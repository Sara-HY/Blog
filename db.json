{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/diag_statistics2.png","path":"images/diag_statistics2.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_1.png","path":"images/leetcode_1.png","modified":0,"renderable":0},{"_id":"source/images/intent_input.png","path":"images/intent_input.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_14.png","path":"images/leetcode_14.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_16.png","path":"images/leetcode_16.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_15.png","path":"images/leetcode_15.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_18.png","path":"images/leetcode_18.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_2.png","path":"images/leetcode_2.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_21.png","path":"images/leetcode_21.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_23.png","path":"images/leetcode_23.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_22.png","path":"images/leetcode_22.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_24.png","path":"images/leetcode_24.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_25.png","path":"images/leetcode_25.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_28.png","path":"images/leetcode_28.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_29.png","path":"images/leetcode_29.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_32.png","path":"images/leetcode_32.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_33.png","path":"images/leetcode_33.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_34.png","path":"images/leetcode_34.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_36_1.png","path":"images/leetcode_36_1.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_4.png","path":"images/leetcode_4.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_41.png","path":"images/leetcode_41.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_43.png","path":"images/leetcode_43.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_454.png","path":"images/leetcode_454.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_5.png","path":"images/leetcode_5.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_6.png","path":"images/leetcode_6.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_7.png","path":"images/leetcode_7.png","modified":0,"renderable":0},{"_id":"source/images/diag_example.png","path":"images/diag_example.png","modified":0,"renderable":0},{"_id":"source/images/diag_statistics.png","path":"images/diag_statistics.png","modified":0,"renderable":0},{"_id":"source/images/diag_kv_retrieval_result.png","path":"images/diag_kv_retrieval_result.png","modified":0,"renderable":0},{"_id":"source/images/intent_frame.png","path":"images/intent_frame.png","modified":0,"renderable":0},{"_id":"source/images/intent_f1.png","path":"images/intent_f1.png","modified":0,"renderable":0},{"_id":"source/images/intent_frame_model.png","path":"images/intent_frame_model.png","modified":0,"renderable":0},{"_id":"source/images/intent_frame_baseline.png","path":"images/intent_frame_baseline.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_31.png","path":"images/leetcode_31.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_19.png","path":"images/leetcode_19.png","modified":0,"renderable":0},{"_id":"source/images/intent_hlstm.png","path":"images/intent_hlstm.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_11.png","path":"images/leetcode_11.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_13.png","path":"images/leetcode_13.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_12.png","path":"images/leetcode_12.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_17.png","path":"images/leetcode_17.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_27.png","path":"images/leetcode_27.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_26.png","path":"images/leetcode_26.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_3.png","path":"images/leetcode_3.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_30.png","path":"images/leetcode_30.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_37.png","path":"images/leetcode_37.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_40.png","path":"images/leetcode_40.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_35.png","path":"images/leetcode_35.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_42.png","path":"images/leetcode_42.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_20.png","path":"images/leetcode_20.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_9.png","path":"images/leetcode_9.png","modified":0,"renderable":0},{"_id":"source/images/mem2seq.png","path":"images/mem2seq.png","modified":0,"renderable":0},{"_id":"source/images/mem2seq_result.png","path":"images/mem2seq_result.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_39.png","path":"images/leetcode_39.png","modified":0,"renderable":0},{"_id":"source/images/intent_dstc_rnn.png","path":"images/intent_dstc_rnn.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_10.png","path":"images/leetcode_10.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_36.png","path":"images/leetcode_36.png","modified":0,"renderable":0},{"_id":"source/images/leetcode_8.png","path":"images/leetcode_8.png","modified":0,"renderable":0},{"_id":"source/images/mem2seq_result2.png","path":"images/mem2seq_result2.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/diag_kv_retrieval.png","path":"images/diag_kv_retrieval.png","modified":0,"renderable":0},{"_id":"source/images/intent_results.png","path":"images/intent_results.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"17bc4d33eee6f54a115a76d635e3c5d6c8c8c605","modified":1545397376972},{"_id":"source/google10bb50e0b38f396b.html","hash":"1ee7a6da9197409280def29033e0a3a5629a7e32","modified":1543289020030},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1543289020047},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543289020048},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543289020048},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543289020048},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1543289020050},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543289020050},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1543289020050},{"_id":"themes/next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1543289020050},{"_id":"themes/next/_config.yml","hash":"530e1a0bdbda92d9e6d77e3a9827b72f6476bc41","modified":1543289020051},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1543289020051},{"_id":"themes/next/bower.json","hash":"23379fec9b4f70bc2611433ac3770445a8ca18d9","modified":1543289020051},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1543289020050},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1543289020057},{"_id":"themes/next/package.json","hash":"901c9bf4743df8f1806b5bcb5e93b54f6aee0ea3","modified":1543289020107},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1543289020048},{"_id":"source/_posts/intent_slot.md","hash":"aa762a757b8cc615b906ecd9bfe93a75afe1e128","modified":1543289020028},{"_id":"source/_posts/leetcode-3Sum.md","hash":"b84ed71f13a5bb2b9f79430af0a31b072148a93c","modified":1543464727782},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1543459329495},{"_id":"source/_posts/first_step.md","hash":"ae1f6cb8bc3541958668d424a19fc85fcff66e0b","modified":1543289186978},{"_id":"source/categories/index.md","hash":"2c2ba4b201afe11dfe8b79a1926dfb1951c8bbb2","modified":1543289020030},{"_id":"source/_posts/leetcode-4SumII.md","hash":"094852f278016ee86913fe8860ff0c0002234352","modified":1544078542218},{"_id":"source/_posts/leetcode-3SumClosest.md","hash":"0ca084d0d387c9ef73ade1611e1faf25fe4415b4","modified":1543470793165},{"_id":"source/_posts/leetcode-ContainerWithMostWater.md","hash":"d5683524deb96ddfa9588c85cdd5646a14a63a2b","modified":1543385401885},{"_id":"source/_posts/leetcode-CombinationSum.md","hash":"e05764292d54728f274de06812efe68e5563865e","modified":1545733254807},{"_id":"source/_posts/leetcode-DivideTwoIntegers.md","hash":"35f6383661b7ac3302da977b36c827d42093d9d0","modified":1545128429003},{"_id":"source/_posts/leetcode-4Sum.md","hash":"1ee4b4efec4acbdbd27cf89d934bb915ca8ef414","modified":1544069716227},{"_id":"source/_posts/leetcode-FindFirstandLastPositionofElementinSortedArray.md","hash":"172083c48ea4166226bcdcef0abda479636b415a","modified":1545373523753},{"_id":"source/_posts/leetcode-FirstMissingPositive.md","hash":"66f50feaf33fcef6ee9fd7bf2003f42b9ca0a1ba","modified":1545741359009},{"_id":"source/_posts/leetcode-ImplementstrStr.md","hash":"adec66d4c5337fdd8130e35aba4e7f1b2ddca39d","modified":1545122460662},{"_id":"source/_posts/leetcode-GenerateParentheses.md","hash":"e7b0e85beb1c278a62cd1eda0ad4709c610bb1fe","modified":1544177173769},{"_id":"source/_posts/leetcode-IntegertoRoman.md","hash":"2c785e1f2191e9ca6ae5f3e727a2a02c8fa38182","modified":1543459289125},{"_id":"source/_posts/leetcode-LetterCombinationsofaPhoneNumber.md","hash":"1a114342aa60bb36d32e7ffe39337823206f03c9","modified":1543582290675},{"_id":"source/_posts/leetcode-LongestCommonPrefix.md","hash":"34533adfbca8aa39d639da16821c6b4848c14e74","modified":1543462529152},{"_id":"source/_posts/leetcode-LongestSubstringWithoutRepeatingCharacters.md","hash":"cce1b0e83efd163e78062eadd7042f9c58505d16","modified":1543299888995},{"_id":"source/_posts/leetcode-LongestPalindromicSubstring.md","hash":"b7eda1b9b1f801f39312dfbe5a75f1badaed96e8","modified":1543299880362},{"_id":"source/_posts/leetcode-LongestValidParentheses.md","hash":"3b00a3388307764ef6d6b298041505a47b716057","modified":1545364862455},{"_id":"source/_posts/leetcode-MergeTwoSortedLists.md","hash":"f44e8a2f20eaabb82c3a906be25d9c6d80f40dc7","modified":1544086139665},{"_id":"source/_posts/leetcode-MergekSortedLists.md","hash":"c48526c5a7f569af608ad9bbc862ced0fea24bcb","modified":1544541091880},{"_id":"source/_posts/leetcode-MedianofTwoSortedArrays.md","hash":"1c3d189d8feb376bbaecc409ed28ed8aa40f5c3b","modified":1543461817414},{"_id":"source/_posts/leetcode-NextPermutation.md","hash":"6012d1d653fd7fba92a120203216d1f2f166bc94","modified":1545360855745},{"_id":"source/_posts/leetcode-PalindromeNumber.md","hash":"5834456b1951699f75c82a5b7f27a665f867986c","modified":1543299898406},{"_id":"source/_posts/leetcode-MultiplyStrings.md","hash":"c181c0e9be7d81605e3a4907c96dcea007ce9f75","modified":1546527756618},{"_id":"source/_posts/leetcode-RegularExpressionMatching.md","hash":"aaf62322edf0bd016858b5de38a9cad22165be07","modified":1543920878581},{"_id":"source/_posts/leetcode-RemoveDuplicatesfromSortedArray.md","hash":"bd2d74e3eb4ba126c12395b0c615afff192753af","modified":1545120803098},{"_id":"source/_posts/leetcode-RemoveElement.md","hash":"6347643a93ba85272293e0fea1f271f90f1d7dc6","modified":1545121202632},{"_id":"source/_posts/leetcode-ReverseInteger.md","hash":"efb316cbdb0ae739ff5163c6a62fa8a6893f5ed9","modified":1543299910710},{"_id":"source/_posts/leetcode-CountandSay.md","hash":"a07f7f560e5d734d2427480290edbcd4bdae1c78","modified":1545648153034},{"_id":"source/_posts/leetcode-ReverseNodesink-Group.md","hash":"32bf7589821db767181cf4392dffd547ad71aca9","modified":1545115710144},{"_id":"source/_posts/leetcode-RemoveNthNodeFromEndofList.md","hash":"2735a9b1da895d5a11961f746ce237b036aecf81","modified":1544082195892},{"_id":"source/_posts/leetcode-RomantoInteger.md","hash":"1584dd7916d628d44d0468d16dddd26a8340e704","modified":1543458978324},{"_id":"source/_posts/leetcode-SearchInsertPosition.md","hash":"a2fbcbbb0bc9207a6551b90a1909c559047b4c8c","modified":1545374272352},{"_id":"source/_posts/leetcode-StringtoInteger.md","hash":"2787b2f217f1b4e833a497e517fc645f0b062eaa","modified":1543299914123},{"_id":"source/_posts/leetcode-SearchinRotatedSortedArray.md","hash":"e6e9da3a2e9aee8b6b3bea7dcc082ff2566b0949","modified":1545371857652},{"_id":"source/_posts/leetcode-SubstringwithConcatenationofAllWords.md","hash":"34be7e05ae6ac18702c573b9d09909e18b893b7e","modified":1545139853446},{"_id":"source/_posts/leetcode-SudokuSolver.md","hash":"45e9952213c4b63b35c39b6149655ab62b602a90","modified":1545644096128},{"_id":"source/_posts/leetcode-ValidParentheses.md","hash":"3c9048ab850b440038294e81b65ea7117c1a6e2a","modified":1544083118012},{"_id":"source/_posts/leetcode-SwapNodesinPairs.md","hash":"d885fb098d8170a510030d00f98875a5ada57ebd","modified":1545795574299},{"_id":"source/_posts/leetcode-ValidSudoku.md","hash":"48e05bd966c8d203b7726e3d75003472e9285f1b","modified":1545399897251},{"_id":"source/_posts/leetcode-TrappingRainWater.md","hash":"9b7f7d005fae2bfdd1016f60cd202d9bbe977155","modified":1546432645778},{"_id":"source/_posts/leetcode-WildcardMatching.md","hash":"96cf1c1042471419422b4d4d50b2ae80605a99fc","modified":1546761711353},{"_id":"source/_posts/leetcode-addtwonumbers.md","hash":"1a6dc38891c924d6d5c5c0d9ce3a2b9d2401db52","modified":1543299578462},{"_id":"source/_posts/leetcode-twosum.md","hash":"c84e9d1266b8ab04a94fcb42b572b9911557462b","modified":1543299921090},{"_id":"source/_posts/task-oriented-dialog-systems.md","hash":"568918d11ae061fada310fc2d1fdf2c7abe73b40","modified":1543289020030},{"_id":"source/_posts/leetcode-ZigZagConversion.md","hash":"2054a9575741c36e9cb6ac8890ef48685d6cf2d4","modified":1543299929850},{"_id":"source/images/diag_statistics2.png","hash":"c003b21e7aa9e513f6ba11c480e559bdacd6832f","modified":1543289020034},{"_id":"source/images/leetcode_1.png","hash":"7ddb17e84181eb4d0ea5c25afaa75bffec0aaa8b","modified":1543289020040},{"_id":"source/images/intent_input.png","hash":"d675f4a9e795484f2c37fcddce7e4017b8793549","modified":1543289020039},{"_id":"source/images/leetcode_14.png","hash":"3d3f55344113cdda0066ebd31e864dd8ffaec7e8","modified":1543459466660},{"_id":"source/images/leetcode_16.png","hash":"d8221d2fb73a7ce34fc59d51184bc491764b5308","modified":1543464788335},{"_id":"source/images/leetcode_15.png","hash":"c29707cff0825a96368a6b20e1cc9863712c456c","modified":1543462677770},{"_id":"source/images/leetcode_18.png","hash":"cab88ccc4aa82ac3f6b09fb9a5151e0e0909d0f5","modified":1543921196929},{"_id":"source/images/leetcode_2.png","hash":"8104864998b47dacc3946c32ababcfa9b5ebb245","modified":1543289020041},{"_id":"source/images/leetcode_21.png","hash":"3473cb34ea043f6c16a7fc0a6956fd0a89c1c2cd","modified":1544083489328},{"_id":"source/images/leetcode_23.png","hash":"487c3432b7c1756a4610849f232f2105e4b84dc6","modified":1544539018550},{"_id":"source/images/leetcode_22.png","hash":"69bcb0880b3d05345b40be93199220716e96311b","modified":1544171782769},{"_id":"source/images/leetcode_24.png","hash":"522467e5ce64da859c8f35871301f93aa3a296df","modified":1544709061218},{"_id":"source/images/leetcode_25.png","hash":"ea4bd1aaa8041cf3bf4ff154ec2e10b77d361caa","modified":1545112426660},{"_id":"source/images/leetcode_28.png","hash":"cb918d02a5385c3b9a7e51b7a68870465b78efab","modified":1545121597971},{"_id":"source/images/leetcode_29.png","hash":"8081d530fca880f297e78105ba845216722b1fa6","modified":1545122566692},{"_id":"source/images/leetcode_32.png","hash":"f642d733b8e34d915a1ca825d1e6edade437218d","modified":1545364860041},{"_id":"source/images/leetcode_33.png","hash":"c82e686acf0e077fc8816caac6fb8fa70cd7a714","modified":1545369091438},{"_id":"source/images/leetcode_34.png","hash":"3b393863535693f8e0de6789d0300bedbe0340d2","modified":1545372206581},{"_id":"source/images/leetcode_36_1.png","hash":"4239a4e946b1e0e51865c6d26f5ffb126bae4fa2","modified":1545397343852},{"_id":"source/images/leetcode_4.png","hash":"864675976c2b1b3b52df0fee2f138dbcfaa65188","modified":1543289020042},{"_id":"source/images/leetcode_41.png","hash":"64e6d045387ce40d8a59883f7ab7dc72fe7f245d","modified":1545734675436},{"_id":"source/images/leetcode_43.png","hash":"18aabda72fd30490b1f2b2ac76878de86afef18e","modified":1546526848571},{"_id":"source/images/leetcode_454.png","hash":"df05a7be515dc197fc840b4bf4c6c303daae8263","modified":1544069628254},{"_id":"source/images/leetcode_5.png","hash":"1b740e42ca94e7d307c3131e9ba5b77774005f03","modified":1543289020042},{"_id":"source/images/leetcode_6.png","hash":"0ce62cedfeef09ab72e938bcc878f1eedadec98e","modified":1543289020043},{"_id":"source/images/leetcode_7.png","hash":"af9a31892c21918c3890a814b006682d53431517","modified":1543289020043},{"_id":"source/tags/index.md","hash":"a646cf4e1109228f6b7c730b86fce3c0bed1dd35","modified":1543289020047},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1543289020049},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1543289020049},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1543289020049},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1543289020049},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543289020050},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1543289020050},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1543289020051},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1543289020052},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1543289020052},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1543289020052},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1543289020053},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1543289020052},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1543289020053},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1543289020053},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1543289020054},{"_id":"themes/next/layout/_layout.swig","hash":"85de0662a1b136277a72f8d8b4b1425a006f377e","modified":1543289020062},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1543289020104},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1543289020105},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1543289020105},{"_id":"themes/next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1543289020106},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1543289020106},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1543289020107},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1543289020107},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1543289020057},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543289020057},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543289020057},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1543289020057},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1543289020058},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1543289020058},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1543289020058},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1543289020058},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1543289020058},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1543289020058},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1543289020058},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1543289020059},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1543289020059},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1543289020059},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1543289020059},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1543289020059},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1543289020060},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1543289020108},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1543289020108},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543289020108},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543289020155},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543289020155},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543289020156},{"_id":"source/images/diag_example.png","hash":"31b505dd9f41ef86fbbc68cb233082fc4384ceca","modified":1543289020031},{"_id":"source/images/diag_statistics.png","hash":"ffea765a9ffd3ff05537247b871b3882b2e02740","modified":1543289020034},{"_id":"source/images/diag_kv_retrieval_result.png","hash":"4ee9f97f0a5a0dd9fb3a8c254aaa34b70d345040","modified":1543289020033},{"_id":"source/images/intent_frame.png","hash":"777c14e60195e28f7a7d70337b317ae8f3de24b7","modified":1543289020036},{"_id":"source/images/intent_f1.png","hash":"65871d1178789be68a95ff07defba29b40bfde42","modified":1543289020036},{"_id":"source/images/intent_frame_model.png","hash":"9c7fa05f1214bf92990c604ce56c03413e8a16db","modified":1543289020038},{"_id":"source/images/intent_frame_baseline.png","hash":"9a156d1c2723e56017e3e6180109b68e3d834942","modified":1543289020037},{"_id":"source/_posts/leetcode-CombinationSumII.md","hash":"b8f759c7e3907dfd39028aa3360d8aa632280d34","modified":1545734597106},{"_id":"source/images/leetcode_31.png","hash":"f7b069384669cb63e74cad8d7e085741157648f0","modified":1545358542112},{"_id":"source/images/leetcode_19.png","hash":"46b24ebf11818ae25a499069dd367c615c612ff6","modified":1544078584061},{"_id":"source/images/intent_hlstm.png","hash":"caa761afe4039ce40ce441c0e0322cb985dd9896","modified":1543289020038},{"_id":"source/images/leetcode_11.png","hash":"8a40e6634dac9df53cf08f6d36ca0279a15f921d","modified":1543375724577},{"_id":"source/images/leetcode_13.png","hash":"96f88529d99488afd8b0480db038bb1adf21a2d4","modified":1543458664924},{"_id":"source/images/leetcode_12.png","hash":"0b3f43a72b5384a44561d2a48f2f6fef3ce160ff","modified":1543391040079},{"_id":"source/images/leetcode_17.png","hash":"d949502f6a8246ef7e881a2662989ad7fcaaa540","modified":1543581371166},{"_id":"source/images/leetcode_27.png","hash":"9a066ce8ea60b15dc8a0e21fc55eee23b5566149","modified":1545121057439},{"_id":"source/images/leetcode_26.png","hash":"71c6ecb7f1bddbce6186617534d8070c0e61cd70","modified":1545115835436},{"_id":"source/images/leetcode_3.png","hash":"cf5d340924afbaab4f36d751648b7db3a32a6b39","modified":1543289020041},{"_id":"source/images/leetcode_30.png","hash":"f2e7573056a47d7f4f137b46b49fb810fa8d02cb","modified":1545128656590},{"_id":"source/images/leetcode_37.png","hash":"14b1d520bf39b87d4c71856f593386346ad78bed","modified":1545399912605},{"_id":"source/images/leetcode_40.png","hash":"ffca14bcb72c147b577ae883e37a5271ed364644","modified":1545733463229},{"_id":"source/images/leetcode_35.png","hash":"427ff4ce97d1d8811c659bce06197a6cee9135b0","modified":1545373651119},{"_id":"source/images/leetcode_42.png","hash":"4db8020ca946703fe655d5debe7f993810e7a4e3","modified":1545796345770},{"_id":"source/images/leetcode_20.png","hash":"398a51b6fae2a4292b44d6135a90b2a41a151a0f","modified":1544082388558},{"_id":"source/images/leetcode_9.png","hash":"28a3e03eb39d10d0e37d54640a4a82cdf1c01ca8","modified":1543240724911},{"_id":"source/images/mem2seq.png","hash":"9cd4573451de0668f7ec93363063566a333b0519","modified":1543289020045},{"_id":"source/images/mem2seq_result.png","hash":"685fd2616a59a850b69e34f03034ca84421536f9","modified":1543289020046},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020142},{"_id":"source/images/leetcode_39.png","hash":"6033c6a25a5027645b9ce20d6742381b2c0489ea","modified":1545730194469},{"_id":"source/images/intent_dstc_rnn.png","hash":"f96016561fbc376a220790b4d58c472f6ab9b5d5","modified":1543289020035},{"_id":"source/images/leetcode_10.png","hash":"11dc2c98bc132577a4d851a6c539df05921ca2a4","modified":1543301993137},{"_id":"source/images/leetcode_36.png","hash":"beebba1481cbacc8d7b67b2a60d339f34e9cf332","modified":1545397212119},{"_id":"source/images/leetcode_8.png","hash":"33698546ff3681d0fa969306fdd95cb4c7e9fde2","modified":1543289020044},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1543289020055},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1543289020054},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1543289020054},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1543289020057},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1543289020056},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543289020061},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543289020061},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543289020060},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1543289020082},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1543289020083},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d15a983de60d4c0bdd23cd31cd49de876ed2310c","modified":1543289020083},{"_id":"source/images/mem2seq_result2.png","hash":"5c09b80aa39ecb507d4b89a352324618ee449a73","modified":1543289020047},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1543289020086},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1543289020086},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1543289020090},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1543289020090},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1543289020092},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1543289020070},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1543289020070},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1543289020071},{"_id":"themes/next/layout/_macro/post.swig","hash":"5767eccaf3951151e01c61189016932e9516c8b9","modified":1543289020072},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1543289020073},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1543289020082},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1543289020082},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1543289020095},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1543289020097},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1543289020098},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1543289020097},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1543289020100},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1543289020100},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543289020101},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543289020101},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1543289020101},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1543289020090},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1543289020054},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1543289020109},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1543289020109},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1543289020109},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1543289020109},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1543289020109},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1543289020110},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1543289020110},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1543289020110},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1543289020110},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1543289020141},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543289020142},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543289020142},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543289020142},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543289020142},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543289020142},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543289020143},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543289020143},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543289020143},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543289020143},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543289020144},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543289020144},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543289020144},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543289020144},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543289020144},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543289020145},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543289020145},{"_id":"source/images/diag_kv_retrieval.png","hash":"a2f728eac72580c85a45923a4df0c9d20ad47857","modified":1543289020032},{"_id":"source/images/intent_results.png","hash":"66dba505ee2feffe151e2bfedf2f3a4520de8bf4","modified":1543289020040},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020091},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020091},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020131},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020141},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020141},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1543289020083},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1543289020084},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1543289020084},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1543289020085},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1543289020085},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1543289020086},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1543289020086},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1543289020087},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543289020087},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543289020088},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543289020088},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543289020089},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543289020088},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543289020089},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1543289020090},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543289020091},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543289020091},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1543289020070},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1543289020063},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543289020092},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1543289020092},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543289020092},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543289020095},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543289020095},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1543289020097},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1543289020097},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1543289020099},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1543289020099},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1543289020099},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543289020104},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543289020103},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1543289020103},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543289020104},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543289020143},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543289020143},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543289020130},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1543289020131},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1543289020141},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1543289020141},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1543289020141},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543289020145},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543289020145},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543289020145},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543289020145},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543289020146},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543289020146},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543289020146},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543289020147},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543289020147},{"_id":"themes/next/source/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1543289020147},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543289020148},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543289020147},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543289020148},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543289020148},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543289020154},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543289020154},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543289020154},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1543289020141},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543289020148},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543289020152},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543289020102},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1543289020102},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1543289020117},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543289020125},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543289020130},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1543289020130},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1543289020130},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1543289020133},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1543289020132},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543289020133},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543289020134},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1543289020134},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1543289020134},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543289020135},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1543289020135},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543289020137},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543289020138},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1543289020141},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1543289020146},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543289020148},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543289020149},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543289020152},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543289020152},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543289020149},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1543289020110},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1543289020111},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543289020151},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543289020153},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543289020151},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1543289020112},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1543289020112},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543289020112},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1543289020114},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543289020114},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543289020115},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1543289020115},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1543289020115},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1543289020116},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543289020116},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1543289020117},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1543289020118},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1543289020118},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543289020120},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1543289020120},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1543289020120},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1543289020121},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1543289020122},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1543289020122},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1543289020123},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1543289020123},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1543289020124},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1543289020124},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1543289020124},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1543289020129},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543289020136},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543289020136},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543289020139},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543289020150},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543289020121},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543289020122}],"Category":[{"name":"Research","_id":"cjqkljh6o0005c3zmklcywnmd"},{"name":"LeetCode","_id":"cjqkljh70000ac3zml9ymvcs8"},{"name":"Note","_id":"cjqkljh74000fc3zm0yukcp0z"}],"Data":[],"Page":[{"_content":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html","source":"google10bb50e0b38f396b.html","raw":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html","date":"2018-11-27T03:23:40.030Z","updated":"2018-11-27T03:23:40.030Z","path":"google10bb50e0b38f396b.html","title":"","comments":1,"layout":"page","_id":"cjqkljgyl0000c3zmzu0r8z8a","content":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html"},{"title":"categories","date":"2018-10-30T09:23:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-10-30 17:23:43\ntype: \"categories\"\n---\n","updated":"2018-11-27T03:23:40.030Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjqkljh6h0002c3zmzos3doci","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-10-30T09:23:49.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-10-30 17:23:49\ntype: \"tags\"\n---\n","updated":"2018-11-27T03:23:40.047Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjqkljh6k0004c3zmzv06pi4f","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Review on Intent Classification and Slot Filling","date":"2018-11-02T02:41:02.000Z","_content":"\n自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。\n\n<!--more-->\n\n意图分类时一个典型的文本分类的问题，常用的方法如下：\n- 基于规则的方法\n 用户人工定义一些匹配规则进行分类。\n- 机器学习的方法\n SVM, Decision Tree等等。\n- 深度学习的方法\n 目前更加推崇使用 End-to-End 的网络进行分类。\n\n最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。\n\n## 中文数据集\n\n### [NLPCC 2018 Task4](http://tcci.ccf.org.cn/conference/2018/taskdata.php) - Spoken Language Understanding in Task-Oriented Dialogue Systems\n\n#### 数据描述 [1]\n这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 **5.8K** 次会话，总共有 **26K** 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。\n\n - 训练集：4705次会话, 21352次叙述。\n - 验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）\n\n数据格式\n``` bash\nsession ID    用户query              意图                       语义槽标注\n    1           打电话\t   phone_call.make_a_phone_call\t        打电话\n    1\t      我想听美观\t        music.play\t          我想听<song>美观</song>\n    1\t      我想听什话\t        music.play\t          我想听<song>什话||神话</song>\n```\n\n#### 评估方法\n这个比赛主要有两个评估方法:\n\n- 意图分类，评估方法为F1值，具体的计算方法如下：\n<div align=center>\n\t<img src=\"/images/intent_f1.png\" width = \"500\"/>\n</div>\n\n- 意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。\n\n#### 主要算法\n总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：\n<div align=center>\n\t<img src=\"/images/intent_results.png\" width = \"500\" align=center/>\n</div>\n\n##### HLSTM-SLU [2]\n这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：\n<div align=center>\n\t<img src=\"/images/intent_hlstm.png\" width = \"500\" align=center/>\n</div>\n\n这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。\n\n- 输入Bi-LSTM\n 输入：Character Embedding + POS + Domain \n 其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：\n\n<div align=center>\n\t<img src=\"/images/intent_input.png\" width = \"500\" align=center/>\n</div>\n\n- Session LSTM\n 输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。\n 输出：**意图的类别**\n\n- 输出Bi-LSTM\n 输入：Session LSTM + 输入Bi-LSTM\n 输出：**槽位标注**\n\n注：并没有直接使用LSTM的结果作为最终的结果，而是根据 **CRF** 预测最优的序列。\n\n**Trick**: 使用 **over sampling** 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。\n\n**结果**：这个模型在两个评估方法的结果最终为94.19%，90.84%。\n\n##### Sogou [3]\n这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用**基于规则**的处理的方法进行标注；剩下的部分采用**基于模型**的方法，具体的模型方法分为5步：\n\n1. 对query进行分词和词性标注（POS）。\n\n2. 寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。\n\n3. 槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。\n\n4. 槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。\n\n5. 意图分类：使用**XGBoost**的方法，根据word embedding，query长度，槽类别进行意图分类。\n\n注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。\n\n**结果**：这个模型在两个评估方法的结果最终为96.11%，94.49%。\n\n## 英文数据集\n\n### [Frame](https://datasets.maluuba.com/Frames/dl)\n\n#### 数据描述 [4]\n这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 **1369** 个对话, 总共有 **19986** 轮。\n\n**数据格式**\n每一次叙述都包含 'author', 'text', 'labels', 'timestamp', 'frames'('frame id', 'frame parent id', 'requests, binary questions, compare requests', 'info'), 'db'字段。其中 'labels'记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， 'info'字段主要为了标注对于槽位值是否为否定的。\n\n**Act类型**：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye.....\n\n\n#### 评估方法\n微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：\n<div align=center>\n\t<img src=\"/images/intent_frame.png\" width = \"300\" align=center/>\n</div>\n\n这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。\n\n#### 主要算法\n\n##### Baseline [4]\n由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。\n<div align=center>\n\t<img src=\"/images/intent_frame_baseline.png\" width = \"300\" align=center/>\n</div>\n\n**结果**：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。\n\n##### Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\n微软的团队随后提出了一个新的模型来处理这个问题。\n\n###### 输入预处理\n\n- Token Encoding：每个词用trigrams的形式表示。如：“hello” -> #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 \n\n- 用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。\n\n- Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。\n\n- Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。\n\n\n###### 模型输入\n\n- 当前轮之前所有的frames （Slot ID, Trigrams ID）\n\n- 叙述 （Trigrams ID）\n\n- 当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）\n\n###### 模型结构\n\n<div align=center>\n\t<img src=\"/images/intent_frame_model.png\" width = \"400\" align=center/>\n</div>\n\n1. 对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\\\(m_f\\\\) （|F| \\* 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\\\(m_{asv}\\\\) （N \\* 256, N为act的数量）来表示acts；\n\n2. 通过计算 \\\\(m_f\\\\) 和 \\\\(m_{asv}\\\\) 的点乘的结果 \\\\(S_m\\\\) （N \\* |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\\\(S_L\\\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。\n\n3. 在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\\\(p_{asv, f}\\\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。\n\n4. 另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\\\(p_{a, f}\\\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。\n\n**注**：这里没有详细介绍实验的一些完善trick，如模型图中的\\\\(g_c\\\\)， \\\\(g_n\\\\)， \\\\(h_d\\\\)， \\\\(h_c\\\\)，详情请看论文。\n\n**结果**：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。\n\n\n### [DSTC](https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/) (Dialog State Tracking Challenge) [6, 7]\n\n#### 数据描述\nDSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。\n- DSTC 1\n 这个数据集包括城市BUS的预定电话中的对话数据。**12963**轮训练数据，**2485**轮测试数据。\n\n- DSTC 2&3\n 在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括**2218**轮训练数据，**1117**轮测试数据；DSTC3包括**3235**轮训练数据，**2275**轮测试数据。数据中的`semantics`字段会对对话中的槽slot和目的act标注。下面是一个数据样例：\n ```bash\n DSTC2 and DSTC3 (Training Set)\n SYS: Which part of town?\n USR: The north uh area\n SYS: Which part of town?\n USR: A cheap place in the north\n SYS: Clown cafe is a cheap restaurant in the north part of town. USR: Do you have any others like that?\n SYS: Galleria is another cheap restaurant in the north. USR: What is their phone number and address?\n ```\n\n- DSTC 4 \n 这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：\n - SVM分类模型\n  输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）\n - 逻辑回归模型 \n  输入：同上。\n - 随机森林模型\n  输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）\n\n- DSTC 5\n 这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。\n\n- DSTC 6\n 这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。\n\n#### 评估方法 （DSTC2 & 3）\n- 准确度：正确预测的轮数占数据总轮数的百分数。\n- L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。\n\n#### 主要算法\n这里我们主要关注在DSTC3上的四个模型。\n\n##### 马尔科夫判别模型 [8]\n<!-- team7 -->\n这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。\n$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\\\(H_t^s\\\\)是在t轮对于槽类型s的假设的集合。\n\n另外，也是本文中比较新的一点是**马尔科夫判别模型**，也就是将生成模型和判别模型相结合：\n\n生成模型： \\\\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\\\)\n\n判别模型： \\\\(P(S_t | O_1^t) = f(O_1^t)\\\\)\n\n马尔科夫判别模型：\\\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\\\)\n\n在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作**标签过耦合**问题。为了解决这个问题，他们设计了一个2步训练法：\n\n- 第一步：训练一个传统的判别模型。\n\n- 第二部：在第一步的基础上训练状态转移特征。\n\n这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 \n\n##### 循环神经网络 [9] \n<!-- team 3 -->\n这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用<slot\\>和<value\\>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。\n\n<div align=center>\n\t<img src=\"/images/intent_dstc_rnn.png\" width = \"400\" align=center/>\n</div>\n\n通过上图的过程，我们可以得出 \"Jamaican food\"标记为 \"s=food and v=jamaican\"，若新的叙述为 \"The Girton area\" 其替换为<slot\\>和<value\\>的概率分布与前者类似，因此可以得出 \"s=area and v=girton\"。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。\n\n##### 基于规则的模型 [10] \n<!-- team 5 -->\n这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，**马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)**。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 \n\n\n##### 知识驱动的基于规则的模型 [11] \n<!-- team 4 -->\n这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n\n\n\n\n[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems\n[2] Learning Dialogue History for Spoken Language Understanding.\n[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.\n[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.\n[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.\n[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.\n[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.\n[8] Markovian discriminative modeling for cross-domain dialog state tracking. \n[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.\n[10] A generalized rule based tracker for dialogue state tracking. \n[11] Knowledge-based dialog state tracking.\n\n","source":"_posts/intent_slot.md","raw":"---\ntitle: Review on Intent Classification and Slot Filling\ndate: 2018-11-02 10:41:02\ncategories: Research\ntags: \n  - intent\n  - slot \n---\n\n自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。\n\n<!--more-->\n\n意图分类时一个典型的文本分类的问题，常用的方法如下：\n- 基于规则的方法\n 用户人工定义一些匹配规则进行分类。\n- 机器学习的方法\n SVM, Decision Tree等等。\n- 深度学习的方法\n 目前更加推崇使用 End-to-End 的网络进行分类。\n\n最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。\n\n## 中文数据集\n\n### [NLPCC 2018 Task4](http://tcci.ccf.org.cn/conference/2018/taskdata.php) - Spoken Language Understanding in Task-Oriented Dialogue Systems\n\n#### 数据描述 [1]\n这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 **5.8K** 次会话，总共有 **26K** 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。\n\n - 训练集：4705次会话, 21352次叙述。\n - 验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）\n\n数据格式\n``` bash\nsession ID    用户query              意图                       语义槽标注\n    1           打电话\t   phone_call.make_a_phone_call\t        打电话\n    1\t      我想听美观\t        music.play\t          我想听<song>美观</song>\n    1\t      我想听什话\t        music.play\t          我想听<song>什话||神话</song>\n```\n\n#### 评估方法\n这个比赛主要有两个评估方法:\n\n- 意图分类，评估方法为F1值，具体的计算方法如下：\n<div align=center>\n\t<img src=\"/images/intent_f1.png\" width = \"500\"/>\n</div>\n\n- 意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。\n\n#### 主要算法\n总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：\n<div align=center>\n\t<img src=\"/images/intent_results.png\" width = \"500\" align=center/>\n</div>\n\n##### HLSTM-SLU [2]\n这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：\n<div align=center>\n\t<img src=\"/images/intent_hlstm.png\" width = \"500\" align=center/>\n</div>\n\n这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。\n\n- 输入Bi-LSTM\n 输入：Character Embedding + POS + Domain \n 其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：\n\n<div align=center>\n\t<img src=\"/images/intent_input.png\" width = \"500\" align=center/>\n</div>\n\n- Session LSTM\n 输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。\n 输出：**意图的类别**\n\n- 输出Bi-LSTM\n 输入：Session LSTM + 输入Bi-LSTM\n 输出：**槽位标注**\n\n注：并没有直接使用LSTM的结果作为最终的结果，而是根据 **CRF** 预测最优的序列。\n\n**Trick**: 使用 **over sampling** 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。\n\n**结果**：这个模型在两个评估方法的结果最终为94.19%，90.84%。\n\n##### Sogou [3]\n这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用**基于规则**的处理的方法进行标注；剩下的部分采用**基于模型**的方法，具体的模型方法分为5步：\n\n1. 对query进行分词和词性标注（POS）。\n\n2. 寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。\n\n3. 槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。\n\n4. 槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。\n\n5. 意图分类：使用**XGBoost**的方法，根据word embedding，query长度，槽类别进行意图分类。\n\n注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。\n\n**结果**：这个模型在两个评估方法的结果最终为96.11%，94.49%。\n\n## 英文数据集\n\n### [Frame](https://datasets.maluuba.com/Frames/dl)\n\n#### 数据描述 [4]\n这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 **1369** 个对话, 总共有 **19986** 轮。\n\n**数据格式**\n每一次叙述都包含 'author', 'text', 'labels', 'timestamp', 'frames'('frame id', 'frame parent id', 'requests, binary questions, compare requests', 'info'), 'db'字段。其中 'labels'记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， 'info'字段主要为了标注对于槽位值是否为否定的。\n\n**Act类型**：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye.....\n\n\n#### 评估方法\n微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：\n<div align=center>\n\t<img src=\"/images/intent_frame.png\" width = \"300\" align=center/>\n</div>\n\n这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。\n\n#### 主要算法\n\n##### Baseline [4]\n由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。\n<div align=center>\n\t<img src=\"/images/intent_frame_baseline.png\" width = \"300\" align=center/>\n</div>\n\n**结果**：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。\n\n##### Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\n微软的团队随后提出了一个新的模型来处理这个问题。\n\n###### 输入预处理\n\n- Token Encoding：每个词用trigrams的形式表示。如：“hello” -> #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 \n\n- 用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。\n\n- Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。\n\n- Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。\n\n\n###### 模型输入\n\n- 当前轮之前所有的frames （Slot ID, Trigrams ID）\n\n- 叙述 （Trigrams ID）\n\n- 当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）\n\n###### 模型结构\n\n<div align=center>\n\t<img src=\"/images/intent_frame_model.png\" width = \"400\" align=center/>\n</div>\n\n1. 对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\\\(m_f\\\\) （|F| \\* 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\\\(m_{asv}\\\\) （N \\* 256, N为act的数量）来表示acts；\n\n2. 通过计算 \\\\(m_f\\\\) 和 \\\\(m_{asv}\\\\) 的点乘的结果 \\\\(S_m\\\\) （N \\* |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\\\(S_L\\\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。\n\n3. 在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\\\(p_{asv, f}\\\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。\n\n4. 另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\\\(p_{a, f}\\\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。\n\n**注**：这里没有详细介绍实验的一些完善trick，如模型图中的\\\\(g_c\\\\)， \\\\(g_n\\\\)， \\\\(h_d\\\\)， \\\\(h_c\\\\)，详情请看论文。\n\n**结果**：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。\n\n\n### [DSTC](https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/) (Dialog State Tracking Challenge) [6, 7]\n\n#### 数据描述\nDSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。\n- DSTC 1\n 这个数据集包括城市BUS的预定电话中的对话数据。**12963**轮训练数据，**2485**轮测试数据。\n\n- DSTC 2&3\n 在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括**2218**轮训练数据，**1117**轮测试数据；DSTC3包括**3235**轮训练数据，**2275**轮测试数据。数据中的`semantics`字段会对对话中的槽slot和目的act标注。下面是一个数据样例：\n ```bash\n DSTC2 and DSTC3 (Training Set)\n SYS: Which part of town?\n USR: The north uh area\n SYS: Which part of town?\n USR: A cheap place in the north\n SYS: Clown cafe is a cheap restaurant in the north part of town. USR: Do you have any others like that?\n SYS: Galleria is another cheap restaurant in the north. USR: What is their phone number and address?\n ```\n\n- DSTC 4 \n 这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：\n - SVM分类模型\n  输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）\n - 逻辑回归模型 \n  输入：同上。\n - 随机森林模型\n  输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）\n\n- DSTC 5\n 这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。\n\n- DSTC 6\n 这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。\n\n#### 评估方法 （DSTC2 & 3）\n- 准确度：正确预测的轮数占数据总轮数的百分数。\n- L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。\n\n#### 主要算法\n这里我们主要关注在DSTC3上的四个模型。\n\n##### 马尔科夫判别模型 [8]\n<!-- team7 -->\n这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。\n$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\\\(H_t^s\\\\)是在t轮对于槽类型s的假设的集合。\n\n另外，也是本文中比较新的一点是**马尔科夫判别模型**，也就是将生成模型和判别模型相结合：\n\n生成模型： \\\\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\\\)\n\n判别模型： \\\\(P(S_t | O_1^t) = f(O_1^t)\\\\)\n\n马尔科夫判别模型：\\\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\\\)\n\n在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作**标签过耦合**问题。为了解决这个问题，他们设计了一个2步训练法：\n\n- 第一步：训练一个传统的判别模型。\n\n- 第二部：在第一步的基础上训练状态转移特征。\n\n这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 \n\n##### 循环神经网络 [9] \n<!-- team 3 -->\n这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用<slot\\>和<value\\>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。\n\n<div align=center>\n\t<img src=\"/images/intent_dstc_rnn.png\" width = \"400\" align=center/>\n</div>\n\n通过上图的过程，我们可以得出 \"Jamaican food\"标记为 \"s=food and v=jamaican\"，若新的叙述为 \"The Girton area\" 其替换为<slot\\>和<value\\>的概率分布与前者类似，因此可以得出 \"s=area and v=girton\"。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。\n\n##### 基于规则的模型 [10] \n<!-- team 5 -->\n这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，**马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)**。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 \n\n\n##### 知识驱动的基于规则的模型 [11] \n<!-- team 4 -->\n这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n\n\n\n\n[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems\n[2] Learning Dialogue History for Spoken Language Understanding.\n[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.\n[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.\n[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.\n[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.\n[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.\n[8] Markovian discriminative modeling for cross-domain dialog state tracking. \n[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.\n[10] A generalized rule based tracker for dialogue state tracking. \n[11] Knowledge-based dialog state tracking.\n\n","slug":"intent_slot","published":1,"updated":"2018-11-27T03:23:40.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh6c0001c3zm6b9fmc1x","content":"<p>自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。</p>\n<a id=\"more\"></a>\n<p>意图分类时一个典型的文本分类的问题，常用的方法如下：</p>\n<ul>\n<li>基于规则的方法<br>用户人工定义一些匹配规则进行分类。</li>\n<li>机器学习的方法<br>SVM, Decision Tree等等。</li>\n<li>深度学习的方法<br>目前更加推崇使用 End-to-End 的网络进行分类。</li>\n</ul>\n<p>最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。</p>\n<h2 id=\"中文数据集\"><a href=\"#中文数据集\" class=\"headerlink\" title=\"中文数据集\"></a>中文数据集</h2><h3 id=\"NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\"><a href=\"#NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\" class=\"headerlink\" title=\"NLPCC 2018 Task4 - Spoken Language Understanding in Task-Oriented Dialogue Systems\"></a><a href=\"http://tcci.ccf.org.cn/conference/2018/taskdata.php\" target=\"_blank\" rel=\"noopener\">NLPCC 2018 Task4</a> - Spoken Language Understanding in Task-Oriented Dialogue Systems</h3><h4 id=\"数据描述-1\"><a href=\"#数据描述-1\" class=\"headerlink\" title=\"数据描述 [1]\"></a>数据描述 [1]</h4><p>这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 <strong>5.8K</strong> 次会话，总共有 <strong>26K</strong> 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。</p>\n<ul>\n<li>训练集：4705次会话, 21352次叙述。</li>\n<li>验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）</li>\n</ul>\n<p>数据格式<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">session ID    用户query              意图                       语义槽标注</span><br><span class=\"line\">    1           打电话\t   phone_call.make_a_phone_call\t        打电话</span><br><span class=\"line\">    1\t      我想听美观\t        music.play\t          我想听&lt;song&gt;美观&lt;/song&gt;</span><br><span class=\"line\">    1\t      我想听什话\t        music.play\t          我想听&lt;song&gt;什话||神话&lt;/song&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"评估方法\"><a href=\"#评估方法\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>这个比赛主要有两个评估方法:</p>\n<ul>\n<li><p>意图分类，评估方法为F1值，具体的计算方法如下：</p>\n<div align=\"center\"><br>  <img src=\"/images/intent_f1.png\" width=\"500\"><br></div>\n</li>\n<li><p>意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。</p>\n</li>\n</ul>\n<h4 id=\"主要算法\"><a href=\"#主要算法\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_results.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h5 id=\"HLSTM-SLU-2\"><a href=\"#HLSTM-SLU-2\" class=\"headerlink\" title=\"HLSTM-SLU [2]\"></a>HLSTM-SLU [2]</h5><p>这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_hlstm.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。</p>\n<ul>\n<li>输入Bi-LSTM<br>输入：Character Embedding + POS + Domain<br>其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：</li>\n</ul>\n<div align=\"center\"><br>    <img src=\"/images/intent_input.png\" width=\"500\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Session LSTM<br>输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。<br>输出：<strong>意图的类别</strong></p>\n</li>\n<li><p>输出Bi-LSTM<br>输入：Session LSTM + 输入Bi-LSTM<br>输出：<strong>槽位标注</strong></p>\n</li>\n</ul>\n<p>注：并没有直接使用LSTM的结果作为最终的结果，而是根据 <strong>CRF</strong> 预测最优的序列。</p>\n<p><strong>Trick</strong>: 使用 <strong>over sampling</strong> 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为94.19%，90.84%。</p>\n<h5 id=\"Sogou-3\"><a href=\"#Sogou-3\" class=\"headerlink\" title=\"Sogou [3]\"></a>Sogou [3]</h5><p>这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用<strong>基于规则</strong>的处理的方法进行标注；剩下的部分采用<strong>基于模型</strong>的方法，具体的模型方法分为5步：</p>\n<ol>\n<li><p>对query进行分词和词性标注（POS）。</p>\n</li>\n<li><p>寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。</p>\n</li>\n<li><p>槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。</p>\n</li>\n<li><p>槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。</p>\n</li>\n<li><p>意图分类：使用<strong>XGBoost</strong>的方法，根据word embedding，query长度，槽类别进行意图分类。</p>\n</li>\n</ol>\n<p>注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为96.11%，94.49%。</p>\n<h2 id=\"英文数据集\"><a href=\"#英文数据集\" class=\"headerlink\" title=\"英文数据集\"></a>英文数据集</h2><h3 id=\"Frame\"><a href=\"#Frame\" class=\"headerlink\" title=\"Frame\"></a><a href=\"https://datasets.maluuba.com/Frames/dl\" target=\"_blank\" rel=\"noopener\">Frame</a></h3><h4 id=\"数据描述-4\"><a href=\"#数据描述-4\" class=\"headerlink\" title=\"数据描述 [4]\"></a>数据描述 [4]</h4><p>这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 <strong>1369</strong> 个对话, 总共有 <strong>19986</strong> 轮。</p>\n<p><strong>数据格式</strong><br>每一次叙述都包含 ‘author’, ‘text’, ‘labels’, ‘timestamp’, ‘frames’(‘frame id’, ‘frame parent id’, ‘requests, binary questions, compare requests’, ‘info’), ‘db’字段。其中 ‘labels’记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， ‘info’字段主要为了标注对于槽位值是否为否定的。</p>\n<p><strong>Act类型</strong>：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye…..</p>\n<h4 id=\"评估方法-1\"><a href=\"#评估方法-1\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p>这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。</p>\n<h4 id=\"主要算法-1\"><a href=\"#主要算法-1\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><h5 id=\"Baseline-4\"><a href=\"#Baseline-4\" class=\"headerlink\" title=\"Baseline [4]\"></a>Baseline [4]</h5><p>由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame_baseline.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。</p>\n<h5 id=\"Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\"><a href=\"#Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\" class=\"headerlink\" title=\"Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\"></a>Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]</h5><p>微软的团队随后提出了一个新的模型来处理这个问题。</p>\n<h6 id=\"输入预处理\"><a href=\"#输入预处理\" class=\"headerlink\" title=\"输入预处理\"></a>输入预处理</h6><ul>\n<li><p>Token Encoding：每个词用trigrams的形式表示。如：“hello” -&gt; #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 </p>\n</li>\n<li><p>用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。</p>\n</li>\n<li><p>Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。</p>\n</li>\n<li><p>Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。</p>\n</li>\n</ul>\n<h6 id=\"模型输入\"><a href=\"#模型输入\" class=\"headerlink\" title=\"模型输入\"></a>模型输入</h6><ul>\n<li><p>当前轮之前所有的frames （Slot ID, Trigrams ID）</p>\n</li>\n<li><p>叙述 （Trigrams ID）</p>\n</li>\n<li><p>当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）</p>\n</li>\n</ul>\n<h6 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h6><div align=\"center\"><br>    <img src=\"/images/intent_frame_model.png\" width=\"400\" align=\"center/\"><br></div>\n\n<ol>\n<li><p>对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\(m_f\\) （|F| * 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\(m_{asv}\\) （N * 256, N为act的数量）来表示acts；</p>\n</li>\n<li><p>通过计算 \\(m_f\\) 和 \\(m_{asv}\\) 的点乘的结果 \\(S_m\\) （N * |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\(S_L\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。</p>\n</li>\n<li><p>在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\(p_{asv, f}\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。</p>\n</li>\n<li><p>另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\(p_{a, f}\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。</p>\n</li>\n</ol>\n<p><strong>注</strong>：这里没有详细介绍实验的一些完善trick，如模型图中的\\(g_c\\)， \\(g_n\\)， \\(h_d\\)， \\(h_c\\)，详情请看论文。</p>\n<p><strong>结果</strong>：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。</p>\n<h3 id=\"DSTC-Dialog-State-Tracking-Challenge-6-7\"><a href=\"#DSTC-Dialog-State-Tracking-Challenge-6-7\" class=\"headerlink\" title=\"DSTC (Dialog State Tracking Challenge) [6, 7]\"></a><a href=\"https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/\" target=\"_blank\" rel=\"noopener\">DSTC</a> (Dialog State Tracking Challenge) [6, 7]</h3><h4 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h4><p>DSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。</p>\n<ul>\n<li><p>DSTC 1<br>这个数据集包括城市BUS的预定电话中的对话数据。<strong>12963</strong>轮训练数据，<strong>2485</strong>轮测试数据。</p>\n</li>\n<li><p>DSTC 2&amp;3<br>在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括<strong>2218</strong>轮训练数据，<strong>1117</strong>轮测试数据；DSTC3包括<strong>3235</strong>轮训练数据，<strong>2275</strong>轮测试数据。数据中的<code>semantics</code>字段会对对话中的槽slot和目的act标注。下面是一个数据样例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DSTC2 and DSTC3 (Training Set)</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: The north uh area</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: A cheap place <span class=\"keyword\">in</span> the north</span><br><span class=\"line\">SYS: Clown cafe is a cheap restaurant <span class=\"keyword\">in</span> the north part of town. USR: Do you have any others like that?</span><br><span class=\"line\">SYS: Galleria is another cheap restaurant <span class=\"keyword\">in</span> the north. USR: What is their phone number and address?</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DSTC 4<br>这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：</p>\n<ul>\n<li>SVM分类模型<br>输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）</li>\n<li>逻辑回归模型<br>输入：同上。</li>\n<li>随机森林模型<br>输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）</li>\n</ul>\n</li>\n<li><p>DSTC 5<br>这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。</p>\n</li>\n<li><p>DSTC 6<br>这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。</p>\n</li>\n</ul>\n<h4 id=\"评估方法-（DSTC2-amp-3）\"><a href=\"#评估方法-（DSTC2-amp-3）\" class=\"headerlink\" title=\"评估方法 （DSTC2 &amp; 3）\"></a>评估方法 （DSTC2 &amp; 3）</h4><ul>\n<li>准确度：正确预测的轮数占数据总轮数的百分数。</li>\n<li>L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。</li>\n</ul>\n<h4 id=\"主要算法-2\"><a href=\"#主要算法-2\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>这里我们主要关注在DSTC3上的四个模型。</p>\n<h5 id=\"马尔科夫判别模型-8\"><a href=\"#马尔科夫判别模型-8\" class=\"headerlink\" title=\"马尔科夫判别模型 [8]\"></a>马尔科夫判别模型 [8]</h5><!-- team7 -->\n<p>这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。<br>$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\(H_t^s\\)是在t轮对于槽类型s的假设的集合。</p>\n<p>另外，也是本文中比较新的一点是<strong>马尔科夫判别模型</strong>，也就是将生成模型和判别模型相结合：</p>\n<p>生成模型： \\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\)</p>\n<p>判别模型： \\(P(S_t | O_1^t) = f(O_1^t)\\)</p>\n<p>马尔科夫判别模型：\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\)</p>\n<p>在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作<strong>标签过耦合</strong>问题。为了解决这个问题，他们设计了一个2步训练法：</p>\n<ul>\n<li><p>第一步：训练一个传统的判别模型。</p>\n</li>\n<li><p>第二部：在第一步的基础上训练状态转移特征。</p>\n</li>\n</ul>\n<p>这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 </p>\n<h5 id=\"循环神经网络-9\"><a href=\"#循环神经网络-9\" class=\"headerlink\" title=\"循环神经网络 [9]\"></a>循环神经网络 [9]</h5><!-- team 3 -->\n<p>这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用&lt;slot>和&lt;value>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_dstc_rnn.png\" width=\"400\" align=\"center/\"><br></div>\n\n<p>通过上图的过程，我们可以得出 “Jamaican food”标记为 “s=food and v=jamaican”，若新的叙述为 “The Girton area” 其替换为&lt;slot>和&lt;value>的概率分布与前者类似，因此可以得出 “s=area and v=girton”。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。</p>\n<h5 id=\"基于规则的模型-10\"><a href=\"#基于规则的模型-10\" class=\"headerlink\" title=\"基于规则的模型 [10]\"></a>基于规则的模型 [10]</h5><!-- team 5 -->\n<p>这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，<strong>马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)</strong>。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 </p>\n<h5 id=\"知识驱动的基于规则的模型-11\"><a href=\"#知识驱动的基于规则的模型-11\" class=\"headerlink\" title=\"知识驱动的基于规则的模型 [11]\"></a>知识驱动的基于规则的模型 [11]</h5><!-- team 4 -->\n<p>这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。</p>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems<br>[2] Learning Dialogue History for Spoken Language Understanding.<br>[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.<br>[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.<br>[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.<br>[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.<br>[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.<br>[8] Markovian discriminative modeling for cross-domain dialog state tracking.<br>[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.<br>[10] A generalized rule based tracker for dialogue state tracking.<br>[11] Knowledge-based dialog state tracking.</p>\n","site":{"data":{}},"excerpt":"<p>自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。</p>","more":"<p>意图分类时一个典型的文本分类的问题，常用的方法如下：</p>\n<ul>\n<li>基于规则的方法<br>用户人工定义一些匹配规则进行分类。</li>\n<li>机器学习的方法<br>SVM, Decision Tree等等。</li>\n<li>深度学习的方法<br>目前更加推崇使用 End-to-End 的网络进行分类。</li>\n</ul>\n<p>最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。</p>\n<h2 id=\"中文数据集\"><a href=\"#中文数据集\" class=\"headerlink\" title=\"中文数据集\"></a>中文数据集</h2><h3 id=\"NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\"><a href=\"#NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\" class=\"headerlink\" title=\"NLPCC 2018 Task4 - Spoken Language Understanding in Task-Oriented Dialogue Systems\"></a><a href=\"http://tcci.ccf.org.cn/conference/2018/taskdata.php\" target=\"_blank\" rel=\"noopener\">NLPCC 2018 Task4</a> - Spoken Language Understanding in Task-Oriented Dialogue Systems</h3><h4 id=\"数据描述-1\"><a href=\"#数据描述-1\" class=\"headerlink\" title=\"数据描述 [1]\"></a>数据描述 [1]</h4><p>这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 <strong>5.8K</strong> 次会话，总共有 <strong>26K</strong> 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。</p>\n<ul>\n<li>训练集：4705次会话, 21352次叙述。</li>\n<li>验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）</li>\n</ul>\n<p>数据格式<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">session ID    用户query              意图                       语义槽标注</span><br><span class=\"line\">    1           打电话\t   phone_call.make_a_phone_call\t        打电话</span><br><span class=\"line\">    1\t      我想听美观\t        music.play\t          我想听&lt;song&gt;美观&lt;/song&gt;</span><br><span class=\"line\">    1\t      我想听什话\t        music.play\t          我想听&lt;song&gt;什话||神话&lt;/song&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"评估方法\"><a href=\"#评估方法\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>这个比赛主要有两个评估方法:</p>\n<ul>\n<li><p>意图分类，评估方法为F1值，具体的计算方法如下：</p>\n<div align=\"center\"><br>  <img src=\"/images/intent_f1.png\" width=\"500\"><br></div>\n</li>\n<li><p>意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。</p>\n</li>\n</ul>\n<h4 id=\"主要算法\"><a href=\"#主要算法\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_results.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h5 id=\"HLSTM-SLU-2\"><a href=\"#HLSTM-SLU-2\" class=\"headerlink\" title=\"HLSTM-SLU [2]\"></a>HLSTM-SLU [2]</h5><p>这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_hlstm.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。</p>\n<ul>\n<li>输入Bi-LSTM<br>输入：Character Embedding + POS + Domain<br>其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：</li>\n</ul>\n<div align=\"center\"><br>    <img src=\"/images/intent_input.png\" width=\"500\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Session LSTM<br>输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。<br>输出：<strong>意图的类别</strong></p>\n</li>\n<li><p>输出Bi-LSTM<br>输入：Session LSTM + 输入Bi-LSTM<br>输出：<strong>槽位标注</strong></p>\n</li>\n</ul>\n<p>注：并没有直接使用LSTM的结果作为最终的结果，而是根据 <strong>CRF</strong> 预测最优的序列。</p>\n<p><strong>Trick</strong>: 使用 <strong>over sampling</strong> 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为94.19%，90.84%。</p>\n<h5 id=\"Sogou-3\"><a href=\"#Sogou-3\" class=\"headerlink\" title=\"Sogou [3]\"></a>Sogou [3]</h5><p>这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用<strong>基于规则</strong>的处理的方法进行标注；剩下的部分采用<strong>基于模型</strong>的方法，具体的模型方法分为5步：</p>\n<ol>\n<li><p>对query进行分词和词性标注（POS）。</p>\n</li>\n<li><p>寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。</p>\n</li>\n<li><p>槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。</p>\n</li>\n<li><p>槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。</p>\n</li>\n<li><p>意图分类：使用<strong>XGBoost</strong>的方法，根据word embedding，query长度，槽类别进行意图分类。</p>\n</li>\n</ol>\n<p>注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为96.11%，94.49%。</p>\n<h2 id=\"英文数据集\"><a href=\"#英文数据集\" class=\"headerlink\" title=\"英文数据集\"></a>英文数据集</h2><h3 id=\"Frame\"><a href=\"#Frame\" class=\"headerlink\" title=\"Frame\"></a><a href=\"https://datasets.maluuba.com/Frames/dl\" target=\"_blank\" rel=\"noopener\">Frame</a></h3><h4 id=\"数据描述-4\"><a href=\"#数据描述-4\" class=\"headerlink\" title=\"数据描述 [4]\"></a>数据描述 [4]</h4><p>这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 <strong>1369</strong> 个对话, 总共有 <strong>19986</strong> 轮。</p>\n<p><strong>数据格式</strong><br>每一次叙述都包含 ‘author’, ‘text’, ‘labels’, ‘timestamp’, ‘frames’(‘frame id’, ‘frame parent id’, ‘requests, binary questions, compare requests’, ‘info’), ‘db’字段。其中 ‘labels’记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， ‘info’字段主要为了标注对于槽位值是否为否定的。</p>\n<p><strong>Act类型</strong>：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye…..</p>\n<h4 id=\"评估方法-1\"><a href=\"#评估方法-1\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p>这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。</p>\n<h4 id=\"主要算法-1\"><a href=\"#主要算法-1\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><h5 id=\"Baseline-4\"><a href=\"#Baseline-4\" class=\"headerlink\" title=\"Baseline [4]\"></a>Baseline [4]</h5><p>由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame_baseline.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。</p>\n<h5 id=\"Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\"><a href=\"#Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\" class=\"headerlink\" title=\"Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\"></a>Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]</h5><p>微软的团队随后提出了一个新的模型来处理这个问题。</p>\n<h6 id=\"输入预处理\"><a href=\"#输入预处理\" class=\"headerlink\" title=\"输入预处理\"></a>输入预处理</h6><ul>\n<li><p>Token Encoding：每个词用trigrams的形式表示。如：“hello” -&gt; #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 </p>\n</li>\n<li><p>用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。</p>\n</li>\n<li><p>Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。</p>\n</li>\n<li><p>Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。</p>\n</li>\n</ul>\n<h6 id=\"模型输入\"><a href=\"#模型输入\" class=\"headerlink\" title=\"模型输入\"></a>模型输入</h6><ul>\n<li><p>当前轮之前所有的frames （Slot ID, Trigrams ID）</p>\n</li>\n<li><p>叙述 （Trigrams ID）</p>\n</li>\n<li><p>当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）</p>\n</li>\n</ul>\n<h6 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h6><div align=\"center\"><br>    <img src=\"/images/intent_frame_model.png\" width=\"400\" align=\"center/\"><br></div>\n\n<ol>\n<li><p>对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\(m_f\\) （|F| * 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\(m_{asv}\\) （N * 256, N为act的数量）来表示acts；</p>\n</li>\n<li><p>通过计算 \\(m_f\\) 和 \\(m_{asv}\\) 的点乘的结果 \\(S_m\\) （N * |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\(S_L\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。</p>\n</li>\n<li><p>在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\(p_{asv, f}\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。</p>\n</li>\n<li><p>另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\(p_{a, f}\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。</p>\n</li>\n</ol>\n<p><strong>注</strong>：这里没有详细介绍实验的一些完善trick，如模型图中的\\(g_c\\)， \\(g_n\\)， \\(h_d\\)， \\(h_c\\)，详情请看论文。</p>\n<p><strong>结果</strong>：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。</p>\n<h3 id=\"DSTC-Dialog-State-Tracking-Challenge-6-7\"><a href=\"#DSTC-Dialog-State-Tracking-Challenge-6-7\" class=\"headerlink\" title=\"DSTC (Dialog State Tracking Challenge) [6, 7]\"></a><a href=\"https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/\" target=\"_blank\" rel=\"noopener\">DSTC</a> (Dialog State Tracking Challenge) [6, 7]</h3><h4 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h4><p>DSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。</p>\n<ul>\n<li><p>DSTC 1<br>这个数据集包括城市BUS的预定电话中的对话数据。<strong>12963</strong>轮训练数据，<strong>2485</strong>轮测试数据。</p>\n</li>\n<li><p>DSTC 2&amp;3<br>在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括<strong>2218</strong>轮训练数据，<strong>1117</strong>轮测试数据；DSTC3包括<strong>3235</strong>轮训练数据，<strong>2275</strong>轮测试数据。数据中的<code>semantics</code>字段会对对话中的槽slot和目的act标注。下面是一个数据样例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DSTC2 and DSTC3 (Training Set)</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: The north uh area</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: A cheap place <span class=\"keyword\">in</span> the north</span><br><span class=\"line\">SYS: Clown cafe is a cheap restaurant <span class=\"keyword\">in</span> the north part of town. USR: Do you have any others like that?</span><br><span class=\"line\">SYS: Galleria is another cheap restaurant <span class=\"keyword\">in</span> the north. USR: What is their phone number and address?</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DSTC 4<br>这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：</p>\n<ul>\n<li>SVM分类模型<br>输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）</li>\n<li>逻辑回归模型<br>输入：同上。</li>\n<li>随机森林模型<br>输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）</li>\n</ul>\n</li>\n<li><p>DSTC 5<br>这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。</p>\n</li>\n<li><p>DSTC 6<br>这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。</p>\n</li>\n</ul>\n<h4 id=\"评估方法-（DSTC2-amp-3）\"><a href=\"#评估方法-（DSTC2-amp-3）\" class=\"headerlink\" title=\"评估方法 （DSTC2 &amp; 3）\"></a>评估方法 （DSTC2 &amp; 3）</h4><ul>\n<li>准确度：正确预测的轮数占数据总轮数的百分数。</li>\n<li>L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。</li>\n</ul>\n<h4 id=\"主要算法-2\"><a href=\"#主要算法-2\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>这里我们主要关注在DSTC3上的四个模型。</p>\n<h5 id=\"马尔科夫判别模型-8\"><a href=\"#马尔科夫判别模型-8\" class=\"headerlink\" title=\"马尔科夫判别模型 [8]\"></a>马尔科夫判别模型 [8]</h5><!-- team7 -->\n<p>这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。<br>$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\(H_t^s\\)是在t轮对于槽类型s的假设的集合。</p>\n<p>另外，也是本文中比较新的一点是<strong>马尔科夫判别模型</strong>，也就是将生成模型和判别模型相结合：</p>\n<p>生成模型： \\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\)</p>\n<p>判别模型： \\(P(S_t | O_1^t) = f(O_1^t)\\)</p>\n<p>马尔科夫判别模型：\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\)</p>\n<p>在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作<strong>标签过耦合</strong>问题。为了解决这个问题，他们设计了一个2步训练法：</p>\n<ul>\n<li><p>第一步：训练一个传统的判别模型。</p>\n</li>\n<li><p>第二部：在第一步的基础上训练状态转移特征。</p>\n</li>\n</ul>\n<p>这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 </p>\n<h5 id=\"循环神经网络-9\"><a href=\"#循环神经网络-9\" class=\"headerlink\" title=\"循环神经网络 [9]\"></a>循环神经网络 [9]</h5><!-- team 3 -->\n<p>这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用&lt;slot>和&lt;value>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_dstc_rnn.png\" width=\"400\" align=\"center/\"><br></div>\n\n<p>通过上图的过程，我们可以得出 “Jamaican food”标记为 “s=food and v=jamaican”，若新的叙述为 “The Girton area” 其替换为&lt;slot>和&lt;value>的概率分布与前者类似，因此可以得出 “s=area and v=girton”。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。</p>\n<h5 id=\"基于规则的模型-10\"><a href=\"#基于规则的模型-10\" class=\"headerlink\" title=\"基于规则的模型 [10]\"></a>基于规则的模型 [10]</h5><!-- team 5 -->\n<p>这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，<strong>马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)</strong>。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 </p>\n<h5 id=\"知识驱动的基于规则的模型-11\"><a href=\"#知识驱动的基于规则的模型-11\" class=\"headerlink\" title=\"知识驱动的基于规则的模型 [11]\"></a>知识驱动的基于规则的模型 [11]</h5><!-- team 4 -->\n<p>这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。</p>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems<br>[2] Learning Dialogue History for Spoken Language Understanding.<br>[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.<br>[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.<br>[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.<br>[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.<br>[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.<br>[8] Markovian discriminative modeling for cross-domain dialog state tracking.<br>[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.<br>[10] A generalized rule based tracker for dialogue state tracking.<br>[11] Knowledge-based dialog state tracking.</p>"},{"title":"LeetCode_3Sum","date":"2018-11-29T03:36:41.000Z","_content":"\n## [3Sum](https://leetcode.com/problems/3sum/)\n\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n（寻找数组中三个数的和为0的所有组合）\n\n<!--more-->\n\nNote:\nThe solution set must not contain duplicate triplets.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_15.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中`l , r = i + 1, len(nums) - 1,`，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\\\(O(n^2)\\\\)。\n  - i 去重： if i > 0 and nums[i] ==  nums[i-1]: continue\n  - l 去重： while l < r and nums[l] == nums[l-1]: l += 1\n  - r 去重： while l < r and nums[r] == nums[r+1]: r -= 1\n\n\n```python\nclass Solution(object):\n    def threeSum(self, nums):\n        result = []\n        nums.sort()\n        if len(nums) < 3:\n            return result\n\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]: continue\n            l, r = i + 1, len(nums) - 1\n            while l < r :\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    result.append([nums[i] ,nums[l] ,nums[r]])\n                    l += 1; r -= 1\n                    while l < r and nums[l] == nums[l - 1]: l += 1\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\n                elif s < 0 :\n                    l += 1\n                else:\n                    r -= 1\n        return result\n```","source":"_posts/leetcode-3Sum.md","raw":"---\ntitle: LeetCode_3Sum\ndate: 2018-11-29 11:36:41\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - two pointers\n---\n\n## [3Sum](https://leetcode.com/problems/3sum/)\n\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n（寻找数组中三个数的和为0的所有组合）\n\n<!--more-->\n\nNote:\nThe solution set must not contain duplicate triplets.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_15.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中`l , r = i + 1, len(nums) - 1,`，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\\\(O(n^2)\\\\)。\n  - i 去重： if i > 0 and nums[i] ==  nums[i-1]: continue\n  - l 去重： while l < r and nums[l] == nums[l-1]: l += 1\n  - r 去重： while l < r and nums[r] == nums[r+1]: r -= 1\n\n\n```python\nclass Solution(object):\n    def threeSum(self, nums):\n        result = []\n        nums.sort()\n        if len(nums) < 3:\n            return result\n\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]: continue\n            l, r = i + 1, len(nums) - 1\n            while l < r :\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    result.append([nums[i] ,nums[l] ,nums[r]])\n                    l += 1; r -= 1\n                    while l < r and nums[l] == nums[l - 1]: l += 1\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\n                elif s < 0 :\n                    l += 1\n                else:\n                    r -= 1\n        return result\n```","slug":"leetcode-3Sum","published":1,"updated":"2018-11-29T04:12:07.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh6i0003c3zma2honljq","content":"<h2 id=\"3Sum\"><a href=\"#3Sum\" class=\"headerlink\" title=\"3Sum\"></a><a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">3Sum</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>（寻找数组中三个数的和为0的所有组合）</p>\n<a id=\"more\"></a>\n<p>Note:<br>The solution set must not contain duplicate triplets.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_15.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中<code>l , r = i + 1, len(nums) - 1,</code>，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\(O(n^2)\\)。</p>\n<ul>\n<li>i 去重： if i &gt; 0 and nums[i] ==  nums[i-1]: continue</li>\n<li>l 去重： while l &lt; r and nums[l] == nums[l-1]: l += 1</li>\n<li>r 去重： while l &lt; r and nums[r] == nums[r+1]: r -= 1</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums) - <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            l, r = i + <span class=\"number\">1</span>, len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r :</span><br><span class=\"line\">                s = nums[i] + nums[l] + nums[r]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    result.append([nums[i] ,nums[l] ,nums[r]])</span><br><span class=\"line\">                    l += <span class=\"number\">1</span>; r -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l - <span class=\"number\">1</span>]: l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[r] == nums[r + <span class=\"number\">1</span>]: r -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> s &lt; <span class=\"number\">0</span> :</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"3Sum\"><a href=\"#3Sum\" class=\"headerlink\" title=\"3Sum\"></a><a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">3Sum</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>（寻找数组中三个数的和为0的所有组合）</p>","more":"<p>Note:<br>The solution set must not contain duplicate triplets.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_15.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中<code>l , r = i + 1, len(nums) - 1,</code>，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\(O(n^2)\\)。</p>\n<ul>\n<li>i 去重： if i &gt; 0 and nums[i] ==  nums[i-1]: continue</li>\n<li>l 去重： while l &lt; r and nums[l] == nums[l-1]: l += 1</li>\n<li>r 去重： while l &lt; r and nums[r] == nums[r+1]: r -= 1</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums) - <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            l, r = i + <span class=\"number\">1</span>, len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r :</span><br><span class=\"line\">                s = nums[i] + nums[l] + nums[r]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    result.append([nums[i] ,nums[l] ,nums[r]])</span><br><span class=\"line\">                    l += <span class=\"number\">1</span>; r -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l - <span class=\"number\">1</span>]: l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[r] == nums[r + <span class=\"number\">1</span>]: r -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> s &lt; <span class=\"number\">0</span> :</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"First Step to Establish the Blog","date":"2018-11-01T02:41:02.000Z","_content":"\n让我们搭一个美美的博客，一起写写写吧~~~\n\n<!-- more --> \n\n## Requirement\n\n​\tbrew, hexo, Node.js\n\n### Hexo项目\n\n``` bash\n$ hexo init           # 新建博客目录\n$ hexo new \"postname\" # 生成postname.md文件\n$ hexo clean          # 清空生成的网页\n$ hexo generate       # 根据当前目录下文件生成静态网页\n$ hexo server \t      # 启动服务器\n```\n\n通过访问localhost:4000可以在本地调试。文件目录`source`下的`_posts`中可以添加用户新增加的博客内容（Markdown语法）。\n\nMore info: [Heox](https://hexo.io/docs/)\n\n### 修改主题\n\n``` bash\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n修改`config.yml`配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：\n``` bash\nauto_excerpt:   # 可通过 <!-- more --> 标签自动截断, 增加阅读全文按钮。\n  enable: true\n  length: 150\n\nbusuanzi_count: # 监听网页浏览量。\n  enable: true\n```\n\n### 添加新的导航栏\n\n``` bash\n$ hexo new page tags   # 添加tags标签页\n```\n\n修改`source`目录下的`tags`中的`index.md`如下：\n\n```\n---\ntitle: tags\ndate: 2018-10-30 17:23:49\ntype: \"tags\"\n---\n```\n\n在菜单中添加链接。编辑`config.yml`配置文件中的menu属性，如下：\n\n```\nmenu:\n  home: /\n  archives: /archives\n  tags : /tags\n```\n\n### 部署到 Github\n\n修改`config.yml`配置文件中的deploy属性：\n\n``` bash\ndeploy:\n  type: git \n  repo: https://github.com/test/test.github.io.git  # github路径\n```\n\n通过下面的指令实现部署：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo deploy\n```\n\n### Google 收录博客网站\n\n1. 添加站点：用自己的 Google 帐号登陆 [Webmaster Central](https://www.google.com/webmasters/verification/home?hl=en)。\n\n2. 验证站点: 将网站上的验证文件放在 `source` 文件下，在站点配置文件配置如下：\n``` bash\nskip_render: google10bb50e0b38f396b.html\n```\n\n3. 产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在`config.yml`里配置一下：\n``` bash\nnpm install hexo-generator-sitemap --save\n```\n\t``` bash\n\tsitemap:\n\t    path: sitemap.xml\n\t```\n\n4. 重新编译生成\n``` bash\nhexo generate\n```\n","source":"_posts/first_step.md","raw":"---\ntitle: First Step to Establish the Blog\ndate: 2018-11-01 10:41:02\ncategories: Note\ntags:\n  - tools\n---\n\n让我们搭一个美美的博客，一起写写写吧~~~\n\n<!-- more --> \n\n## Requirement\n\n​\tbrew, hexo, Node.js\n\n### Hexo项目\n\n``` bash\n$ hexo init           # 新建博客目录\n$ hexo new \"postname\" # 生成postname.md文件\n$ hexo clean          # 清空生成的网页\n$ hexo generate       # 根据当前目录下文件生成静态网页\n$ hexo server \t      # 启动服务器\n```\n\n通过访问localhost:4000可以在本地调试。文件目录`source`下的`_posts`中可以添加用户新增加的博客内容（Markdown语法）。\n\nMore info: [Heox](https://hexo.io/docs/)\n\n### 修改主题\n\n``` bash\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n修改`config.yml`配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：\n``` bash\nauto_excerpt:   # 可通过 <!-- more --> 标签自动截断, 增加阅读全文按钮。\n  enable: true\n  length: 150\n\nbusuanzi_count: # 监听网页浏览量。\n  enable: true\n```\n\n### 添加新的导航栏\n\n``` bash\n$ hexo new page tags   # 添加tags标签页\n```\n\n修改`source`目录下的`tags`中的`index.md`如下：\n\n```\n---\ntitle: tags\ndate: 2018-10-30 17:23:49\ntype: \"tags\"\n---\n```\n\n在菜单中添加链接。编辑`config.yml`配置文件中的menu属性，如下：\n\n```\nmenu:\n  home: /\n  archives: /archives\n  tags : /tags\n```\n\n### 部署到 Github\n\n修改`config.yml`配置文件中的deploy属性：\n\n``` bash\ndeploy:\n  type: git \n  repo: https://github.com/test/test.github.io.git  # github路径\n```\n\n通过下面的指令实现部署：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo deploy\n```\n\n### Google 收录博客网站\n\n1. 添加站点：用自己的 Google 帐号登陆 [Webmaster Central](https://www.google.com/webmasters/verification/home?hl=en)。\n\n2. 验证站点: 将网站上的验证文件放在 `source` 文件下，在站点配置文件配置如下：\n``` bash\nskip_render: google10bb50e0b38f396b.html\n```\n\n3. 产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在`config.yml`里配置一下：\n``` bash\nnpm install hexo-generator-sitemap --save\n```\n\t``` bash\n\tsitemap:\n\t    path: sitemap.xml\n\t```\n\n4. 重新编译生成\n``` bash\nhexo generate\n```\n","slug":"first_step","published":1,"updated":"2018-11-27T03:26:26.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh6r0007c3zmh02uewyo","content":"<p>让我们搭一个美美的博客，一起写写写吧~~~</p>\n<a id=\"more\"></a> \n<h2 id=\"Requirement\"><a href=\"#Requirement\" class=\"headerlink\" title=\"Requirement\"></a>Requirement</h2><p>​    brew, hexo, Node.js</p>\n<h3 id=\"Hexo项目\"><a href=\"#Hexo项目\" class=\"headerlink\" title=\"Hexo项目\"></a>Hexo项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init           <span class=\"comment\"># 新建博客目录</span></span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postname\"</span> <span class=\"comment\"># 生成postname.md文件</span></span><br><span class=\"line\">$ hexo clean          <span class=\"comment\"># 清空生成的网页</span></span><br><span class=\"line\">$ hexo generate       <span class=\"comment\"># 根据当前目录下文件生成静态网页</span></span><br><span class=\"line\">$ hexo server \t      <span class=\"comment\"># 启动服务器</span></span><br></pre></td></tr></table></figure>\n<p>通过访问localhost:4000可以在本地调试。文件目录<code>source</code>下的<code>_posts</code>中可以添加用户新增加的博客内容（Markdown语法）。</p>\n<p>More info: <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">Heox</a></p>\n<h3 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>修改<code>config.yml</code>配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_excerpt:   <span class=\"comment\"># 可通过 &lt;!-- more --&gt; 标签自动截断, 增加阅读全文按钮。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  length: 150</span><br><span class=\"line\"></span><br><span class=\"line\">busuanzi_count: <span class=\"comment\"># 监听网页浏览量。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加新的导航栏\"><a href=\"#添加新的导航栏\" class=\"headerlink\" title=\"添加新的导航栏\"></a>添加新的导航栏</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page tags   <span class=\"comment\"># 添加tags标签页</span></span><br></pre></td></tr></table></figure>\n<p>修改<code>source</code>目录下的<code>tags</code>中的<code>index.md</code>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2018-10-30 17:23:49</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>在菜单中添加链接。编辑<code>config.yml</code>配置文件中的menu属性，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /</span><br><span class=\"line\">  archives: /archives</span><br><span class=\"line\">  tags : /tags</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署到-Github\"><a href=\"#部署到-Github\" class=\"headerlink\" title=\"部署到 Github\"></a>部署到 Github</h3><p>修改<code>config.yml</code>配置文件中的deploy属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git </span><br><span class=\"line\">  repo: https://github.com/<span class=\"built_in\">test</span>/test.github.io.git  <span class=\"comment\"># github路径</span></span><br></pre></td></tr></table></figure>\n<p>通过下面的指令实现部署：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Google-收录博客网站\"><a href=\"#Google-收录博客网站\" class=\"headerlink\" title=\"Google 收录博客网站\"></a>Google 收录博客网站</h3><ol>\n<li><p>添加站点：用自己的 Google 帐号登陆 <a href=\"https://www.google.com/webmasters/verification/home?hl=en\" target=\"_blank\" rel=\"noopener\">Webmaster Central</a>。</p>\n</li>\n<li><p>验证站点: 将网站上的验证文件放在 <code>source</code> 文件下，在站点配置文件配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip_render: google10bb50e0b38f396b.html</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在<code>config.yml</code>里配置一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">    path: sitemap.xml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>让我们搭一个美美的博客，一起写写写吧~~~</p>","more":"<h2 id=\"Requirement\"><a href=\"#Requirement\" class=\"headerlink\" title=\"Requirement\"></a>Requirement</h2><p>​    brew, hexo, Node.js</p>\n<h3 id=\"Hexo项目\"><a href=\"#Hexo项目\" class=\"headerlink\" title=\"Hexo项目\"></a>Hexo项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init           <span class=\"comment\"># 新建博客目录</span></span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postname\"</span> <span class=\"comment\"># 生成postname.md文件</span></span><br><span class=\"line\">$ hexo clean          <span class=\"comment\"># 清空生成的网页</span></span><br><span class=\"line\">$ hexo generate       <span class=\"comment\"># 根据当前目录下文件生成静态网页</span></span><br><span class=\"line\">$ hexo server \t      <span class=\"comment\"># 启动服务器</span></span><br></pre></td></tr></table></figure>\n<p>通过访问localhost:4000可以在本地调试。文件目录<code>source</code>下的<code>_posts</code>中可以添加用户新增加的博客内容（Markdown语法）。</p>\n<p>More info: <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">Heox</a></p>\n<h3 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>修改<code>config.yml</code>配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_excerpt:   <span class=\"comment\"># 可通过 &lt;!-- more --&gt; 标签自动截断, 增加阅读全文按钮。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  length: 150</span><br><span class=\"line\"></span><br><span class=\"line\">busuanzi_count: <span class=\"comment\"># 监听网页浏览量。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加新的导航栏\"><a href=\"#添加新的导航栏\" class=\"headerlink\" title=\"添加新的导航栏\"></a>添加新的导航栏</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page tags   <span class=\"comment\"># 添加tags标签页</span></span><br></pre></td></tr></table></figure>\n<p>修改<code>source</code>目录下的<code>tags</code>中的<code>index.md</code>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2018-10-30 17:23:49</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>在菜单中添加链接。编辑<code>config.yml</code>配置文件中的menu属性，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /</span><br><span class=\"line\">  archives: /archives</span><br><span class=\"line\">  tags : /tags</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署到-Github\"><a href=\"#部署到-Github\" class=\"headerlink\" title=\"部署到 Github\"></a>部署到 Github</h3><p>修改<code>config.yml</code>配置文件中的deploy属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git </span><br><span class=\"line\">  repo: https://github.com/<span class=\"built_in\">test</span>/test.github.io.git  <span class=\"comment\"># github路径</span></span><br></pre></td></tr></table></figure>\n<p>通过下面的指令实现部署：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Google-收录博客网站\"><a href=\"#Google-收录博客网站\" class=\"headerlink\" title=\"Google 收录博客网站\"></a>Google 收录博客网站</h3><ol>\n<li><p>添加站点：用自己的 Google 帐号登陆 <a href=\"https://www.google.com/webmasters/verification/home?hl=en\" target=\"_blank\" rel=\"noopener\">Webmaster Central</a>。</p>\n</li>\n<li><p>验证站点: 将网站上的验证文件放在 <code>source</code> 文件下，在站点配置文件配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip_render: google10bb50e0b38f396b.html</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在<code>config.yml</code>里配置一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">    path: sitemap.xml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"LeetCode_4SumII","date":"2018-12-06T04:12:13.000Z","_content":"\n## [4SumII](https://leetcode.com/problems/4sum-ii/)\n\nGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.\n（寻找4个数组中四个数的和为0的组合个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_454.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 两次双重循环\n将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        \n        dict = {}\n        for i in range(n):\n            for j in range(n):\n                sum =  A[i] + B[j]\n                if sum not in dict:\n                    dict[sum] = 1\n                else:\n                    dict[sum] += 1\n        \n        result = 0\n        for i in range(n):\n            for j in range(n):\n                sum = C[i] + D[j]\n                if -sum in dict:\n                    result += dict[-sum]\n                \n        return result \n```\n\n### 1. 两次双重循环2\n将上述过程中的解法中的通过 index索引改为 python中的 **`in`** 遍历。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n\n        dict = {}\n        for a in A:\n            for b in B:\n                if a + b not in dict:\n                    dict[a + b] = 1\n                else:\n                    dict[a + b] += 1\n        \n        result = 0\n        for c in C:\n            for d in D:\n                if -c-d in dict:\n                    result += dict[-c-d]\n                \n        return result\n```\n","source":"_posts/leetcode-4SumII.md","raw":"---\ntitle: LeetCode_4SumII\ndate: 2018-12-06 12:12:13\ncategories: LeetCode\ntags: \n  - medium\n  - binary search\n  - hash table\n---\n\n## [4SumII](https://leetcode.com/problems/4sum-ii/)\n\nGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.\n（寻找4个数组中四个数的和为0的组合个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_454.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 两次双重循环\n将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        \n        dict = {}\n        for i in range(n):\n            for j in range(n):\n                sum =  A[i] + B[j]\n                if sum not in dict:\n                    dict[sum] = 1\n                else:\n                    dict[sum] += 1\n        \n        result = 0\n        for i in range(n):\n            for j in range(n):\n                sum = C[i] + D[j]\n                if -sum in dict:\n                    result += dict[-sum]\n                \n        return result \n```\n\n### 1. 两次双重循环2\n将上述过程中的解法中的通过 index索引改为 python中的 **`in`** 遍历。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n\n        dict = {}\n        for a in A:\n            for b in B:\n                if a + b not in dict:\n                    dict[a + b] = 1\n                else:\n                    dict[a + b] += 1\n        \n        result = 0\n        for c in C:\n            for d in D:\n                if -c-d in dict:\n                    result += dict[-c-d]\n                \n        return result\n```\n","slug":"leetcode-4SumII","published":1,"updated":"2018-12-06T06:42:22.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh6v0008c3zmu5eguc2r","content":"<h2 id=\"4SumII\"><a href=\"#4SumII\" class=\"headerlink\" title=\"4SumII\"></a><a href=\"https://leetcode.com/problems/4sum-ii/\" target=\"_blank\" rel=\"noopener\">4SumII</a></h2><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.<br>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.<br>（寻找4个数组中四个数的和为0的组合个数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_454.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-两次双重循环\"><a href=\"#1-两次双重循环\" class=\"headerlink\" title=\"1. 两次双重循环\"></a>1. 两次双重循环</h3><p>将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(A)</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum =  A[i] + B[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum = C[i] + D[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-sum]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-两次双重循环2\"><a href=\"#1-两次双重循环2\" class=\"headerlink\" title=\"1. 两次双重循环2\"></a>1. 两次双重循环2</h3><p>将上述过程中的解法中的通过 index索引改为 python中的 <strong><code>in</code></strong> 遍历。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> a + b <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[a + b] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[a + b] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> C:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> D:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -c-d <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-c-d]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"4SumII\"><a href=\"#4SumII\" class=\"headerlink\" title=\"4SumII\"></a><a href=\"https://leetcode.com/problems/4sum-ii/\" target=\"_blank\" rel=\"noopener\">4SumII</a></h2><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.<br>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.<br>（寻找4个数组中四个数的和为0的组合个数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_454.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-两次双重循环\"><a href=\"#1-两次双重循环\" class=\"headerlink\" title=\"1. 两次双重循环\"></a>1. 两次双重循环</h3><p>将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(A)</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum =  A[i] + B[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum = C[i] + D[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-sum]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-两次双重循环2\"><a href=\"#1-两次双重循环2\" class=\"headerlink\" title=\"1. 两次双重循环2\"></a>1. 两次双重循环2</h3><p>将上述过程中的解法中的通过 index索引改为 python中的 <strong><code>in</code></strong> 遍历。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> a + b <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[a + b] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[a + b] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> C:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> D:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -c-d <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-c-d]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Container With Most Water","date":"2018-11-28T03:20:13.000Z","_content":"\n## [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)\n\nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and n is at least 2.\n（求最大矩形面积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_11.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力轮循\n双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        n = len(height)\n        for j in range(n):\n            for i in range(j):\n                height_min = min(height[i], height[j])\n                area = max(area, height_min*(j-i))\n                \n        return area\n```\n\n### 2. 头尾指针\n在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        p_left = 0\n        p_right = len(height) - 1\n        \n        while p_left < p_right:\n            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))\n            if height[p_left] < height[p_right]:\n                p_left += 1\n            else:\n                p_right -= 1\n                \n        return area\n```","source":"_posts/leetcode-ContainerWithMostWater.md","raw":"---\ntitle: LeetCode_Container With Most Water\ndate: 2018-11-28 11:20:13\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - pointer\n---\n\n## [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)\n\nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and n is at least 2.\n（求最大矩形面积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_11.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力轮循\n双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        n = len(height)\n        for j in range(n):\n            for i in range(j):\n                height_min = min(height[i], height[j])\n                area = max(area, height_min*(j-i))\n                \n        return area\n```\n\n### 2. 头尾指针\n在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        p_left = 0\n        p_right = len(height) - 1\n        \n        while p_left < p_right:\n            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))\n            if height[p_left] < height[p_right]:\n                p_left += 1\n            else:\n                p_right -= 1\n                \n        return area\n```","slug":"leetcode-ContainerWithMostWater","published":1,"updated":"2018-11-28T06:10:01.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh6z0009c3zmekqhvlku","content":"<h2 id=\"Container-With-Most-Water\"><a href=\"#Container-With-Most-Water\" class=\"headerlink\" title=\"Container With Most Water\"></a><a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">Container With Most Water</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and n is at least 2.<br>（求最大矩形面积）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_11.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力轮循\"><a href=\"#1-暴力轮循\" class=\"headerlink\" title=\"1. 暴力轮循\"></a>1. 暴力轮循</h3><p>双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\(O(n^2)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(height)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">                height_min = min(height[i], height[j])</span><br><span class=\"line\">                area = max(area, height_min*(j-i))</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-头尾指针\"><a href=\"#2-头尾指针\" class=\"headerlink\" title=\"2. 头尾指针\"></a>2. 头尾指针</h3><p>在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        p_left = <span class=\"number\">0</span></span><br><span class=\"line\">        p_right = len(height) - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_left &lt; p_right:</span><br><span class=\"line\">            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[p_left] &lt; height[p_right]:</span><br><span class=\"line\">                p_left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Container-With-Most-Water\"><a href=\"#Container-With-Most-Water\" class=\"headerlink\" title=\"Container With Most Water\"></a><a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">Container With Most Water</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and n is at least 2.<br>（求最大矩形面积）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_11.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力轮循\"><a href=\"#1-暴力轮循\" class=\"headerlink\" title=\"1. 暴力轮循\"></a>1. 暴力轮循</h3><p>双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\(O(n^2)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(height)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">                height_min = min(height[i], height[j])</span><br><span class=\"line\">                area = max(area, height_min*(j-i))</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-头尾指针\"><a href=\"#2-头尾指针\" class=\"headerlink\" title=\"2. 头尾指针\"></a>2. 头尾指针</h3><p>在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        p_left = <span class=\"number\">0</span></span><br><span class=\"line\">        p_right = len(height) - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_left &lt; p_right:</span><br><span class=\"line\">            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[p_left] &lt; height[p_right]:</span><br><span class=\"line\">                p_left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_3Sum Closest","date":"2018-11-29T04:11:39.000Z","_content":"\n## [3Sum Closest](https://leetcode.com/problems/3sum-closest/)\n\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n（寻找数组中三个数的和为target的一个组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_16.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n排序后三个指针遍历数组。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            l = i + 1\n            r = n - 1\n            while l < r:\n                threesum = nums[l] + nums[r] + nums[i]\n                if threesum == target :\n                    return threesum\n\n                if abs(threesum - target) < abs(result - target):\n                \tresult = threesum\n\n                if threesum > target:\n                \tr -= 1\n                else:\n                \tl += 1\n                \n        return result\n```","source":"_posts/leetcode-3SumClosest.md","raw":"---\ntitle: LeetCode_3Sum Closest\ndate: 2018-11-29 12:11:39\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - two pointers\n---\n\n## [3Sum Closest](https://leetcode.com/problems/3sum-closest/)\n\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n（寻找数组中三个数的和为target的一个组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_16.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n排序后三个指针遍历数组。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            l = i + 1\n            r = n - 1\n            while l < r:\n                threesum = nums[l] + nums[r] + nums[i]\n                if threesum == target :\n                    return threesum\n\n                if abs(threesum - target) < abs(result - target):\n                \tresult = threesum\n\n                if threesum > target:\n                \tr -= 1\n                else:\n                \tl += 1\n                \n        return result\n```","slug":"leetcode-3SumClosest","published":1,"updated":"2018-11-29T05:53:13.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh71000cc3zmrxl3ae0e","content":"<h2 id=\"3Sum-Closest\"><a href=\"#3Sum-Closest\" class=\"headerlink\" title=\"3Sum Closest\"></a><a href=\"https://leetcode.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">3Sum Closest</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br>（寻找数组中三个数的和为target的一个组合）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_16.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>排序后三个指针遍历数组。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        result = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n - <span class=\"number\">2</span>):</span><br><span class=\"line\">            l = i + <span class=\"number\">1</span></span><br><span class=\"line\">            r = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                threesum = nums[l] + nums[r] + nums[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum == target :</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(threesum - target) &lt; abs(result - target):</span><br><span class=\"line\">                \tresult = threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum &gt; target:</span><br><span class=\"line\">                \tr -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                \tl += <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"3Sum-Closest\"><a href=\"#3Sum-Closest\" class=\"headerlink\" title=\"3Sum Closest\"></a><a href=\"https://leetcode.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">3Sum Closest</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br>（寻找数组中三个数的和为target的一个组合）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_16.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>排序后三个指针遍历数组。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        result = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n - <span class=\"number\">2</span>):</span><br><span class=\"line\">            l = i + <span class=\"number\">1</span></span><br><span class=\"line\">            r = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                threesum = nums[l] + nums[r] + nums[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum == target :</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(threesum - target) &lt; abs(result - target):</span><br><span class=\"line\">                \tresult = threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum &gt; target:</span><br><span class=\"line\">                \tr -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                \tl += <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Combination Sum","date":"2018-12-25T09:15:38.000Z","_content":"\n# [Combination Sum](https://leetcode.com/problems/combination-sum/)\n\nGiven a **set** of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates **unlimited** number of times.\n（从集合中挑选和为特定值的数字组合，同一元素可选多次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_39.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 回溯法\n在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。\n\n```python\nclass Solution:\n    def backtracking(self, re, candidates, target):\n        if target == 0:\n        \tself.result.append(list(re))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tcontinue\n        \t\tre.append(candidates[i])\n        \t\tself.backtracking(re, candidates[i:], target - candidates[i])\n        \t\tre.pop()\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n        self.backtracking([], candidates, target)\n        \n        return self.result\n```\n","source":"_posts/leetcode-CombinationSum.md","raw":"---\ntitle: LeetCode_Combination Sum\ndate: 2018-12-25 17:15:38\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n---\n\n# [Combination Sum](https://leetcode.com/problems/combination-sum/)\n\nGiven a **set** of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates **unlimited** number of times.\n（从集合中挑选和为特定值的数字组合，同一元素可选多次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_39.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 回溯法\n在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。\n\n```python\nclass Solution:\n    def backtracking(self, re, candidates, target):\n        if target == 0:\n        \tself.result.append(list(re))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tcontinue\n        \t\tre.append(candidates[i])\n        \t\tself.backtracking(re, candidates[i:], target - candidates[i])\n        \t\tre.pop()\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n        self.backtracking([], candidates, target)\n        \n        return self.result\n```\n","slug":"leetcode-CombinationSum","published":1,"updated":"2018-12-25T10:20:54.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh72000dc3zm7e546yi1","content":"<h1 id=\"Combination-Sum\"><a href=\"#Combination-Sum\" class=\"headerlink\" title=\"Combination Sum\"></a><a href=\"https://leetcode.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">Combination Sum</a></h1><p>Given a <strong>set</strong> of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates <strong>unlimited</strong> number of times.<br>（从集合中挑选和为特定值的数字组合，同一元素可选多次）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_39.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span>:</span><br><span class=\"line\">        \tself.result.append(list(re))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">        \t\tre.append(candidates[i])</span><br><span class=\"line\">        \t\tself.backtracking(re, candidates[i:], target - candidates[i])</span><br><span class=\"line\">        \t\tre.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">        self.backtracking([], candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"Combination-Sum\"><a href=\"#Combination-Sum\" class=\"headerlink\" title=\"Combination Sum\"></a><a href=\"https://leetcode.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">Combination Sum</a></h1><p>Given a <strong>set</strong> of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates <strong>unlimited</strong> number of times.<br>（从集合中挑选和为特定值的数字组合，同一元素可选多次）</p>","more":"<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_39.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span>:</span><br><span class=\"line\">        \tself.result.append(list(re))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">        \t\tre.append(candidates[i])</span><br><span class=\"line\">        \t\tself.backtracking(re, candidates[i:], target - candidates[i])</span><br><span class=\"line\">        \t\tre.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">        self.backtracking([], candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_4Sum","date":"2018-12-04T10:56:06.000Z","_content":"\n## [4Sum](hhttps://leetcode.com/problems/4sum/)\n\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n（寻找数组中四个数的和为target的组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_18.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 四个指针\n可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\\\(O(n^3)\\\\)。\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()\n        for i in range(n):\n            for j in range(i-2):\n                k = j + 1\n                l = i - 1\n                while k < l:\n                    sum = nums[i] + nums[k] + nums[l] + nums[j]\n                    if sum == target:\n                        if [nums[j], nums[k], nums[l], nums[i]] not in result:\n                            result.append([nums[j], nums[k], nums[l], nums[i]])\n                        k+=1\n                        l-=1\n                    elif sum > target:\n                        l-=1\n                    else:\n                        k+=1\n        \n        return result\n```\n\n### 2. 两次 2Sum + Dict\n换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\\\(O(n^2)\\\\)。 \n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()   \n     \n        dict = {}\n        for i in range(n):\n            for j in range(i):\n                sum = nums[i] + nums[j]\n                if sum not in dict:\n                    dict[sum] = [[j, i]]\n                else:\n                    dict[sum].append([j, i])\n        \n        for i in range(n):\n            for j in range(i):\n                sum = target - nums[i] - nums[j]\n                if sum in dict:\n                    for list in dict[sum]:\n                        if list[0] > i and [nums[j],nums[i], nums[list[0]], nums[list[1]]] not in result:\n                            result.append([nums[j],nums[i],nums[list[0]],nums[list[1]]])\n\n        return result\n```\n\n### 3. 递归 N-sum\n这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 \n\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def findNsum(l, r, target, N, result, results):\n            if r-l+1<N or N<2 or nums[l]*N > target or nums[r]*N < target:\n                return\n            if N == 2:\n                while l < r:\n                    sum = nums[l] + nums[r]\n                    if sum == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l+=1\n                    elif sum < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else:\n                for i in range(l, r+1):\n                    if i == l or (i > l and nums[i-1] != nums[i]):\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\n            \n        nums.sort()\n        results = []\n        findNsum(0, len(nums)-1, target, 4, [], results)\n        \n        return results \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-4Sum.md","raw":"---\ntitle: LeetCode_4Sum\ndate: 2018-12-04 18:56:06\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - hash table\n  - two pointers\n---\n\n## [4Sum](hhttps://leetcode.com/problems/4sum/)\n\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n（寻找数组中四个数的和为target的组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_18.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 四个指针\n可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\\\(O(n^3)\\\\)。\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()\n        for i in range(n):\n            for j in range(i-2):\n                k = j + 1\n                l = i - 1\n                while k < l:\n                    sum = nums[i] + nums[k] + nums[l] + nums[j]\n                    if sum == target:\n                        if [nums[j], nums[k], nums[l], nums[i]] not in result:\n                            result.append([nums[j], nums[k], nums[l], nums[i]])\n                        k+=1\n                        l-=1\n                    elif sum > target:\n                        l-=1\n                    else:\n                        k+=1\n        \n        return result\n```\n\n### 2. 两次 2Sum + Dict\n换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\\\(O(n^2)\\\\)。 \n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()   \n     \n        dict = {}\n        for i in range(n):\n            for j in range(i):\n                sum = nums[i] + nums[j]\n                if sum not in dict:\n                    dict[sum] = [[j, i]]\n                else:\n                    dict[sum].append([j, i])\n        \n        for i in range(n):\n            for j in range(i):\n                sum = target - nums[i] - nums[j]\n                if sum in dict:\n                    for list in dict[sum]:\n                        if list[0] > i and [nums[j],nums[i], nums[list[0]], nums[list[1]]] not in result:\n                            result.append([nums[j],nums[i],nums[list[0]],nums[list[1]]])\n\n        return result\n```\n\n### 3. 递归 N-sum\n这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 \n\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def findNsum(l, r, target, N, result, results):\n            if r-l+1<N or N<2 or nums[l]*N > target or nums[r]*N < target:\n                return\n            if N == 2:\n                while l < r:\n                    sum = nums[l] + nums[r]\n                    if sum == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l+=1\n                    elif sum < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else:\n                for i in range(l, r+1):\n                    if i == l or (i > l and nums[i-1] != nums[i]):\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\n            \n        nums.sort()\n        results = []\n        findNsum(0, len(nums)-1, target, 4, [], results)\n        \n        return results \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-4Sum","published":1,"updated":"2018-12-06T04:15:16.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh74000hc3zm1bl1aiko","content":"<h2 id=\"4Sum\"><a href=\"#4Sum\" class=\"headerlink\" title=\"4Sum\"></a><a href=\"hhttps://leetcode.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">4Sum</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br>（寻找数组中四个数的和为target的组合）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_18.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-四个指针\"><a href=\"#1-四个指针\" class=\"headerlink\" title=\"1. 四个指针\"></a>1. 四个指针</h3><p>可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\(O(n^3)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-2</span>):</span><br><span class=\"line\">                k = j + <span class=\"number\">1</span></span><br><span class=\"line\">                l = i - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> k &lt; l:</span><br><span class=\"line\">                    sum = nums[i] + nums[k] + nums[l] + nums[j]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> [nums[j], nums[k], nums[l], nums[i]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j], nums[k], nums[l], nums[i]])</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &gt; target:</span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-两次-2Sum-Dict\"><a href=\"#2-两次-2Sum-Dict\" class=\"headerlink\" title=\"2. 两次 2Sum + Dict\"></a>2. 两次 2Sum + Dict</h3><p>换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()   </span><br><span class=\"line\">     </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = nums[i] + nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = [[j, i]]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum].append([j, i])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = target - nums[i] - nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> dict[sum]:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> list[<span class=\"number\">0</span>] &gt; i <span class=\"keyword\">and</span> [nums[j],nums[i], nums[list[<span class=\"number\">0</span>]], nums[list[<span class=\"number\">1</span>]]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j],nums[i],nums[list[<span class=\"number\">0</span>]],nums[list[<span class=\"number\">1</span>]]])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-递归-N-sum\"><a href=\"#3-递归-N-sum\" class=\"headerlink\" title=\"3. 递归 N-sum\"></a>3. 递归 N-sum</h3><p>这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNsum</span><span class=\"params\">(l, r, target, N, result, results)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> r-l+<span class=\"number\">1</span>&lt;N <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span> <span class=\"keyword\">or</span> nums[l]*N &gt; target <span class=\"keyword\">or</span> nums[r]*N &lt; target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> N == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                    sum = nums[l] + nums[r]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        results.append(result + [nums[l], nums[r]])</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            l+=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &lt; target:</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        r -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(l, r+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i == l <span class=\"keyword\">or</span> (i &gt; l <span class=\"keyword\">and</span> nums[i<span class=\"number\">-1</span>] != nums[i]):</span><br><span class=\"line\">                        findNsum(i+<span class=\"number\">1</span>, r, target-nums[i], N<span class=\"number\">-1</span>, result+[nums[i]], results)</span><br><span class=\"line\">            </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        findNsum(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>, target, <span class=\"number\">4</span>, [], results)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"4Sum\"><a href=\"#4Sum\" class=\"headerlink\" title=\"4Sum\"></a><a href=\"hhttps://leetcode.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">4Sum</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br>（寻找数组中四个数的和为target的组合）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_18.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-四个指针\"><a href=\"#1-四个指针\" class=\"headerlink\" title=\"1. 四个指针\"></a>1. 四个指针</h3><p>可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\(O(n^3)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-2</span>):</span><br><span class=\"line\">                k = j + <span class=\"number\">1</span></span><br><span class=\"line\">                l = i - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> k &lt; l:</span><br><span class=\"line\">                    sum = nums[i] + nums[k] + nums[l] + nums[j]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> [nums[j], nums[k], nums[l], nums[i]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j], nums[k], nums[l], nums[i]])</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &gt; target:</span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-两次-2Sum-Dict\"><a href=\"#2-两次-2Sum-Dict\" class=\"headerlink\" title=\"2. 两次 2Sum + Dict\"></a>2. 两次 2Sum + Dict</h3><p>换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()   </span><br><span class=\"line\">     </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = nums[i] + nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = [[j, i]]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum].append([j, i])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = target - nums[i] - nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> dict[sum]:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> list[<span class=\"number\">0</span>] &gt; i <span class=\"keyword\">and</span> [nums[j],nums[i], nums[list[<span class=\"number\">0</span>]], nums[list[<span class=\"number\">1</span>]]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j],nums[i],nums[list[<span class=\"number\">0</span>]],nums[list[<span class=\"number\">1</span>]]])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-递归-N-sum\"><a href=\"#3-递归-N-sum\" class=\"headerlink\" title=\"3. 递归 N-sum\"></a>3. 递归 N-sum</h3><p>这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNsum</span><span class=\"params\">(l, r, target, N, result, results)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> r-l+<span class=\"number\">1</span>&lt;N <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span> <span class=\"keyword\">or</span> nums[l]*N &gt; target <span class=\"keyword\">or</span> nums[r]*N &lt; target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> N == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                    sum = nums[l] + nums[r]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        results.append(result + [nums[l], nums[r]])</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            l+=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &lt; target:</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        r -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(l, r+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i == l <span class=\"keyword\">or</span> (i &gt; l <span class=\"keyword\">and</span> nums[i<span class=\"number\">-1</span>] != nums[i]):</span><br><span class=\"line\">                        findNsum(i+<span class=\"number\">1</span>, r, target-nums[i], N<span class=\"number\">-1</span>, result+[nums[i]], results)</span><br><span class=\"line\">            </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        findNsum(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>, target, <span class=\"number\">4</span>, [], results)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Divide Two Integers","date":"2018-12-18T08:41:42.000Z","_content":"\n## [Divide Two Integers](https://leetcode.com/problems/divide-two-integers/)\n\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.\n（非乘 除 取模 方法实现除法）\n\n<!--more-->\n\nNote:\n- Both dividend and divisor will be 32-bit signed integers.\n- The divisor will never be 0.\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_29.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 减法实现除法\n这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地**加大除数**来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：\n\n```python\nclass Solution:\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if (dividend < 0 and divisor < 0) or (dividend > 0 and divisor > 0):\n            flag = 1\n        else:\n            flag = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        re = 0\n        i = 1\n        new_divisor = divisor\n        while dividend >= new_divisor:\n            re += i\n            dividend -= new_divisor\n            \n            new_divisor += new_divisor\n            i += i\n            if dividend < new_divisor:\n                new_divisor = divisor\n                i = 1\n         \n        if flag < 0:\n            return -re\n        else:\n            MAX = pow(2, 31) - 1\n            return min(re, MAX)\n```","source":"_posts/leetcode-DivideTwoIntegers.md","raw":"---\ntitle: LeetCode_Divide Two Integers\ndate: 2018-12-18 16:41:42\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - binary search\n---\n\n## [Divide Two Integers](https://leetcode.com/problems/divide-two-integers/)\n\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.\n（非乘 除 取模 方法实现除法）\n\n<!--more-->\n\nNote:\n- Both dividend and divisor will be 32-bit signed integers.\n- The divisor will never be 0.\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_29.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 减法实现除法\n这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地**加大除数**来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：\n\n```python\nclass Solution:\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if (dividend < 0 and divisor < 0) or (dividend > 0 and divisor > 0):\n            flag = 1\n        else:\n            flag = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        re = 0\n        i = 1\n        new_divisor = divisor\n        while dividend >= new_divisor:\n            re += i\n            dividend -= new_divisor\n            \n            new_divisor += new_divisor\n            i += i\n            if dividend < new_divisor:\n                new_divisor = divisor\n                i = 1\n         \n        if flag < 0:\n            return -re\n        else:\n            MAX = pow(2, 31) - 1\n            return min(re, MAX)\n```","slug":"leetcode-DivideTwoIntegers","published":1,"updated":"2018-12-18T10:20:29.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh77000jc3zm26gz3ol7","content":"<h2 id=\"Divide-Two-Integers\"><a href=\"#Divide-Two-Integers\" class=\"headerlink\" title=\"Divide Two Integers\"></a><a href=\"https://leetcode.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">Divide Two Integers</a></h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.<br>（非乘 除 取模 方法实现除法）</p>\n<a id=\"more\"></a>\n<p>Note:</p>\n<ul>\n<li>Both dividend and divisor will be 32-bit signed integers.</li>\n<li>The divisor will never be 0.</li>\n<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_29.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-减法实现除法\"><a href=\"#1-减法实现除法\" class=\"headerlink\" title=\"1. 减法实现除法\"></a>1. 减法实现除法</h3><p>这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地<strong>加大除数</strong>来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, dividend, divisor)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type dividend: int</span></span><br><span class=\"line\"><span class=\"string\">        :type divisor: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &lt; <span class=\"number\">0</span>) <span class=\"keyword\">or</span> (dividend &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &gt; <span class=\"number\">0</span>):</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flag = <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dividend = abs(dividend)</span><br><span class=\"line\">        divisor = abs(divisor)</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        new_divisor = divisor</span><br><span class=\"line\">        <span class=\"keyword\">while</span> dividend &gt;= new_divisor:</span><br><span class=\"line\">            re += i</span><br><span class=\"line\">            dividend -= new_divisor</span><br><span class=\"line\">            </span><br><span class=\"line\">            new_divisor += new_divisor</span><br><span class=\"line\">            i += i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dividend &lt; new_divisor:</span><br><span class=\"line\">                new_divisor = divisor</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -re</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(re, MAX)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Divide-Two-Integers\"><a href=\"#Divide-Two-Integers\" class=\"headerlink\" title=\"Divide Two Integers\"></a><a href=\"https://leetcode.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">Divide Two Integers</a></h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.<br>（非乘 除 取模 方法实现除法）</p>","more":"<p>Note:</p>\n<ul>\n<li>Both dividend and divisor will be 32-bit signed integers.</li>\n<li>The divisor will never be 0.</li>\n<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_29.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-减法实现除法\"><a href=\"#1-减法实现除法\" class=\"headerlink\" title=\"1. 减法实现除法\"></a>1. 减法实现除法</h3><p>这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地<strong>加大除数</strong>来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, dividend, divisor)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type dividend: int</span></span><br><span class=\"line\"><span class=\"string\">        :type divisor: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &lt; <span class=\"number\">0</span>) <span class=\"keyword\">or</span> (dividend &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &gt; <span class=\"number\">0</span>):</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flag = <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dividend = abs(dividend)</span><br><span class=\"line\">        divisor = abs(divisor)</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        new_divisor = divisor</span><br><span class=\"line\">        <span class=\"keyword\">while</span> dividend &gt;= new_divisor:</span><br><span class=\"line\">            re += i</span><br><span class=\"line\">            dividend -= new_divisor</span><br><span class=\"line\">            </span><br><span class=\"line\">            new_divisor += new_divisor</span><br><span class=\"line\">            i += i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dividend &lt; new_divisor:</span><br><span class=\"line\">                new_divisor = divisor</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -re</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(re, MAX)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Find First and Last Position of Element in Sorted Array","date":"2018-12-21T06:01:10.000Z","_content":"\n## [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].\n\n（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_34.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return [-1, -1]\n        \n        re_left, re_right = -1, -1\n\n        # find the first index\n        left, right = 0, n-1\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_left = middle\n                right = middle - 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n        \n        if nums[left] != target:\n        \treturn [-1, -1]\n           \n        # find the last index     \n        left, right = 0, n-1 \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_right = middle\n                left = middle + 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n                \n        return [re_left, re_right]\n```\n","source":"_posts/leetcode-FindFirstandLastPositionofElementinSortedArray.md","raw":"---\ntitle: LeetCode_Find First and Last Position of Element in Sorted Array\ndate: 2018-12-21 14:01:10\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - binary search\n---\n\n## [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].\n\n（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_34.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return [-1, -1]\n        \n        re_left, re_right = -1, -1\n\n        # find the first index\n        left, right = 0, n-1\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_left = middle\n                right = middle - 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n        \n        if nums[left] != target:\n        \treturn [-1, -1]\n           \n        # find the last index     \n        left, right = 0, n-1 \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_right = middle\n                left = middle + 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n                \n        return [re_left, re_right]\n```\n","slug":"leetcode-FindFirstandLastPositionofElementinSortedArray","published":1,"updated":"2018-12-21T06:25:23.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7b000oc3zmdi4mlc46","content":"<h2 id=\"Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"Find First and Last Position of Element in Sorted Array\"></a><a href=\"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">Find First and Last Position of Element in Sorted Array</a></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].</p>\n<p>（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_34.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re_left, re_right = <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># find the first index</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_left = middle</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] != target:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"comment\"># find the last index     </span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span> </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_right = middle</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [re_left, re_right]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"Find First and Last Position of Element in Sorted Array\"></a><a href=\"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">Find First and Last Position of Element in Sorted Array</a></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].</p>\n<p>（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_34.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re_left, re_right = <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># find the first index</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_left = middle</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] != target:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"comment\"># find the last index     </span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span> </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_right = middle</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [re_left, re_right]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_First Missing Positive","date":"2018-12-25T10:43:04.000Z","_content":"\n# [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)\n\nGiven an unsorted integer array, find the smallest missing positive integer.\n（在未排序数组中找到最小的非正数）\n\n<!--more-->\n\n**Note:**\n- Your algorithm should run in O(n) time and uses constant extra space.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_41.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 哈希法\n\n要在时间复杂度为 \\\\( O(n)\\\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i, n = 0, len(nums)\n\n        while i < n:\n            # nums[i] > 0, nums[i] <= n means positive number in [1, n]\n            # nums[i] != i+1 means index==i but it is not i + 1\n            # nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]\n            if nums[i] > 0 and nums[i] <= n and nums[i] != i+1 and nums[nums[i] - 1] != nums[i]:\n                temp = nums[i]\n                nums[i], nums[temp-1] = nums[temp-1], nums[i]\n            else:\n                i += 1\n\n        for i in range(n):\n            if nums[i] != i+1:\n                return i+1\n         \n        return n+1\n```","source":"_posts/leetcode-FirstMissingPositive.md","raw":"---\ntitle: LeetCode_First Missing Positive\ndate: 2018-12-25 18:43:04\ncategories: LeetCode\ntags: \n  - hard\n  - array\n---\n\n# [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)\n\nGiven an unsorted integer array, find the smallest missing positive integer.\n（在未排序数组中找到最小的非正数）\n\n<!--more-->\n\n**Note:**\n- Your algorithm should run in O(n) time and uses constant extra space.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_41.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 哈希法\n\n要在时间复杂度为 \\\\( O(n)\\\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i, n = 0, len(nums)\n\n        while i < n:\n            # nums[i] > 0, nums[i] <= n means positive number in [1, n]\n            # nums[i] != i+1 means index==i but it is not i + 1\n            # nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]\n            if nums[i] > 0 and nums[i] <= n and nums[i] != i+1 and nums[nums[i] - 1] != nums[i]:\n                temp = nums[i]\n                nums[i], nums[temp-1] = nums[temp-1], nums[i]\n            else:\n                i += 1\n\n        for i in range(n):\n            if nums[i] != i+1:\n                return i+1\n         \n        return n+1\n```","slug":"leetcode-FirstMissingPositive","published":1,"updated":"2018-12-25T12:35:59.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7d000qc3zmn63au84b","content":"<h1 id=\"First-Missing-Positive\"><a href=\"#First-Missing-Positive\" class=\"headerlink\" title=\"First Missing Positive\"></a><a href=\"https://leetcode.com/problems/first-missing-positive/\" target=\"_blank\" rel=\"noopener\">First Missing Positive</a></h1><p>Given an unsorted integer array, find the smallest missing positive integer.<br>（在未排序数组中找到最小的非正数）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Your algorithm should run in O(n) time and uses constant extra space.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_41.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-哈希法\"><a href=\"#1-哈希法\" class=\"headerlink\" title=\"1. 哈希法\"></a>1. 哈希法</h3><p>要在时间复杂度为 \\( O(n)\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        i, n = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"comment\"># nums[i] &gt; 0, nums[i] &lt;= n means positive number in [1, n]</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[i] != i+1 means index==i but it is not i + 1</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] &lt;= n <span class=\"keyword\">and</span> nums[i] != i+<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[nums[i] - <span class=\"number\">1</span>] != nums[i]:</span><br><span class=\"line\">                temp = nums[i]</span><br><span class=\"line\">                nums[i], nums[temp<span class=\"number\">-1</span>] = nums[temp<span class=\"number\">-1</span>], nums[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] != i+<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"First-Missing-Positive\"><a href=\"#First-Missing-Positive\" class=\"headerlink\" title=\"First Missing Positive\"></a><a href=\"https://leetcode.com/problems/first-missing-positive/\" target=\"_blank\" rel=\"noopener\">First Missing Positive</a></h1><p>Given an unsorted integer array, find the smallest missing positive integer.<br>（在未排序数组中找到最小的非正数）</p>","more":"<p><strong>Note:</strong></p>\n<ul>\n<li>Your algorithm should run in O(n) time and uses constant extra space.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_41.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-哈希法\"><a href=\"#1-哈希法\" class=\"headerlink\" title=\"1. 哈希法\"></a>1. 哈希法</h3><p>要在时间复杂度为 \\( O(n)\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        i, n = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"comment\"># nums[i] &gt; 0, nums[i] &lt;= n means positive number in [1, n]</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[i] != i+1 means index==i but it is not i + 1</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] &lt;= n <span class=\"keyword\">and</span> nums[i] != i+<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[nums[i] - <span class=\"number\">1</span>] != nums[i]:</span><br><span class=\"line\">                temp = nums[i]</span><br><span class=\"line\">                nums[i], nums[temp<span class=\"number\">-1</span>] = nums[temp<span class=\"number\">-1</span>], nums[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] != i+<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Implement strStr()","date":"2018-12-18T08:21:01.000Z","_content":"\n## [Implement strStr()](https://leetcode.com/problems/implement-strstr/)\n\nImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n（实现寻找字符串子串函数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_28.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历 -- easy\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        n = len(needle)\n        m = len(haystack)\n        \n        if n == 0:\n            return 0\n        \n        if n > m:\n            return -1\n        \n        for i in range(m-n+1):\n            if haystack[i:i+n] == needle:\n                return i\n        \n        return -1\n```\n\n### 2. 调用 python 库函数 in, index\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)\n```","source":"_posts/leetcode-ImplementstrStr.md","raw":"---\ntitle: LeetCode_Implement strStr()\ndate: 2018-12-18 16:21:01\ncategories: LeetCode\ntags: \n  - easy\n  - string\n  - two pointers\n---\n\n## [Implement strStr()](https://leetcode.com/problems/implement-strstr/)\n\nImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n（实现寻找字符串子串函数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_28.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历 -- easy\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        n = len(needle)\n        m = len(haystack)\n        \n        if n == 0:\n            return 0\n        \n        if n > m:\n            return -1\n        \n        for i in range(m-n+1):\n            if haystack[i:i+n] == needle:\n                return i\n        \n        return -1\n```\n\n### 2. 调用 python 库函数 in, index\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)\n```","slug":"leetcode-ImplementstrStr","published":1,"updated":"2018-12-18T08:41:00.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7g000uc3zmcekrenvk","content":"<h2 id=\"Implement-strStr\"><a href=\"#Implement-strStr\" class=\"headerlink\" title=\"Implement strStr()\"></a><a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">Implement strStr()</a></h2><p>Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.<br>（实现寻找字符串子串函数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_28.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历-–-easy\"><a href=\"#1-遍历-–-easy\" class=\"headerlink\" title=\"1. 遍历 – easy\"></a>1. 遍历 – easy</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(needle)</span><br><span class=\"line\">        m = len(haystack)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m-n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> haystack[i:i+n] == needle:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-调用-python-库函数-in-index\"><a href=\"#2-调用-python-库函数-in-index\" class=\"headerlink\" title=\"2. 调用 python 库函数 in, index\"></a>2. 调用 python 库函数 in, index</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> needle <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> haystack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> haystack.index(needle)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Implement-strStr\"><a href=\"#Implement-strStr\" class=\"headerlink\" title=\"Implement strStr()\"></a><a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">Implement strStr()</a></h2><p>Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.<br>（实现寻找字符串子串函数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_28.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历-–-easy\"><a href=\"#1-遍历-–-easy\" class=\"headerlink\" title=\"1. 遍历 – easy\"></a>1. 遍历 – easy</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(needle)</span><br><span class=\"line\">        m = len(haystack)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m-n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> haystack[i:i+n] == needle:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-调用-python-库函数-in-index\"><a href=\"#2-调用-python-库函数-in-index\" class=\"headerlink\" title=\"2. 调用 python 库函数 in, index\"></a>2. 调用 python 库函数 in, index</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> needle <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> haystack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> haystack.index(needle)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Generate Parentheses","date":"2018-12-07T08:33:33.000Z","_content":"\n## [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n（n 对括号所有组合形式）\n\n<!--more-->\n\n**Example:** \nFor example, given n = 3, a solution set is:\n\n<div align=center>\n\t<img src=\"/images/leetcode_22.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归 & 深度优先搜索\n这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： **任何位置的之前的 NUM_( >= NUM_)**。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        \n        def generateParenthesis(left_remain, right_remain, s):\n            if left_remain == 0 and right_remain == 0:\n                result.append(s)\n            if left_remain > 0:\n                generateParenthesis(left_remain-1, right_remain, s + '(')\n            if right_remain > 0 and left_remain < right_remain:\n                generateParenthesis(left_remain, right_remain-1, s + ')')\n            \n        generateParenthesis(n, n, '')\n        \n        return result\n```\n\n### 2. 动态规划\n经过观察发现如下：\n  - n==0, result = ['']\n  - n==1, result = [\n  \t() = ( + result_0 + ) + result_0\n  ]\n  - n==2, result = [\n  ()() = ( + result_0 + ) + result_1()\n  (()) = ( + result_1() + ) + result_0\n  ]\n  - n==3, result = [\n  ()()() = ( + result_0 + ) + result_2_1()()\n  ()(()) = ( + result_0 + ) + result_2_2(())\n  (())() = ( + result_1() + ) + result_1()\n  (()()) = ( + result_2_1()() + ) + result_0\n  ((())) = ( + result_2_2(()) + ) + result_0\n  ]\n因此我们可以得出如下结论：\n  - dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        dp = [[] for i in range(n+1)]\n\n        dp[0].append('')\n        for i in range(n + 1):\n        \tfor j in range(i):\n        \t\t dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\n            \n        return dp[n]    \n        \n```","source":"_posts/leetcode-GenerateParentheses.md","raw":"---\ntitle: LeetCode_Generate Parentheses\ndate: 2018-12-07 16:33:33\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - backtracking\n---\n\n## [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n（n 对括号所有组合形式）\n\n<!--more-->\n\n**Example:** \nFor example, given n = 3, a solution set is:\n\n<div align=center>\n\t<img src=\"/images/leetcode_22.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归 & 深度优先搜索\n这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： **任何位置的之前的 NUM_( >= NUM_)**。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        \n        def generateParenthesis(left_remain, right_remain, s):\n            if left_remain == 0 and right_remain == 0:\n                result.append(s)\n            if left_remain > 0:\n                generateParenthesis(left_remain-1, right_remain, s + '(')\n            if right_remain > 0 and left_remain < right_remain:\n                generateParenthesis(left_remain, right_remain-1, s + ')')\n            \n        generateParenthesis(n, n, '')\n        \n        return result\n```\n\n### 2. 动态规划\n经过观察发现如下：\n  - n==0, result = ['']\n  - n==1, result = [\n  \t() = ( + result_0 + ) + result_0\n  ]\n  - n==2, result = [\n  ()() = ( + result_0 + ) + result_1()\n  (()) = ( + result_1() + ) + result_0\n  ]\n  - n==3, result = [\n  ()()() = ( + result_0 + ) + result_2_1()()\n  ()(()) = ( + result_0 + ) + result_2_2(())\n  (())() = ( + result_1() + ) + result_1()\n  (()()) = ( + result_2_1()() + ) + result_0\n  ((())) = ( + result_2_2(()) + ) + result_0\n  ]\n因此我们可以得出如下结论：\n  - dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        dp = [[] for i in range(n+1)]\n\n        dp[0].append('')\n        for i in range(n + 1):\n        \tfor j in range(i):\n        \t\t dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\n            \n        return dp[n]    \n        \n```","slug":"leetcode-GenerateParentheses","published":1,"updated":"2018-12-07T10:06:13.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7h000wc3zmy54sxpcm","content":"<h2 id=\"Generate-Parentheses\"><a href=\"#Generate-Parentheses\" class=\"headerlink\" title=\"Generate Parentheses\"></a><a href=\"https://leetcode.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">Generate Parentheses</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>（n 对括号所有组合形式）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong><br>For example, given n = 3, a solution set is:</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_22.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归-amp-深度优先搜索\"><a href=\"#1-递归-amp-深度优先搜索\" class=\"headerlink\" title=\"1. 递归 &amp; 深度优先搜索\"></a>1. 递归 &amp; 深度优先搜索</h3><p>这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： <strong>任何位置的之前的 NUM_( &gt;= NUM_)</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(left_remain, right_remain, s)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain == <span class=\"number\">0</span> <span class=\"keyword\">and</span> right_remain == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                generateParenthesis(left_remain<span class=\"number\">-1</span>, right_remain, s + <span class=\"string\">'('</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> right_remain &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> left_remain &lt; right_remain:</span><br><span class=\"line\">                generateParenthesis(left_remain, right_remain<span class=\"number\">-1</span>, s + <span class=\"string\">')'</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        generateParenthesis(n, n, <span class=\"string\">''</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>经过观察发现如下：</p>\n<ul>\n<li>n==0, result = [‘’]</li>\n<li>n==1, result = [<br>  () = ( + result_0 + ) + result_0<br>]</li>\n<li>n==2, result = [<br>()() = ( + result_0 + ) + result_1()<br>(()) = ( + result_1() + ) + result_0<br>]</li>\n<li>n==3, result = [<br>()()() = ( + result_0 + ) + result_2_1()()<br>()(()) = ( + result_0 + ) + result_2_2(())<br>(())() = ( + result_1() + ) + result_1()<br>(()()) = ( + result_2_1()() + ) + result_0<br>((())) = ( + result_2_2(()) + ) + result_0<br>]<br>因此我们可以得出如下结论：</li>\n<li>dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        dp = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>].append(<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">        \t\t dp[i] += [<span class=\"string\">'('</span> + x + <span class=\"string\">')'</span> + y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> dp[j] <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> dp[i - j - <span class=\"number\">1</span>]]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Generate-Parentheses\"><a href=\"#Generate-Parentheses\" class=\"headerlink\" title=\"Generate Parentheses\"></a><a href=\"https://leetcode.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">Generate Parentheses</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>（n 对括号所有组合形式）</p>","more":"<p><strong>Example:</strong><br>For example, given n = 3, a solution set is:</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_22.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归-amp-深度优先搜索\"><a href=\"#1-递归-amp-深度优先搜索\" class=\"headerlink\" title=\"1. 递归 &amp; 深度优先搜索\"></a>1. 递归 &amp; 深度优先搜索</h3><p>这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： <strong>任何位置的之前的 NUM_( &gt;= NUM_)</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(left_remain, right_remain, s)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain == <span class=\"number\">0</span> <span class=\"keyword\">and</span> right_remain == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                generateParenthesis(left_remain<span class=\"number\">-1</span>, right_remain, s + <span class=\"string\">'('</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> right_remain &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> left_remain &lt; right_remain:</span><br><span class=\"line\">                generateParenthesis(left_remain, right_remain<span class=\"number\">-1</span>, s + <span class=\"string\">')'</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        generateParenthesis(n, n, <span class=\"string\">''</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>经过观察发现如下：</p>\n<ul>\n<li>n==0, result = [‘’]</li>\n<li>n==1, result = [<br>  () = ( + result_0 + ) + result_0<br>]</li>\n<li>n==2, result = [<br>()() = ( + result_0 + ) + result_1()<br>(()) = ( + result_1() + ) + result_0<br>]</li>\n<li>n==3, result = [<br>()()() = ( + result_0 + ) + result_2_1()()<br>()(()) = ( + result_0 + ) + result_2_2(())<br>(())() = ( + result_1() + ) + result_1()<br>(()()) = ( + result_2_1()() + ) + result_0<br>((())) = ( + result_2_2(()) + ) + result_0<br>]<br>因此我们可以得出如下结论：</li>\n<li>dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        dp = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>].append(<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">        \t\t dp[i] += [<span class=\"string\">'('</span> + x + <span class=\"string\">')'</span> + y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> dp[j] <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> dp[i - j - <span class=\"number\">1</span>]]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Letter Combinations of a Phone Number","date":"2018-11-30T12:28:46.000Z","_content":"\n## [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n（根据九宫格键盘将数字映射到字符）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_17.png\" width = \"500\" align=center/>\n</div>\n\n### 1. map / hash_table 进行索引\n这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了`digits == ''`的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。\n\n```python\nclass Solution:\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        dict = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        result = []\n        for ch in digits:\n            letter = dict[ch]\n            if len(result) == 0:\n                result = letter\n            else:\n                new_result = []\n                for a in result:\n                    for b in letter:\n                        new_result.append(a + b)\n                result = new_result\n                \n        return result \n```","source":"_posts/leetcode-LetterCombinationsofaPhoneNumber.md","raw":"---\ntitle: LeetCode_Letter Combinations of a Phone Number\ndate: 2018-11-30 20:28:46\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - backtracking\n---\n\n## [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n（根据九宫格键盘将数字映射到字符）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_17.png\" width = \"500\" align=center/>\n</div>\n\n### 1. map / hash_table 进行索引\n这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了`digits == ''`的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。\n\n```python\nclass Solution:\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        dict = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        result = []\n        for ch in digits:\n            letter = dict[ch]\n            if len(result) == 0:\n                result = letter\n            else:\n                new_result = []\n                for a in result:\n                    for b in letter:\n                        new_result.append(a + b)\n                result = new_result\n                \n        return result \n```","slug":"leetcode-LetterCombinationsofaPhoneNumber","published":1,"updated":"2018-11-30T12:51:30.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7j000yc3zmjqzf6svv","content":"<h2 id=\"Letter-Combinations-of-a-Phone-Number\"><a href=\"#Letter-Combinations-of-a-Phone-Number\" class=\"headerlink\" title=\"Letter Combinations of a Phone Number\"></a><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">Letter Combinations of a Phone Number</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>（根据九宫格键盘将数字映射到字符）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_17.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-map-hash-table-进行索引\"><a href=\"#1-map-hash-table-进行索引\" class=\"headerlink\" title=\"1. map / hash_table 进行索引\"></a>1. map / hash_table 进行索引</h3><p>这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了<code>digits == &#39;&#39;</code>的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type digits: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;</span><br><span class=\"line\">            <span class=\"string\">'2'</span>: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>],</span><br><span class=\"line\">            <span class=\"string\">'3'</span>: [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>],</span><br><span class=\"line\">            <span class=\"string\">'4'</span>: [<span class=\"string\">'g'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'i'</span>],</span><br><span class=\"line\">            <span class=\"string\">'5'</span>: [<span class=\"string\">'j'</span>, <span class=\"string\">'k'</span>, <span class=\"string\">'l'</span>],</span><br><span class=\"line\">            <span class=\"string\">'6'</span>: [<span class=\"string\">'m'</span>, <span class=\"string\">'n'</span>, <span class=\"string\">'o'</span>],</span><br><span class=\"line\">            <span class=\"string\">'7'</span>: [<span class=\"string\">'p'</span>, <span class=\"string\">'q'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'s'</span>],</span><br><span class=\"line\">            <span class=\"string\">'8'</span>: [<span class=\"string\">'t'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'v'</span>],</span><br><span class=\"line\">            <span class=\"string\">'9'</span>: [<span class=\"string\">'w'</span>, <span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'z'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> digits:</span><br><span class=\"line\">            letter = dict[ch]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result = letter</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_result = []</span><br><span class=\"line\">                <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> letter:</span><br><span class=\"line\">                        new_result.append(a + b)</span><br><span class=\"line\">                result = new_result</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Letter-Combinations-of-a-Phone-Number\"><a href=\"#Letter-Combinations-of-a-Phone-Number\" class=\"headerlink\" title=\"Letter Combinations of a Phone Number\"></a><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">Letter Combinations of a Phone Number</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>（根据九宫格键盘将数字映射到字符）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_17.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-map-hash-table-进行索引\"><a href=\"#1-map-hash-table-进行索引\" class=\"headerlink\" title=\"1. map / hash_table 进行索引\"></a>1. map / hash_table 进行索引</h3><p>这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了<code>digits == &#39;&#39;</code>的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type digits: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;</span><br><span class=\"line\">            <span class=\"string\">'2'</span>: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>],</span><br><span class=\"line\">            <span class=\"string\">'3'</span>: [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>],</span><br><span class=\"line\">            <span class=\"string\">'4'</span>: [<span class=\"string\">'g'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'i'</span>],</span><br><span class=\"line\">            <span class=\"string\">'5'</span>: [<span class=\"string\">'j'</span>, <span class=\"string\">'k'</span>, <span class=\"string\">'l'</span>],</span><br><span class=\"line\">            <span class=\"string\">'6'</span>: [<span class=\"string\">'m'</span>, <span class=\"string\">'n'</span>, <span class=\"string\">'o'</span>],</span><br><span class=\"line\">            <span class=\"string\">'7'</span>: [<span class=\"string\">'p'</span>, <span class=\"string\">'q'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'s'</span>],</span><br><span class=\"line\">            <span class=\"string\">'8'</span>: [<span class=\"string\">'t'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'v'</span>],</span><br><span class=\"line\">            <span class=\"string\">'9'</span>: [<span class=\"string\">'w'</span>, <span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'z'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> digits:</span><br><span class=\"line\">            letter = dict[ch]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result = letter</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_result = []</span><br><span class=\"line\">                <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> letter:</span><br><span class=\"line\">                        new_result.append(a + b)</span><br><span class=\"line\">                result = new_result</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Integer to Roman","date":"2018-11-28T07:40:20.000Z","_content":"\n## [Integer to Roman](https://leetcode.com/problems/integer-to-roman/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（整数转罗马字符）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_12.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 基数扩展\n由于 \"4\" 和 \"9\" 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        base = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        base_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        \n        result = \"\"\n        for i in range(len(base_list)):\n            if num // base_list[i] != 0:\n                for j in range(num // base_list[i]):\n                    result += base[base_list[i]]\n                num = num % base_list[i]\n            \n        return result \n```\n\n\n### 2. 列表索引\n列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    \n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\n```","source":"_posts/leetcode-IntegertoRoman.md","raw":"---\ntitle: LeetCode_Integer to Roman\ndate: 2018-11-28 15:40:20\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - string\n---\n\n## [Integer to Roman](https://leetcode.com/problems/integer-to-roman/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（整数转罗马字符）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_12.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 基数扩展\n由于 \"4\" 和 \"9\" 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        base = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        base_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        \n        result = \"\"\n        for i in range(len(base_list)):\n            if num // base_list[i] != 0:\n                for j in range(num // base_list[i]):\n                    result += base[base_list[i]]\n                num = num % base_list[i]\n            \n        return result \n```\n\n\n### 2. 列表索引\n列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    \n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\n```","slug":"leetcode-IntegertoRoman","published":1,"updated":"2018-11-29T02:41:29.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7l0012c3zm7k3ejr0v","content":"<h2 id=\"Integer-to-Roman\"><a href=\"#Integer-to-Roman\" class=\"headerlink\" title=\"Integer to Roman\"></a><a href=\"https://leetcode.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">Integer to Roman</a></h2><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（整数转罗马字符）</p>\n<a id=\"more\"></a>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_12.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-基数扩展\"><a href=\"#1-基数扩展\" class=\"headerlink\" title=\"1. 基数扩展\"></a>1. 基数扩展</h3><p>由于 “4” 和 “9” 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"number\">1000</span>: <span class=\"string\">'M'</span>,</span><br><span class=\"line\">            <span class=\"number\">900</span>: <span class=\"string\">'CM'</span>,</span><br><span class=\"line\">            <span class=\"number\">500</span>: <span class=\"string\">'D'</span>,</span><br><span class=\"line\">            <span class=\"number\">400</span>: <span class=\"string\">'CD'</span>,</span><br><span class=\"line\">            <span class=\"number\">100</span>: <span class=\"string\">'C'</span>,</span><br><span class=\"line\">            <span class=\"number\">90</span>: <span class=\"string\">'XC'</span>,</span><br><span class=\"line\">            <span class=\"number\">50</span>: <span class=\"string\">'L'</span>,</span><br><span class=\"line\">            <span class=\"number\">40</span>: <span class=\"string\">'XL'</span>,</span><br><span class=\"line\">            <span class=\"number\">10</span>: <span class=\"string\">'X'</span>,</span><br><span class=\"line\">            <span class=\"number\">9</span>: <span class=\"string\">'IX'</span>,</span><br><span class=\"line\">            <span class=\"number\">5</span>: <span class=\"string\">'V'</span>,</span><br><span class=\"line\">            <span class=\"number\">4</span>: <span class=\"string\">'IV'</span>,</span><br><span class=\"line\">            <span class=\"number\">1</span>: <span class=\"string\">'I'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        base_list = [<span class=\"number\">1000</span>, <span class=\"number\">900</span>, <span class=\"number\">500</span>, <span class=\"number\">400</span>, <span class=\"number\">100</span>, <span class=\"number\">90</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(base_list)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num // base_list[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(num // base_list[i]):</span><br><span class=\"line\">                    result += base[base_list[i]]</span><br><span class=\"line\">                num = num % base_list[i]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-列表索引\"><a href=\"#2-列表索引\" class=\"headerlink\" title=\"2. 列表索引\"></a>2. 列表索引</h3><p>列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        M = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"MM\"</span>, <span class=\"string\">\"MMM\"</span>]</span><br><span class=\"line\">        C = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span>]</span><br><span class=\"line\">        X = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span>]</span><br><span class=\"line\">        I = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> M[num//<span class=\"number\">1000</span>] + C[(num%<span class=\"number\">1000</span>)//<span class=\"number\">100</span>] + X[(num%<span class=\"number\">100</span>)//<span class=\"number\">10</span>] + I[num%<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Integer-to-Roman\"><a href=\"#Integer-to-Roman\" class=\"headerlink\" title=\"Integer to Roman\"></a><a href=\"https://leetcode.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">Integer to Roman</a></h2><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（整数转罗马字符）</p>","more":"<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_12.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-基数扩展\"><a href=\"#1-基数扩展\" class=\"headerlink\" title=\"1. 基数扩展\"></a>1. 基数扩展</h3><p>由于 “4” 和 “9” 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"number\">1000</span>: <span class=\"string\">'M'</span>,</span><br><span class=\"line\">            <span class=\"number\">900</span>: <span class=\"string\">'CM'</span>,</span><br><span class=\"line\">            <span class=\"number\">500</span>: <span class=\"string\">'D'</span>,</span><br><span class=\"line\">            <span class=\"number\">400</span>: <span class=\"string\">'CD'</span>,</span><br><span class=\"line\">            <span class=\"number\">100</span>: <span class=\"string\">'C'</span>,</span><br><span class=\"line\">            <span class=\"number\">90</span>: <span class=\"string\">'XC'</span>,</span><br><span class=\"line\">            <span class=\"number\">50</span>: <span class=\"string\">'L'</span>,</span><br><span class=\"line\">            <span class=\"number\">40</span>: <span class=\"string\">'XL'</span>,</span><br><span class=\"line\">            <span class=\"number\">10</span>: <span class=\"string\">'X'</span>,</span><br><span class=\"line\">            <span class=\"number\">9</span>: <span class=\"string\">'IX'</span>,</span><br><span class=\"line\">            <span class=\"number\">5</span>: <span class=\"string\">'V'</span>,</span><br><span class=\"line\">            <span class=\"number\">4</span>: <span class=\"string\">'IV'</span>,</span><br><span class=\"line\">            <span class=\"number\">1</span>: <span class=\"string\">'I'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        base_list = [<span class=\"number\">1000</span>, <span class=\"number\">900</span>, <span class=\"number\">500</span>, <span class=\"number\">400</span>, <span class=\"number\">100</span>, <span class=\"number\">90</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(base_list)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num // base_list[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(num // base_list[i]):</span><br><span class=\"line\">                    result += base[base_list[i]]</span><br><span class=\"line\">                num = num % base_list[i]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-列表索引\"><a href=\"#2-列表索引\" class=\"headerlink\" title=\"2. 列表索引\"></a>2. 列表索引</h3><p>列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        M = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"MM\"</span>, <span class=\"string\">\"MMM\"</span>]</span><br><span class=\"line\">        C = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span>]</span><br><span class=\"line\">        X = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span>]</span><br><span class=\"line\">        I = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> M[num//<span class=\"number\">1000</span>] + C[(num%<span class=\"number\">1000</span>)//<span class=\"number\">100</span>] + X[(num%<span class=\"number\">100</span>)//<span class=\"number\">10</span>] + I[num%<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Longest Common Prefix","date":"2018-11-29T02:37:25.000Z","_content":"\n## [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)\n\nWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". \n（寻找最长公共前缀序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_14.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：\n```python\nclass Solution:\n    def commonPrefixof2(self, str1, str2):\n        result = \"\"\n        n = min(len(str1), len(str2))\n        for i in range(n):\n            if str1[i] == str2[i]:\n                result += str2[i]\n            else:\n                break\n        return result    \n        \n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        result = '' \n        n = len(strs)\n        \n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        elif n == 2:\n            return self.commonPrefixof2(strs[0], strs[1])\n        else: \n            result1 = self.longestCommonPrefix(strs[:n//2])\n            result2 = self.longestCommonPrefix(strs[n//2:])\n            return self.commonPrefixof2(result1, result2)\n```\n\n### 2. Zip函数 & Set\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\" \n        if not strs:\n            return \"\"\n        \n        for i, word in enumerate(zip(*strs)):\n            if len(set(word)) > 1:\n                return strs[0][:i]\n\n        return min(strs)\n```\n\n\n### 3. 字符子串组成Set\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        n = len(strs)\n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        length = min([len(s) for s in strs])\n        \n        while length > 0:\n            substrings = [s[:length] for s in strs]\n            if len(set(substrings)) == 1:\n                return substrings[0]\n            length -= 1\n        return \"\"\n```","source":"_posts/leetcode-LongestCommonPrefix.md","raw":"---\ntitle: LeetCode_Longest Common Prefix\ndate: 2018-11-29 10:37:25\ncategories: LeetCode\ntags: \n  - easy\n  - string\n---\n\n## [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)\n\nWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". \n（寻找最长公共前缀序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_14.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：\n```python\nclass Solution:\n    def commonPrefixof2(self, str1, str2):\n        result = \"\"\n        n = min(len(str1), len(str2))\n        for i in range(n):\n            if str1[i] == str2[i]:\n                result += str2[i]\n            else:\n                break\n        return result    \n        \n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        result = '' \n        n = len(strs)\n        \n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        elif n == 2:\n            return self.commonPrefixof2(strs[0], strs[1])\n        else: \n            result1 = self.longestCommonPrefix(strs[:n//2])\n            result2 = self.longestCommonPrefix(strs[n//2:])\n            return self.commonPrefixof2(result1, result2)\n```\n\n### 2. Zip函数 & Set\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\" \n        if not strs:\n            return \"\"\n        \n        for i, word in enumerate(zip(*strs)):\n            if len(set(word)) > 1:\n                return strs[0][:i]\n\n        return min(strs)\n```\n\n\n### 3. 字符子串组成Set\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        n = len(strs)\n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        length = min([len(s) for s in strs])\n        \n        while length > 0:\n            substrings = [s[:length] for s in strs]\n            if len(set(substrings)) == 1:\n                return substrings[0]\n            length -= 1\n        return \"\"\n```","slug":"leetcode-LongestCommonPrefix","published":1,"updated":"2018-11-29T03:35:29.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7n0015c3zmu41a24ud","content":"<h2 id=\"Longest-Common-Prefix\"><a href=\"#Longest-Common-Prefix\" class=\"headerlink\" title=\"Longest Common Prefix\"></a><a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">Longest Common Prefix</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.<br>（寻找最长公共前缀序列）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_14.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commonPrefixof2</span><span class=\"params\">(self, str1, str2)</span>:</span></span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = min(len(str1), len(str2))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i] == str2[i]:</span><br><span class=\"line\">                result += str2[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = <span class=\"string\">''</span> </span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(strs[<span class=\"number\">0</span>], strs[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: </span><br><span class=\"line\">            result1 = self.longestCommonPrefix(strs[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">            result2 = self.longestCommonPrefix(strs[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(result1, result2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Zip函数-amp-Set\"><a href=\"#2-Zip函数-amp-Set\" class=\"headerlink\" title=\"2. Zip函数 &amp; Set\"></a>2. Zip函数 &amp; Set</h3><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, word <span class=\"keyword\">in</span> enumerate(zip(*strs)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(word)) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>][:i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(strs)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-字符子串组成Set\"><a href=\"#3-字符子串组成Set\" class=\"headerlink\" title=\"3. 字符子串组成Set\"></a>3. 字符子串组成Set</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        length = min([len(s) <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> length &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            substrings = [s[:length] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(substrings)) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> substrings[<span class=\"number\">0</span>]</span><br><span class=\"line\">            length -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Common-Prefix\"><a href=\"#Longest-Common-Prefix\" class=\"headerlink\" title=\"Longest Common Prefix\"></a><a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">Longest Common Prefix</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.<br>（寻找最长公共前缀序列）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_14.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commonPrefixof2</span><span class=\"params\">(self, str1, str2)</span>:</span></span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = min(len(str1), len(str2))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i] == str2[i]:</span><br><span class=\"line\">                result += str2[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = <span class=\"string\">''</span> </span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(strs[<span class=\"number\">0</span>], strs[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: </span><br><span class=\"line\">            result1 = self.longestCommonPrefix(strs[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">            result2 = self.longestCommonPrefix(strs[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(result1, result2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Zip函数-amp-Set\"><a href=\"#2-Zip函数-amp-Set\" class=\"headerlink\" title=\"2. Zip函数 &amp; Set\"></a>2. Zip函数 &amp; Set</h3><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, word <span class=\"keyword\">in</span> enumerate(zip(*strs)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(word)) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>][:i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(strs)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-字符子串组成Set\"><a href=\"#3-字符子串组成Set\" class=\"headerlink\" title=\"3. 字符子串组成Set\"></a>3. 字符子串组成Set</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        length = min([len(s) <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> length &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            substrings = [s[:length] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(substrings)) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> substrings[<span class=\"number\">0</span>]</span><br><span class=\"line\">            length -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Longest Substring Without Repeating Characters","date":"2018-11-23T06:33:59.000Z","_content":"\n## [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\nGiven a string, find the length of the longest substring without repeating characters.\n（字符串中的最大不重复子串）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_3.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力循环\n\n对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\\\(O(n^3)\\\\)。在测试过程中会 Time Limit Exceeded。\n\n### 2. 移动窗口 / 动态规划\n\n这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\\\(O(2n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        long = 0\n        i = 0\n        j = 0\n        \n        while(i < len(s) and j < len(s)):\n            if (s[j] not in d) or (d[s[j]] == 0):\n                d[s[j]] = 1\n                j += 1\n                long = max(long, j-i)\n            else:\n                d[s[i]] = 0\n                i += 1 \n        return long\n```\n\n上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        i = 0\n        j = 0\n        long = 0\n        while j < len(s) :\n            if s[j] in d and d[s[j]] > i:\n                i = d[s[j]]\n            else:\n            \tlong = max(long, j - i + 1)\n            d[s[j]] = j + 1\n            j += 1\n            \n        return long\n```\n\n**注**： 测试的时候考虑字符串为空等临界条件。\n\n\n\n\n\n\n","source":"_posts/leetcode-LongestSubstringWithoutRepeatingCharacters.md","raw":"---\ntitle: LeetCode_Longest Substring Without Repeating Characters\ndate: 2018-11-23 14:33:59\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - hash table\n  - dynamic programming\n---\n\n## [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\nGiven a string, find the length of the longest substring without repeating characters.\n（字符串中的最大不重复子串）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_3.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力循环\n\n对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\\\(O(n^3)\\\\)。在测试过程中会 Time Limit Exceeded。\n\n### 2. 移动窗口 / 动态规划\n\n这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\\\(O(2n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        long = 0\n        i = 0\n        j = 0\n        \n        while(i < len(s) and j < len(s)):\n            if (s[j] not in d) or (d[s[j]] == 0):\n                d[s[j]] = 1\n                j += 1\n                long = max(long, j-i)\n            else:\n                d[s[i]] = 0\n                i += 1 \n        return long\n```\n\n上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        i = 0\n        j = 0\n        long = 0\n        while j < len(s) :\n            if s[j] in d and d[s[j]] > i:\n                i = d[s[j]]\n            else:\n            \tlong = max(long, j - i + 1)\n            d[s[j]] = j + 1\n            j += 1\n            \n        return long\n```\n\n**注**： 测试的时候考虑字符串为空等临界条件。\n\n\n\n\n\n\n","slug":"leetcode-LongestSubstringWithoutRepeatingCharacters","published":1,"updated":"2018-11-27T06:24:48.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7o0019c3zmohxwan20","content":"<h2 id=\"Longest-Substring-Without-Repeating-Characters\"><a href=\"#Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"Longest Substring Without Repeating Characters\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">Longest Substring Without Repeating Characters</a></h2><p>Given a string, find the length of the longest substring without repeating characters.<br>（字符串中的最大不重复子串）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_3.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\(O(n^3)\\)。在测试过程中会 Time Limit Exceeded。</p>\n<h3 id=\"2-移动窗口-动态规划\"><a href=\"#2-移动窗口-动态规划\" class=\"headerlink\" title=\"2. 移动窗口 / 动态规划\"></a>2. 移动窗口 / 动态规划</h3><p>这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\(O(2n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len(s) <span class=\"keyword\">and</span> j &lt; len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[j] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> d) <span class=\"keyword\">or</span> (d[s[j]] == <span class=\"number\">0</span>):</span><br><span class=\"line\">                d[s[j]] = <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">                long = max(long, j-i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[s[i]] = <span class=\"number\">0</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p>上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(s) :</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> d[s[j]] &gt; i:</span><br><span class=\"line\">                i = d[s[j]]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            \tlong = max(long, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">            d[s[j]] = j + <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>： 测试的时候考虑字符串为空等临界条件。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Substring-Without-Repeating-Characters\"><a href=\"#Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"Longest Substring Without Repeating Characters\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">Longest Substring Without Repeating Characters</a></h2><p>Given a string, find the length of the longest substring without repeating characters.<br>（字符串中的最大不重复子串）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_3.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\(O(n^3)\\)。在测试过程中会 Time Limit Exceeded。</p>\n<h3 id=\"2-移动窗口-动态规划\"><a href=\"#2-移动窗口-动态规划\" class=\"headerlink\" title=\"2. 移动窗口 / 动态规划\"></a>2. 移动窗口 / 动态规划</h3><p>这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\(O(2n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len(s) <span class=\"keyword\">and</span> j &lt; len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[j] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> d) <span class=\"keyword\">or</span> (d[s[j]] == <span class=\"number\">0</span>):</span><br><span class=\"line\">                d[s[j]] = <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">                long = max(long, j-i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[s[i]] = <span class=\"number\">0</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p>上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(s) :</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> d[s[j]] &gt; i:</span><br><span class=\"line\">                i = d[s[j]]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            \tlong = max(long, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">            d[s[j]] = j + <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>： 测试的时候考虑字符串为空等临界条件。</p>"},{"title":"LeetCode_Longest Palindromic Substring","date":"2018-11-26T03:28:13.000Z","_content":"\n## [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\n\nGiven a string **s**, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n（寻找最长回文序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_5.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1.动态规划\n这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：\n\n\\\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\\\]\n\n然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\\\(O(n^2)\\\\)，空间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        dp = [[0] * n  for i in range(n)]\n    \n        result = ''\n        max_len = 0\n        for i in range(n):\n            dp[i][i] = 1\n            result = s[i]\n            max_len = 1\n        \n        for j in range(n):\n            for i in range(0, j):\n                if s[i] == s[j] and (dp[i+1][j-1] == 1 or i == j-1):\n                    dp[i][j] = 1\n                    if max_len <= j - i + 1:\n                        result = s[i:j+1]\n                        max_len = j - i + 1\n        \n        return result\n```\n\n","source":"_posts/leetcode-LongestPalindromicSubstring.md","raw":"---\ntitle: LeetCode_Longest Palindromic Substring\ndate: 2018-11-26 11:28:13\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - dynamic programming\n---\n\n## [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\n\nGiven a string **s**, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n（寻找最长回文序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_5.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1.动态规划\n这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：\n\n\\\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\\\]\n\n然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\\\(O(n^2)\\\\)，空间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        dp = [[0] * n  for i in range(n)]\n    \n        result = ''\n        max_len = 0\n        for i in range(n):\n            dp[i][i] = 1\n            result = s[i]\n            max_len = 1\n        \n        for j in range(n):\n            for i in range(0, j):\n                if s[i] == s[j] and (dp[i+1][j-1] == 1 or i == j-1):\n                    dp[i][j] = 1\n                    if max_len <= j - i + 1:\n                        result = s[i:j+1]\n                        max_len = j - i + 1\n        \n        return result\n```\n\n","slug":"leetcode-LongestPalindromicSubstring","published":1,"updated":"2018-11-27T06:24:40.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7q001cc3zmd3436ac2","content":"<h2 id=\"Longest-Palindromic-Substring\"><a href=\"#Longest-Palindromic-Substring\" class=\"headerlink\" title=\"Longest Palindromic Substring\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">Longest Palindromic Substring</a></h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>（寻找最长回文序列）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_5.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：</p>\n<p>\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\]</p>\n<p>然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\(O(n^2)\\)，空间复杂度为 \\(O(n^2)\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>] * n  <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    </span><br><span class=\"line\">        result = <span class=\"string\">''</span></span><br><span class=\"line\">        max_len = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dp[i][i] = <span class=\"number\">1</span></span><br><span class=\"line\">            result = s[i]</span><br><span class=\"line\">            max_len = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[i] == s[j] <span class=\"keyword\">and</span> (dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>] == <span class=\"number\">1</span> <span class=\"keyword\">or</span> i == j<span class=\"number\">-1</span>):</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> max_len &lt;= j - i + <span class=\"number\">1</span>:</span><br><span class=\"line\">                        result = s[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">                        max_len = j - i + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Palindromic-Substring\"><a href=\"#Longest-Palindromic-Substring\" class=\"headerlink\" title=\"Longest Palindromic Substring\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">Longest Palindromic Substring</a></h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>（寻找最长回文序列）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_5.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：</p>\n<p>\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\]</p>\n<p>然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\(O(n^2)\\)，空间复杂度为 \\(O(n^2)\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>] * n  <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    </span><br><span class=\"line\">        result = <span class=\"string\">''</span></span><br><span class=\"line\">        max_len = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dp[i][i] = <span class=\"number\">1</span></span><br><span class=\"line\">            result = s[i]</span><br><span class=\"line\">            max_len = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[i] == s[j] <span class=\"keyword\">and</span> (dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>] == <span class=\"number\">1</span> <span class=\"keyword\">or</span> i == j<span class=\"number\">-1</span>):</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> max_len &lt;= j - i + <span class=\"number\">1</span>:</span><br><span class=\"line\">                        result = s[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">                        max_len = j - i + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Longest Valid Parentheses","date":"2018-12-21T03:00:45.000Z","_content":"\n## [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)\n\nGiven a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n（最长有效括号对）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_32.png\" width = \"500\" align=center/>\n</div>\n\n### 1.动态规划\n这是一个很直观的动态规划的题目，需要分两种情况讨论：\n1. 当前字符为 ')' 且前一个字符为 '(' ，则动态规划公式可以为 dp[i] = dp[i-2] + 2\n2. 当前字符为 ')' 且前一个字符为 ')' ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 '(' 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。\n具体实现过程如下：\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        if n <= 1:\n            return 0\n        \n        dp = [0 for _ in range(n)]\n        \n        for i in range(1, n):\n            if s[i] == ')' and s[i-1] == '(':\n                if i >=2:\n                    dp[i] = dp[i-2] + 2\n                else:\n                    dp[i] = 2\n            if s[i] == ')' and s[i-1] == ')':\n                if i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n        \n        return max(dp)\n```\n\n### 2.栈 \n首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 '(' 就 push 进去新的index，遇到 ')' 就pop堆栈并分两种情况讨论：\n1. 此时堆栈为空，表示 ')' 的个数大于 '(' ，因此我们可以把此时的 index push进去，表示重新开始；\n2. 此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        stack = []\n        stack.append(-1)\n        \n        max_re = 0\n        for i, ch in enumerate(s):\n            if ch == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    stack.append(i)\n                else:\n                    max_re = max(max_re, i - stack[-1])\n                    \n        return max_re\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-LongestValidParentheses.md","raw":"---\ntitle: LeetCode_Longest Valid Parentheses\ndate: 2018-12-21 11:00:45\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n---\n\n## [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)\n\nGiven a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n（最长有效括号对）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_32.png\" width = \"500\" align=center/>\n</div>\n\n### 1.动态规划\n这是一个很直观的动态规划的题目，需要分两种情况讨论：\n1. 当前字符为 ')' 且前一个字符为 '(' ，则动态规划公式可以为 dp[i] = dp[i-2] + 2\n2. 当前字符为 ')' 且前一个字符为 ')' ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 '(' 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。\n具体实现过程如下：\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        if n <= 1:\n            return 0\n        \n        dp = [0 for _ in range(n)]\n        \n        for i in range(1, n):\n            if s[i] == ')' and s[i-1] == '(':\n                if i >=2:\n                    dp[i] = dp[i-2] + 2\n                else:\n                    dp[i] = 2\n            if s[i] == ')' and s[i-1] == ')':\n                if i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n        \n        return max(dp)\n```\n\n### 2.栈 \n首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 '(' 就 push 进去新的index，遇到 ')' 就pop堆栈并分两种情况讨论：\n1. 此时堆栈为空，表示 ')' 的个数大于 '(' ，因此我们可以把此时的 index push进去，表示重新开始；\n2. 此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        stack = []\n        stack.append(-1)\n        \n        max_re = 0\n        for i, ch in enumerate(s):\n            if ch == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    stack.append(i)\n                else:\n                    max_re = max(max_re, i - stack[-1])\n                    \n        return max_re\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-LongestValidParentheses","published":1,"updated":"2018-12-21T04:01:02.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7t001fc3zm7cnxcosi","content":"<h2 id=\"Longest-Valid-Parentheses\"><a href=\"#Longest-Valid-Parentheses\" class=\"headerlink\" title=\"Longest Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Longest Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.<br>（最长有效括号对）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_32.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这是一个很直观的动态规划的题目，需要分两种情况讨论：</p>\n<ol>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘(‘ ，则动态规划公式可以为 dp[i] = dp[i-2] + 2</li>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘)’ ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 ‘(‘ 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。<br>具体实现过程如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i] = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">')'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈\"><a href=\"#2-栈\" class=\"headerlink\" title=\"2.栈\"></a>2.栈</h3><p>首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 ‘(‘ 就 push 进去新的index，遇到 ‘)’ 就pop堆栈并分两种情况讨论：</p>\n<ol>\n<li>此时堆栈为空，表示 ‘)’ 的个数大于 ‘(‘ ，因此我们可以把此时的 index push进去，表示重新开始；</li>\n<li>此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        stack.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        max_re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, ch <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    stack.append(i)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    max_re = max(max_re, i - stack[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_re</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Valid-Parentheses\"><a href=\"#Longest-Valid-Parentheses\" class=\"headerlink\" title=\"Longest Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Longest Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.<br>（最长有效括号对）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_32.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这是一个很直观的动态规划的题目，需要分两种情况讨论：</p>\n<ol>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘(‘ ，则动态规划公式可以为 dp[i] = dp[i-2] + 2</li>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘)’ ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 ‘(‘ 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。<br>具体实现过程如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i] = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">')'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈\"><a href=\"#2-栈\" class=\"headerlink\" title=\"2.栈\"></a>2.栈</h3><p>首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 ‘(‘ 就 push 进去新的index，遇到 ‘)’ 就pop堆栈并分两种情况讨论：</p>\n<ol>\n<li>此时堆栈为空，表示 ‘)’ 的个数大于 ‘(‘ ，因此我们可以把此时的 index push进去，表示重新开始；</li>\n<li>此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        stack.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        max_re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, ch <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    stack.append(i)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    max_re = max(max_re, i - stack[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_re</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Merge Two Sorted Lists","date":"2018-12-06T08:02:30.000Z","_content":"\n## [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n（合并有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_21.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个链表指针\n链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if l1 == None:\n            return l2\n        if l2 == None:\n            return l1\n        \n        if l1.val <= l2.val:\n            target = l1\n            p = l1.next\n            q = l2\n        else:\n            target = l2\n            p = l1\n            q = l2.next\n        tail = target\n        \n        while p != None and q != None:\n            if p.val <= q.val:\n                tail.next = p\n                tail = p\n                p = p.next\n            else:\n                tail.next = q\n                tail = q\n                q = q.next\n            \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n        \n        return target\n```\n\n### 2. 增加头结点\n在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1 or not l2:\n        \treturn l1 or l2\n\n        tail = target = ListNode(0)\n        \n        while l1 and l2:\n            if l1.val <= l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n            \n        tail.next = l1 or l2\n        \n        return target.next\n```","source":"_posts/leetcode-MergeTwoSortedLists.md","raw":"---\ntitle: LeetCode_Merge Two Sorted Lists\ndate: 2018-12-06 16:02:30\ncategories: LeetCode\ntags: \n  - easy\n  - linked list\n---\n\n## [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n（合并有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_21.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个链表指针\n链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if l1 == None:\n            return l2\n        if l2 == None:\n            return l1\n        \n        if l1.val <= l2.val:\n            target = l1\n            p = l1.next\n            q = l2\n        else:\n            target = l2\n            p = l1\n            q = l2.next\n        tail = target\n        \n        while p != None and q != None:\n            if p.val <= q.val:\n                tail.next = p\n                tail = p\n                p = p.next\n            else:\n                tail.next = q\n                tail = q\n                q = q.next\n            \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n        \n        return target\n```\n\n### 2. 增加头结点\n在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1 or not l2:\n        \treturn l1 or l2\n\n        tail = target = ListNode(0)\n        \n        while l1 and l2:\n            if l1.val <= l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n            \n        tail.next = l1 or l2\n        \n        return target.next\n```","slug":"leetcode-MergeTwoSortedLists","published":1,"updated":"2018-12-06T08:48:59.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7v001hc3zmo55xdy00","content":"<h2 id=\"Merge-Two-Sorted-Lists\"><a href=\"#Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"Merge Two Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge Two Sorted Lists</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br>（合并有序链表）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_21.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个链表指针\"><a href=\"#1-三个链表指针\" class=\"headerlink\" title=\"1. 三个链表指针\"></a>1. 三个链表指针</h3><p>链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l2 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">            target = l1</span><br><span class=\"line\">            p = l1.next</span><br><span class=\"line\">            q = l2</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            target = l2</span><br><span class=\"line\">            p = l1</span><br><span class=\"line\">            q = l2.next</span><br><span class=\"line\">        tail = target</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt;= q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                tail = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                tail = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-增加头结点\"><a href=\"#2-增加头结点\" class=\"headerlink\" title=\"2. 增加头结点\"></a>2. 增加头结点</h3><p>在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> l2:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = target = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                tail.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        tail.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target.next</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Merge-Two-Sorted-Lists\"><a href=\"#Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"Merge Two Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge Two Sorted Lists</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br>（合并有序链表）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_21.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个链表指针\"><a href=\"#1-三个链表指针\" class=\"headerlink\" title=\"1. 三个链表指针\"></a>1. 三个链表指针</h3><p>链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l2 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">            target = l1</span><br><span class=\"line\">            p = l1.next</span><br><span class=\"line\">            q = l2</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            target = l2</span><br><span class=\"line\">            p = l1</span><br><span class=\"line\">            q = l2.next</span><br><span class=\"line\">        tail = target</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt;= q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                tail = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                tail = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-增加头结点\"><a href=\"#2-增加头结点\" class=\"headerlink\" title=\"2. 增加头结点\"></a>2. 增加头结点</h3><p>在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> l2:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = target = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                tail.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        tail.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Merge k Sorted Lists","date":"2018-12-11T14:34:00.000Z","_content":"\n## [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\n\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n（合并k个有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_23.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法\n这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nclass Solution:\n    def merge2Lists(self, left, right):\n        head = ListNode(0)\n        p = left\n        q = right\n        tail = head\n        \n        while p != None and q != None:\n            if p.val < q.val:\n                tail.next = p\n                p = p.next\n            else:\n                tail.next = q\n                q = q.next\n            tail = tail.next\n        \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n            \n        return head.next\n        \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        n = len(lists)\n        if n == 0:\n            return []\n        if n == 1:\n            return lists[0]\n        \n        left_list = self.mergeKLists(lists[:n//2])\n        right_list = self.mergeKLists(lists[n//2:])\n        return self.merge2Lists(left_list, right_list)\n```\n\n\n### 2. 堆排序\n另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nfrom heapq import heappush, heappop\n\nclass Solution:      \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if lists == []:\n            return []\n        \n        heap = []\n        for list in lists:\n            while list:\n                heappush(heap, list.val)\n                list = list.next\n       \n        head = ListNode(0)\n        tail = head\n        while heap:\n            tail.next = ListNode(heappop(heap))\n            tail = tail.next\n        \n        return head.next\n```\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-MergekSortedLists.md","raw":"---\ntitle: LeetCode_Merge k Sorted Lists\ndate: 2018-12-11 22:34:00\ncategories: LeetCode\ntags: \n  - hard\n  - linked list\n  - heap\n  - divide and conquer\n---\n\n## [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\n\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n（合并k个有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_23.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法\n这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nclass Solution:\n    def merge2Lists(self, left, right):\n        head = ListNode(0)\n        p = left\n        q = right\n        tail = head\n        \n        while p != None and q != None:\n            if p.val < q.val:\n                tail.next = p\n                p = p.next\n            else:\n                tail.next = q\n                q = q.next\n            tail = tail.next\n        \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n            \n        return head.next\n        \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        n = len(lists)\n        if n == 0:\n            return []\n        if n == 1:\n            return lists[0]\n        \n        left_list = self.mergeKLists(lists[:n//2])\n        right_list = self.mergeKLists(lists[n//2:])\n        return self.merge2Lists(left_list, right_list)\n```\n\n\n### 2. 堆排序\n另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nfrom heapq import heappush, heappop\n\nclass Solution:      \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if lists == []:\n            return []\n        \n        heap = []\n        for list in lists:\n            while list:\n                heappush(heap, list.val)\n                list = list.next\n       \n        head = ListNode(0)\n        tail = head\n        while heap:\n            tail.next = ListNode(heappop(heap))\n            tail = tail.next\n        \n        return head.next\n```\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-MergekSortedLists","published":1,"updated":"2018-12-11T15:11:31.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7x001kc3zm16id2nwh","content":"<h2 id=\"Merge-k-Sorted-Lists\"><a href=\"#Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"Merge k Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge k Sorted Lists</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br>（合并k个有序链表）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_23.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法\"><a href=\"#1-分治法\" class=\"headerlink\" title=\"1. 分治法\"></a>1. 分治法</h3><p>这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge2Lists</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = left</span><br><span class=\"line\">        q = right</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt; q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(lists)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        left_list = self.mergeKLists(lists[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        right_list = self.mergeKLists(lists[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.merge2Lists(left_list, right_list)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-堆排序\"><a href=\"#2-堆排序\" class=\"headerlink\" title=\"2. 堆排序\"></a>2. 堆排序</h3><p>另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> heapq <span class=\"keyword\">import</span> heappush, heappop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists == []:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        heap = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> list:</span><br><span class=\"line\">                heappush(heap, list.val)</span><br><span class=\"line\">                list = list.next</span><br><span class=\"line\">       </span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">            tail.next = ListNode(heappop(heap))</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Merge-k-Sorted-Lists\"><a href=\"#Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"Merge k Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge k Sorted Lists</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br>（合并k个有序链表）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_23.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法\"><a href=\"#1-分治法\" class=\"headerlink\" title=\"1. 分治法\"></a>1. 分治法</h3><p>这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge2Lists</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = left</span><br><span class=\"line\">        q = right</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt; q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(lists)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        left_list = self.mergeKLists(lists[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        right_list = self.mergeKLists(lists[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.merge2Lists(left_list, right_list)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-堆排序\"><a href=\"#2-堆排序\" class=\"headerlink\" title=\"2. 堆排序\"></a>2. 堆排序</h3><p>另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> heapq <span class=\"keyword\">import</span> heappush, heappop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists == []:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        heap = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> list:</span><br><span class=\"line\">                heappush(heap, list.val)</span><br><span class=\"line\">                list = list.next</span><br><span class=\"line\">       </span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">            tail.next = ListNode(heappop(heap))</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Median of Two Sorted Arrays","date":"2018-11-23T10:30:10.000Z","_content":"\n## [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\nThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be **O(log (m+n))**. You may assume nums1 and nums2 cannot be both empty.\n（两个有序数组的中位数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_4.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法_1\n我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\\\((m+n)\\\\)个数中的第\\\\((m+n)/2\\\\)数值的大小（需要单独考虑\\\\((m+n)\\\\)的奇偶性）。其时间复杂度为 \\\\(O(log(m+n))\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def findKth(self, nums1, nums2, k):\n        if not nums1:\n            return nums2[k]\n        if not nums2:\n            return nums1[k]\n        \n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        i, j = len1 // 2, len2 // 2\n        \n        if i + j < k:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1, nums2[j+1:], k-j-1)\n            else:\n                return self.findKth(nums1[i+1: ], nums2, k-i-1)\n        else:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1[:i], nums2, k)\n            else:\n                return self.findKth(nums1, nums2[:j], k)\n                \n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        length = len(nums1) + len(nums2)\n        \n        if length % 2:\n            return self.findKth(nums1, nums2, length//2)\n        else:\n            return (self.findKth(nums1, nums2, length//2) + self.findKth(nums1, nums2, length//2-1))/2\n```\n\n### 2. 分治法_2\n与上面的思路相同，但是不同的是找第 \\\\(k\\\\) 个值时，并不是直接将两个数组混合一起找第 \\\\(k\\\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\\\(i\\\\)，使得 \\\\(A[i]\\\\) 和 \\\\(B[k-i]\\\\) 刚好满足其中一个是第\\\\(k\\\\)个数。其时间复杂度为 \\\\(O(log(min(m, n)))\\\\)。具体实现过程如下：\n```python\ndef findKth(self, nums1, nums2, k):\n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        if len1 > len2:\n            len1, len2, nums1, nums2 = len2, len1, nums2, nums1\n        if not nums1:\n            return nums2[k]\n        if k == len1 + len2 - 1:\n            return max(nums1[-1], nums2[-1])\n        \n        i = len1 // 2\n        j = k - i\n        \n        if nums1[i] > nums2[j]:\n            # Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.\n            return self.findKth(nums1[:i], nums2[j:], i)\n        else:\n            return self.findKth(nums1[i:], nums2[:j], j)\n```\n\n### 3. Sort()函数\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        num = sorted(nums1 + nums2)\n        l = len(num)\n        if l%2 == 0:\n            return((num[l//2] + num[l//2-1])/2)\n        if l%2 != 0:\n            return(num[l//2])\n```","source":"_posts/leetcode-MedianofTwoSortedArrays.md","raw":"---\ntitle: LeetCode_Median of Two Sorted Arrays\ndate: 2018-11-23 18:30:10\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - binary search\n  - divide and conquer\n---\n\n## [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\nThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be **O(log (m+n))**. You may assume nums1 and nums2 cannot be both empty.\n（两个有序数组的中位数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_4.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法_1\n我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\\\((m+n)\\\\)个数中的第\\\\((m+n)/2\\\\)数值的大小（需要单独考虑\\\\((m+n)\\\\)的奇偶性）。其时间复杂度为 \\\\(O(log(m+n))\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def findKth(self, nums1, nums2, k):\n        if not nums1:\n            return nums2[k]\n        if not nums2:\n            return nums1[k]\n        \n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        i, j = len1 // 2, len2 // 2\n        \n        if i + j < k:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1, nums2[j+1:], k-j-1)\n            else:\n                return self.findKth(nums1[i+1: ], nums2, k-i-1)\n        else:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1[:i], nums2, k)\n            else:\n                return self.findKth(nums1, nums2[:j], k)\n                \n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        length = len(nums1) + len(nums2)\n        \n        if length % 2:\n            return self.findKth(nums1, nums2, length//2)\n        else:\n            return (self.findKth(nums1, nums2, length//2) + self.findKth(nums1, nums2, length//2-1))/2\n```\n\n### 2. 分治法_2\n与上面的思路相同，但是不同的是找第 \\\\(k\\\\) 个值时，并不是直接将两个数组混合一起找第 \\\\(k\\\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\\\(i\\\\)，使得 \\\\(A[i]\\\\) 和 \\\\(B[k-i]\\\\) 刚好满足其中一个是第\\\\(k\\\\)个数。其时间复杂度为 \\\\(O(log(min(m, n)))\\\\)。具体实现过程如下：\n```python\ndef findKth(self, nums1, nums2, k):\n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        if len1 > len2:\n            len1, len2, nums1, nums2 = len2, len1, nums2, nums1\n        if not nums1:\n            return nums2[k]\n        if k == len1 + len2 - 1:\n            return max(nums1[-1], nums2[-1])\n        \n        i = len1 // 2\n        j = k - i\n        \n        if nums1[i] > nums2[j]:\n            # Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.\n            return self.findKth(nums1[:i], nums2[j:], i)\n        else:\n            return self.findKth(nums1[i:], nums2[:j], j)\n```\n\n### 3. Sort()函数\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        num = sorted(nums1 + nums2)\n        l = len(num)\n        if l%2 == 0:\n            return((num[l//2] + num[l//2-1])/2)\n        if l%2 != 0:\n            return(num[l//2])\n```","slug":"leetcode-MedianofTwoSortedArrays","published":1,"updated":"2018-11-29T03:23:37.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh7y001mc3zmn0jycm9c","content":"<h2 id=\"Median-of-Two-Sorted-Arrays\"><a href=\"#Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"Median of Two Sorted Arrays\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">Median of Two Sorted Arrays</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be <strong>O(log (m+n))</strong>. You may assume nums1 and nums2 cannot be both empty.<br>（两个有序数组的中位数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_4.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法-1\"><a href=\"#1-分治法-1\" class=\"headerlink\" title=\"1. 分治法_1\"></a>1. 分治法_1</h3><p>我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\((m+n)\\)个数中的第\\((m+n)/2\\)数值的大小（需要单独考虑\\((m+n)\\)的奇偶性）。其时间复杂度为 \\(O(log(m+n))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums1[k]</span><br><span class=\"line\">        </span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        i, j = len1 // <span class=\"number\">2</span>, len2 // <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + j &lt; k:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[j+<span class=\"number\">1</span>:], k-j<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[i+<span class=\"number\">1</span>: ], nums2, k-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2, k)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[:j], k)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        length = len(nums1) + len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> length % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1, nums2, length//<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.findKth(nums1, nums2, length//<span class=\"number\">2</span>) + self.findKth(nums1, nums2, length//<span class=\"number\">2</span><span class=\"number\">-1</span>))/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-分治法-2\"><a href=\"#2-分治法-2\" class=\"headerlink\" title=\"2. 分治法_2\"></a>2. 分治法_2</h3><p>与上面的思路相同，但是不同的是找第 \\(k\\) 个值时，并不是直接将两个数组混合一起找第 \\(k\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\(i\\)，使得 \\(A[i]\\) 和 \\(B[k-i]\\) 刚好满足其中一个是第\\(k\\)个数。其时间复杂度为 \\(O(log(min(m, n)))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len1 &gt; len2:</span><br><span class=\"line\">            len1, len2, nums1, nums2 = len2, len1, nums2, nums1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == len1 + len2 - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max(nums1[<span class=\"number\">-1</span>], nums2[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = len1 // <span class=\"number\">2</span></span><br><span class=\"line\">        j = k - i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">            <span class=\"comment\"># Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2[j:], i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[i:], nums2[:j], j)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-Sort-函数\"><a href=\"#3-Sort-函数\" class=\"headerlink\" title=\"3. Sort()函数\"></a>3. Sort()函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num = sorted(nums1 + nums2)</span><br><span class=\"line\">        l = len(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>((num[l//<span class=\"number\">2</span>] + num[l//<span class=\"number\">2</span><span class=\"number\">-1</span>])/<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>(num[l//<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Median-of-Two-Sorted-Arrays\"><a href=\"#Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"Median of Two Sorted Arrays\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">Median of Two Sorted Arrays</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be <strong>O(log (m+n))</strong>. You may assume nums1 and nums2 cannot be both empty.<br>（两个有序数组的中位数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_4.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法-1\"><a href=\"#1-分治法-1\" class=\"headerlink\" title=\"1. 分治法_1\"></a>1. 分治法_1</h3><p>我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\((m+n)\\)个数中的第\\((m+n)/2\\)数值的大小（需要单独考虑\\((m+n)\\)的奇偶性）。其时间复杂度为 \\(O(log(m+n))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums1[k]</span><br><span class=\"line\">        </span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        i, j = len1 // <span class=\"number\">2</span>, len2 // <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + j &lt; k:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[j+<span class=\"number\">1</span>:], k-j<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[i+<span class=\"number\">1</span>: ], nums2, k-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2, k)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[:j], k)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        length = len(nums1) + len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> length % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1, nums2, length//<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.findKth(nums1, nums2, length//<span class=\"number\">2</span>) + self.findKth(nums1, nums2, length//<span class=\"number\">2</span><span class=\"number\">-1</span>))/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-分治法-2\"><a href=\"#2-分治法-2\" class=\"headerlink\" title=\"2. 分治法_2\"></a>2. 分治法_2</h3><p>与上面的思路相同，但是不同的是找第 \\(k\\) 个值时，并不是直接将两个数组混合一起找第 \\(k\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\(i\\)，使得 \\(A[i]\\) 和 \\(B[k-i]\\) 刚好满足其中一个是第\\(k\\)个数。其时间复杂度为 \\(O(log(min(m, n)))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len1 &gt; len2:</span><br><span class=\"line\">            len1, len2, nums1, nums2 = len2, len1, nums2, nums1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == len1 + len2 - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max(nums1[<span class=\"number\">-1</span>], nums2[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = len1 // <span class=\"number\">2</span></span><br><span class=\"line\">        j = k - i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">            <span class=\"comment\"># Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2[j:], i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[i:], nums2[:j], j)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-Sort-函数\"><a href=\"#3-Sort-函数\" class=\"headerlink\" title=\"3. Sort()函数\"></a>3. Sort()函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num = sorted(nums1 + nums2)</span><br><span class=\"line\">        l = len(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>((num[l//<span class=\"number\">2</span>] + num[l//<span class=\"number\">2</span><span class=\"number\">-1</span>])/<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>(num[l//<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Next Permutation","date":"2018-12-21T02:13:55.000Z","_content":"\n## [Next Permutation](https://leetcode.com/problems/next-permutation/)\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.\n（从小到大全排列的下一个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_31.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 后向遍历\n整体的思路就是从后向前遍历：\n1. 当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。\n2. 将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。\n3. 再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。\n\n```python\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return\n        for i in range(n-1, -1, -1):\n            if i == 0:\n                nums.reverse()\n                return \n            if nums[i] > nums[i-1]:\n                break\n        \n        j, k = i, n-1\n        while j < k:\n            nums[j], nums[k] = nums[k], nums[j]\n            j += 1\n            k -= 1\n      \n        for j in range(i, n):\n            if nums[j] > nums[i-1]:\n                nums[i-1], nums[j] = nums[j], nums[i-1]\n                break\n            \n        return\n```\n\n\n## 2. 后向遍历\n另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。","source":"_posts/leetcode-NextPermutation.md","raw":"---\ntitle: LeetCode_Next Permutation\ndate: 2018-12-21 10:13:55\ncategories: LeetCode\ntags: \n  - medium\n  - array\n---\n\n## [Next Permutation](https://leetcode.com/problems/next-permutation/)\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.\n（从小到大全排列的下一个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_31.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 后向遍历\n整体的思路就是从后向前遍历：\n1. 当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。\n2. 将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。\n3. 再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。\n\n```python\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return\n        for i in range(n-1, -1, -1):\n            if i == 0:\n                nums.reverse()\n                return \n            if nums[i] > nums[i-1]:\n                break\n        \n        j, k = i, n-1\n        while j < k:\n            nums[j], nums[k] = nums[k], nums[j]\n            j += 1\n            k -= 1\n      \n        for j in range(i, n):\n            if nums[j] > nums[i-1]:\n                nums[i-1], nums[j] = nums[j], nums[i-1]\n                break\n            \n        return\n```\n\n\n## 2. 后向遍历\n另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。","slug":"leetcode-NextPermutation","published":1,"updated":"2018-12-21T02:54:15.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh80001pc3zmduj943i5","content":"<h2 id=\"Next-Permutation\"><a href=\"#Next-Permutation\" class=\"headerlink\" title=\"Next Permutation\"></a><a href=\"https://leetcode.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">Next Permutation</a></h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.<br>（从小到大全排列的下一个）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_31.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-后向遍历\"><a href=\"#1-后向遍历\" class=\"headerlink\" title=\"1. 后向遍历\"></a>1. 后向遍历</h3><p>整体的思路就是从后向前遍历：</p>\n<ol>\n<li>当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。</li>\n<li>将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。</li>\n<li>再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums.reverse()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        j, k = i, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">            nums[j], nums[k] = nums[k], nums[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                nums[i<span class=\"number\">-1</span>], nums[j] = nums[j], nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-后向遍历\"><a href=\"#2-后向遍历\" class=\"headerlink\" title=\"2. 后向遍历\"></a>2. 后向遍历</h2><p>另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Next-Permutation\"><a href=\"#Next-Permutation\" class=\"headerlink\" title=\"Next Permutation\"></a><a href=\"https://leetcode.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">Next Permutation</a></h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.<br>（从小到大全排列的下一个）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_31.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-后向遍历\"><a href=\"#1-后向遍历\" class=\"headerlink\" title=\"1. 后向遍历\"></a>1. 后向遍历</h3><p>整体的思路就是从后向前遍历：</p>\n<ol>\n<li>当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。</li>\n<li>将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。</li>\n<li>再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums.reverse()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        j, k = i, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">            nums[j], nums[k] = nums[k], nums[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                nums[i<span class=\"number\">-1</span>], nums[j] = nums[j], nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-后向遍历\"><a href=\"#2-后向遍历\" class=\"headerlink\" title=\"2. 后向遍历\"></a>2. 后向遍历</h2><p>另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。</p>"},{"title":"LeetCode_Palindrome Number","date":"2018-11-26T13:56:36.000Z","_content":"\n## [Palindrome Number](https://leetcode.com/problems/palindrome-number/)\n\nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n（判断数字是否是回文序列）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_9.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串翻转\n\n```python\nclass Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        string  = str(x)\n        \n        return string == string[::-1]\n```","source":"_posts/leetcode-PalindromeNumber.md","raw":"---\ntitle: LeetCode_Palindrome Number\ndate: 2018-11-26 21:56:36\ncategories: LeetCode\ntags: \n  - easy\n  - math\n---\n\n## [Palindrome Number](https://leetcode.com/problems/palindrome-number/)\n\nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n（判断数字是否是回文序列）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_9.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串翻转\n\n```python\nclass Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        string  = str(x)\n        \n        return string == string[::-1]\n```","slug":"leetcode-PalindromeNumber","published":1,"updated":"2018-11-27T06:24:58.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh83001sc3zm181cvidw","content":"<h2 id=\"Palindrome-Number\"><a href=\"#Palindrome-Number\" class=\"headerlink\" title=\"Palindrome Number\"></a><a href=\"https://leetcode.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">Palindrome Number</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br>（判断数字是否是回文序列）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_9.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串翻转\"><a href=\"#字符串翻转\" class=\"headerlink\" title=\"字符串翻转\"></a>字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string  = str(x)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> string == string[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Palindrome-Number\"><a href=\"#Palindrome-Number\" class=\"headerlink\" title=\"Palindrome Number\"></a><a href=\"https://leetcode.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">Palindrome Number</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br>（判断数字是否是回文序列）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_9.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串翻转\"><a href=\"#字符串翻转\" class=\"headerlink\" title=\"字符串翻转\"></a>字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string  = str(x)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> string == string[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Multiply Strings","date":"2019-01-03T14:45:45.000Z","_content":"\n## [Multiply Strings](https://leetcode.com/problems/multiply-strings/)\n\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n（用非库函数的方式返回两个字符串表示的整数的乘积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_43.png\" width = \"500\" align=center/>\n</div>\n\nNote:\n- The length of both num1 and num2 is < 110.\n- Both num1 and num2 contain only digits 0-9.\n- Both num1 and num2 do not contain any leading zero, except the number 0 itself.\n- You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n### 实现库函数 atoi 和 itoa\n由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 `ord()`表示将字符转换为ASCII码，`chr()`表示将ASCII码转换为字符。具体实现过程如下：\n\n```python\nclass Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        def atoi(s):\n            result = 0\n            for char in s:\n                result = result * 10 + (ord(char) - ord('0'))\n            return result\n    \n        def itoa(num):\n            if num == 0:\n                return \"0\"\n            s = \"\"\n            while num:\n                char = num % 10 + ord('0')\n                s = chr(char) + s\n                num = num // 10\n            \n            return s\n        \n        return itoa(atoi(num1) * atoi(num2))\n```","source":"_posts/leetcode-MultiplyStrings.md","raw":"---\ntitle: LeetCode_Multiply Strings\ndate: 2019-01-03 22:45:45\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - string\n---\n\n## [Multiply Strings](https://leetcode.com/problems/multiply-strings/)\n\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n（用非库函数的方式返回两个字符串表示的整数的乘积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_43.png\" width = \"500\" align=center/>\n</div>\n\nNote:\n- The length of both num1 and num2 is < 110.\n- Both num1 and num2 contain only digits 0-9.\n- Both num1 and num2 do not contain any leading zero, except the number 0 itself.\n- You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n### 实现库函数 atoi 和 itoa\n由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 `ord()`表示将字符转换为ASCII码，`chr()`表示将ASCII码转换为字符。具体实现过程如下：\n\n```python\nclass Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        def atoi(s):\n            result = 0\n            for char in s:\n                result = result * 10 + (ord(char) - ord('0'))\n            return result\n    \n        def itoa(num):\n            if num == 0:\n                return \"0\"\n            s = \"\"\n            while num:\n                char = num % 10 + ord('0')\n                s = chr(char) + s\n                num = num // 10\n            \n            return s\n        \n        return itoa(atoi(num1) * atoi(num2))\n```","slug":"leetcode-MultiplyStrings","published":1,"updated":"2019-01-03T15:02:36.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh84001wc3zm96wc77qf","content":"<h2 id=\"Multiply-Strings\"><a href=\"#Multiply-Strings\" class=\"headerlink\" title=\"Multiply Strings\"></a><a href=\"https://leetcode.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">Multiply Strings</a></h2><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.<br>（用非库函数的方式返回两个字符串表示的整数的乘积）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_43.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>Note:</p>\n<ul>\n<li>The length of both num1 and num2 is &lt; 110.</li>\n<li>Both num1 and num2 contain only digits 0-9.</li>\n<li>Both num1 and num2 do not contain any leading zero, except the number 0 itself.</li>\n<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>\n</ul>\n<h3 id=\"实现库函数-atoi-和-itoa\"><a href=\"#实现库函数-atoi-和-itoa\" class=\"headerlink\" title=\"实现库函数 atoi 和 itoa\"></a>实现库函数 atoi 和 itoa</h3><p>由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 <code>ord()</code>表示将字符转换为ASCII码，<code>chr()</code>表示将ASCII码转换为字符。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, num1, num2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num1: str</span></span><br><span class=\"line\"><span class=\"string\">        :type num2: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">atoi</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">                result = result * <span class=\"number\">10</span> + (ord(char) - ord(<span class=\"string\">'0'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">itoa</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span></span><br><span class=\"line\">            s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> num:</span><br><span class=\"line\">                char = num % <span class=\"number\">10</span> + ord(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">                s = chr(char) + s</span><br><span class=\"line\">                num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> itoa(atoi(num1) * atoi(num2))</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Multiply-Strings\"><a href=\"#Multiply-Strings\" class=\"headerlink\" title=\"Multiply Strings\"></a><a href=\"https://leetcode.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">Multiply Strings</a></h2><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.<br>（用非库函数的方式返回两个字符串表示的整数的乘积）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_43.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>Note:</p>\n<ul>\n<li>The length of both num1 and num2 is &lt; 110.</li>\n<li>Both num1 and num2 contain only digits 0-9.</li>\n<li>Both num1 and num2 do not contain any leading zero, except the number 0 itself.</li>\n<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>\n</ul>\n<h3 id=\"实现库函数-atoi-和-itoa\"><a href=\"#实现库函数-atoi-和-itoa\" class=\"headerlink\" title=\"实现库函数 atoi 和 itoa\"></a>实现库函数 atoi 和 itoa</h3><p>由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 <code>ord()</code>表示将字符转换为ASCII码，<code>chr()</code>表示将ASCII码转换为字符。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, num1, num2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num1: str</span></span><br><span class=\"line\"><span class=\"string\">        :type num2: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">atoi</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">                result = result * <span class=\"number\">10</span> + (ord(char) - ord(<span class=\"string\">'0'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">itoa</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span></span><br><span class=\"line\">            s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> num:</span><br><span class=\"line\">                char = num % <span class=\"number\">10</span> + ord(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">                s = chr(char) + s</span><br><span class=\"line\">                num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> itoa(atoi(num1) * atoi(num2))</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Regular Expression Matching","date":"2018-11-26T14:13:49.000Z","_content":"\n## [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)\n\nGiven an input **string (s)** and a **pattern (p)**, implement regular expression matching with support for **.** and **\\***, **.** matches any single character, **\\*** matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\n（字符串正则表达式匹配）\n\n<!--more-->\n\nNote:\n**s** could be empty and contains only lowercase letters a-z.\n**p** could be empty and contains only lowercase letters a-z, and characters like . or \\*.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_10.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归算法\n正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。\n  - len(p) >= 2 and p[1] = \\*，则需要分类讨论：\n  \t - p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；\n  \t - p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；\n  - len(p) < 2，可以直接判断；\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return not s\n        \n        first_match = bool(s) and (p[0] in {s[0], '.'})\n        \n        if len(p) >=2 and p[1] == '*':\n            return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])\n```\n\n### 2. 动态规划\ndp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 `j >= 2 and dp[i][j-2]` 表示不扩展当前的 \\* ，即认为此次匹配了0个。 `i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}` 表示扩展当前的 \\* ，即认为此次匹配了1个。\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s = len(s)\n        len_p = len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n        \n        dp[0][0] = True\n        for i in range(len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = (i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}) or (j >= 2 and dp[i][j-2])\n                else:\n                    dp[i][j] = (i >= 1 and dp[i-1][j-1] and p[j-1] in {s[i-1], '.'})\n                    \n        return dp[len_s][len_p]\n```\n\n\n\n\n\n\n","source":"_posts/leetcode-RegularExpressionMatching.md","raw":"---\ntitle: LeetCode_Regular Expression Matching\ndate: 2018-11-26 22:13:49\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n  - backtracking\n---\n\n## [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)\n\nGiven an input **string (s)** and a **pattern (p)**, implement regular expression matching with support for **.** and **\\***, **.** matches any single character, **\\*** matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\n（字符串正则表达式匹配）\n\n<!--more-->\n\nNote:\n**s** could be empty and contains only lowercase letters a-z.\n**p** could be empty and contains only lowercase letters a-z, and characters like . or \\*.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_10.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归算法\n正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。\n  - len(p) >= 2 and p[1] = \\*，则需要分类讨论：\n  \t - p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；\n  \t - p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；\n  - len(p) < 2，可以直接判断；\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return not s\n        \n        first_match = bool(s) and (p[0] in {s[0], '.'})\n        \n        if len(p) >=2 and p[1] == '*':\n            return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])\n```\n\n### 2. 动态规划\ndp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 `j >= 2 and dp[i][j-2]` 表示不扩展当前的 \\* ，即认为此次匹配了0个。 `i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}` 表示扩展当前的 \\* ，即认为此次匹配了1个。\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s = len(s)\n        len_p = len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n        \n        dp[0][0] = True\n        for i in range(len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = (i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}) or (j >= 2 and dp[i][j-2])\n                else:\n                    dp[i][j] = (i >= 1 and dp[i-1][j-1] and p[j-1] in {s[i-1], '.'})\n                    \n        return dp[len_s][len_p]\n```\n\n\n\n\n\n\n","slug":"leetcode-RegularExpressionMatching","published":1,"updated":"2018-12-04T10:54:38.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh87001zc3zmtkw2y8vr","content":"<h2 id=\"Regular-Expression-Matching\"><a href=\"#Regular-Expression-Matching\" class=\"headerlink\" title=\"Regular Expression Matching\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/\" target=\"_blank\" rel=\"noopener\">Regular Expression Matching</a></h2><p>Given an input <strong>string (s)</strong> and a <strong>pattern (p)</strong>, implement regular expression matching with support for <strong>.</strong> and <strong>*</strong>, <strong>.</strong> matches any single character, <strong>*</strong> matches zero or more of the preceding element. The matching should cover the entire input string (not partial).<br>（字符串正则表达式匹配）</p>\n<a id=\"more\"></a>\n<p>Note:<br><strong>s</strong> could be empty and contains only lowercase letters a-z.<br><strong>p</strong> could be empty and contains only lowercase letters a-z, and characters like . or *.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_10.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归算法\"><a href=\"#1-递归算法\" class=\"headerlink\" title=\"1. 递归算法\"></a>1. 递归算法</h3><p>正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。</p>\n<ul>\n<li>len(p) &gt;= 2 and p[1] = *，则需要分类讨论：<ul>\n<li>p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；</li>\n<li>p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；</li>\n</ul>\n</li>\n<li>len(p) &lt; 2，可以直接判断；</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        first_match = bool(s) <span class=\"keyword\">and</span> (p[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> &#123;s[<span class=\"number\">0</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> p[<span class=\"number\">1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.isMatch(s, p[<span class=\"number\">2</span>:])) <span class=\"keyword\">or</span> (first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 <code>j &gt;= 2 and dp[i][j-2]</code> 表示不扩展当前的 * ，即认为此次匹配了0个。 <code>i &gt;= 1 and j &gt;= 2 and dp[i-1][j] and p[j-2] in {s[i-1], &#39;.&#39;}</code> 表示扩展当前的 * ，即认为此次匹配了1个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        len_p = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len_p + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len_p + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> p[j<span class=\"number\">-2</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;) <span class=\"keyword\">or</span> (j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i][j<span class=\"number\">-2</span>])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> p[j<span class=\"number\">-1</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_s][len_p]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Regular-Expression-Matching\"><a href=\"#Regular-Expression-Matching\" class=\"headerlink\" title=\"Regular Expression Matching\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/\" target=\"_blank\" rel=\"noopener\">Regular Expression Matching</a></h2><p>Given an input <strong>string (s)</strong> and a <strong>pattern (p)</strong>, implement regular expression matching with support for <strong>.</strong> and <strong>*</strong>, <strong>.</strong> matches any single character, <strong>*</strong> matches zero or more of the preceding element. The matching should cover the entire input string (not partial).<br>（字符串正则表达式匹配）</p>","more":"<p>Note:<br><strong>s</strong> could be empty and contains only lowercase letters a-z.<br><strong>p</strong> could be empty and contains only lowercase letters a-z, and characters like . or *.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_10.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归算法\"><a href=\"#1-递归算法\" class=\"headerlink\" title=\"1. 递归算法\"></a>1. 递归算法</h3><p>正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。</p>\n<ul>\n<li>len(p) &gt;= 2 and p[1] = *，则需要分类讨论：<ul>\n<li>p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；</li>\n<li>p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；</li>\n</ul>\n</li>\n<li>len(p) &lt; 2，可以直接判断；</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        first_match = bool(s) <span class=\"keyword\">and</span> (p[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> &#123;s[<span class=\"number\">0</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> p[<span class=\"number\">1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.isMatch(s, p[<span class=\"number\">2</span>:])) <span class=\"keyword\">or</span> (first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 <code>j &gt;= 2 and dp[i][j-2]</code> 表示不扩展当前的 * ，即认为此次匹配了0个。 <code>i &gt;= 1 and j &gt;= 2 and dp[i-1][j] and p[j-2] in {s[i-1], &#39;.&#39;}</code> 表示扩展当前的 * ，即认为此次匹配了1个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        len_p = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len_p + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len_p + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> p[j<span class=\"number\">-2</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;) <span class=\"keyword\">or</span> (j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i][j<span class=\"number\">-2</span>])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> p[j<span class=\"number\">-1</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_s][len_p]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Duplicates from Sorted Array","date":"2018-12-18T06:48:12.000Z","_content":"\n## [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n（删除数组中重复的元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_26.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 重复元素个数\n这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        k = 0\n        now = None\n        for i, item in enumerate(nums):\n            if item != now:\n                now = item\n                if k != 0:\n                    nums[i-k] = item\n            else:\n                k += 1\n        \n        return len(nums)-k\n```","source":"_posts/leetcode-RemoveDuplicatesfromSortedArray.md","raw":"---\ntitle: LeetCode_Remove Duplicates from Sorted Array\ndate: 2018-12-18 14:48:12\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - two pointers\n---\n\n## [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n（删除数组中重复的元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_26.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 重复元素个数\n这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        k = 0\n        now = None\n        for i, item in enumerate(nums):\n            if item != now:\n                now = item\n                if k != 0:\n                    nums[i-k] = item\n            else:\n                k += 1\n        \n        return len(nums)-k\n```","slug":"leetcode-RemoveDuplicatesfromSortedArray","published":1,"updated":"2018-12-18T08:13:23.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8a0023c3zm8ncrbsyr","content":"<h2 id=\"Remove-Duplicates-from-Sorted-Array\"><a href=\"#Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>（删除数组中重复的元素，限制空间复杂度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_26.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-重复元素个数\"><a href=\"#1-重复元素个数\" class=\"headerlink\" title=\"1. 重复元素个数\"></a>1. 重复元素个数</h3><p>这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        now = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item != now:</span><br><span class=\"line\">                now = item</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    nums[i-k] = item</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Duplicates-from-Sorted-Array\"><a href=\"#Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>（删除数组中重复的元素，限制空间复杂度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_26.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-重复元素个数\"><a href=\"#1-重复元素个数\" class=\"headerlink\" title=\"1. 重复元素个数\"></a>1. 重复元素个数</h3><p>这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        now = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item != now:</span><br><span class=\"line\">                now = item</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    nums[i-k] = item</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Element","date":"2018-12-18T08:12:33.000Z","_content":"\n## [Remove Element](https://leetcode.com/problems/remove-element/)\n\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n（删除数组中特定元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_27.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 特定元素个数\n这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        k = 0\n        for i, item in enumerate(nums):\n            if item == val:\n                k += 1\n            else:\n                nums[i-k] = item\n        \n        return len(nums)-k\n```","source":"_posts/leetcode-RemoveElement.md","raw":"---\ntitle: LeetCode_Remove Element\ndate: 2018-12-18 16:12:33\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - two pointers\n---\n\n## [Remove Element](https://leetcode.com/problems/remove-element/)\n\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n（删除数组中特定元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_27.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 特定元素个数\n这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        k = 0\n        for i, item in enumerate(nums):\n            if item == val:\n                k += 1\n            else:\n                nums[i-k] = item\n        \n        return len(nums)-k\n```","slug":"leetcode-RemoveElement","published":1,"updated":"2018-12-18T08:20:02.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8d0026c3zm7d9rdd0d","content":"<h2 id=\"Remove-Element\"><a href=\"#Remove-Element\" class=\"headerlink\" title=\"Remove Element\"></a><a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.<br>（删除数组中特定元素，限制空间复杂度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_27.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-特定元素个数\"><a href=\"#1-特定元素个数\" class=\"headerlink\" title=\"1. 特定元素个数\"></a>1. 特定元素个数</h3><p>这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElement</span><span class=\"params\">(self, nums, val)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item == val:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[i-k] = item</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Element\"><a href=\"#Remove-Element\" class=\"headerlink\" title=\"Remove Element\"></a><a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.<br>（删除数组中特定元素，限制空间复杂度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_27.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-特定元素个数\"><a href=\"#1-特定元素个数\" class=\"headerlink\" title=\"1. 特定元素个数\"></a>1. 特定元素个数</h3><p>这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElement</span><span class=\"params\">(self, nums, val)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item == val:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[i-k] = item</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Reverse Integer","date":"2018-11-26T07:26:31.000Z","_content":"\n## [Reverse Integer](https://leetcode.com/problems/reverse-integer/)\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n（翻转一个有符号整形数值字符串）\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_7.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 字符串翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        string = str(x)\n        n = len(string)\n        \n        if string[0] == '-':\n            result = [string[n-i] for i in range(1, n)]\n            result = ['-'] + result\n        else:\n            result = [string[n-i-1] for i in range(n)]\n        \n        re = int(\"\".join(result))\n        \n        if re > pow(2, 31) - 1 or re < - pow(2, 31):\n            re = 0\n        return re\n```\n\n**注**：超过有符号整形的范围时需要返回0。另外`string[::-1]`也可以直接实现字符串的翻转。\n\n\n### 2. 整形翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        abso_x = abs(x)\n        result = 0\n        \n        while abso_x != 0 :\n            a = abso_x % 10\n            abso_x = abso_x // 10\n            result = result * 10  + a\n            \n        if x < 0:\n            result *= -1  \n            \n        if result > (pow(2, 31) - 1) or result < -pow(2, 31):\n            return 0\n        \n        return result\n```\n\n\n\n","source":"_posts/leetcode-ReverseInteger.md","raw":"---\ntitle: LeetCode_Reverse Integer\ndate: 2018-11-26 15:26:31\ncategories: LeetCode\ntags: \n  - easy\n  - math\n---\n\n## [Reverse Integer](https://leetcode.com/problems/reverse-integer/)\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n（翻转一个有符号整形数值字符串）\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_7.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 字符串翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        string = str(x)\n        n = len(string)\n        \n        if string[0] == '-':\n            result = [string[n-i] for i in range(1, n)]\n            result = ['-'] + result\n        else:\n            result = [string[n-i-1] for i in range(n)]\n        \n        re = int(\"\".join(result))\n        \n        if re > pow(2, 31) - 1 or re < - pow(2, 31):\n            re = 0\n        return re\n```\n\n**注**：超过有符号整形的范围时需要返回0。另外`string[::-1]`也可以直接实现字符串的翻转。\n\n\n### 2. 整形翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        abso_x = abs(x)\n        result = 0\n        \n        while abso_x != 0 :\n            a = abso_x % 10\n            abso_x = abso_x // 10\n            result = result * 10  + a\n            \n        if x < 0:\n            result *= -1  \n            \n        if result > (pow(2, 31) - 1) or result < -pow(2, 31):\n            return 0\n        \n        return result\n```\n\n\n\n","slug":"leetcode-ReverseInteger","published":1,"updated":"2018-11-27T06:25:10.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8f0028c3zmobee82r8","content":"<h2 id=\"Reverse-Integer\"><a href=\"#Reverse-Integer\" class=\"headerlink\" title=\"Reverse Integer\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">Reverse Integer</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.<br>（翻转一个有符号整形数值字符串）</p>\n<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_7.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-字符串翻转\"><a href=\"#1-字符串翻转\" class=\"headerlink\" title=\"1. 字符串翻转\"></a>1. 字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str(x)</span><br><span class=\"line\">        n = len(string)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = [string[n-i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n)]</span><br><span class=\"line\">            result = [<span class=\"string\">'-'</span>] + result</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = [string[n-i<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = int(<span class=\"string\">\"\"</span>.join(result))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> re &gt; pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span> <span class=\"keyword\">or</span> re &lt; - pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：超过有符号整形的范围时需要返回0。另外<code>string[::-1]</code>也可以直接实现字符串的翻转。</p>\n<h3 id=\"2-整形翻转\"><a href=\"#2-整形翻转\" class=\"headerlink\" title=\"2. 整形翻转\"></a>2. 整形翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        abso_x = abs(x)</span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> abso_x != <span class=\"number\">0</span> :</span><br><span class=\"line\">            a = abso_x % <span class=\"number\">10</span></span><br><span class=\"line\">            abso_x = abso_x // <span class=\"number\">10</span></span><br><span class=\"line\">            result = result * <span class=\"number\">10</span>  + a</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            result *= <span class=\"number\">-1</span>  </span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; (pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"keyword\">or</span> result &lt; -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Reverse-Integer\"><a href=\"#Reverse-Integer\" class=\"headerlink\" title=\"Reverse Integer\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">Reverse Integer</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.<br>（翻转一个有符号整形数值字符串）</p>\n<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_7.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-字符串翻转\"><a href=\"#1-字符串翻转\" class=\"headerlink\" title=\"1. 字符串翻转\"></a>1. 字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str(x)</span><br><span class=\"line\">        n = len(string)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = [string[n-i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n)]</span><br><span class=\"line\">            result = [<span class=\"string\">'-'</span>] + result</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = [string[n-i<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = int(<span class=\"string\">\"\"</span>.join(result))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> re &gt; pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span> <span class=\"keyword\">or</span> re &lt; - pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：超过有符号整形的范围时需要返回0。另外<code>string[::-1]</code>也可以直接实现字符串的翻转。</p>\n<h3 id=\"2-整形翻转\"><a href=\"#2-整形翻转\" class=\"headerlink\" title=\"2. 整形翻转\"></a>2. 整形翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        abso_x = abs(x)</span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> abso_x != <span class=\"number\">0</span> :</span><br><span class=\"line\">            a = abso_x % <span class=\"number\">10</span></span><br><span class=\"line\">            abso_x = abso_x // <span class=\"number\">10</span></span><br><span class=\"line\">            result = result * <span class=\"number\">10</span>  + a</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            result *= <span class=\"number\">-1</span>  </span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; (pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"keyword\">or</span> result &lt; -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Count and Say","date":"2018-12-24T10:15:52.000Z","_content":"\n## [Count and Say](https://leetcode.com/problems/count-and-say/)\n\n读字符串\n\n<!--more-->\n\n这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：\n1. n = 1时，返回‘1’\n2. n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’\n3. n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’\n3. n时，对n-1的对应的字符串读取的过程进行输出。\n\n这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：\n\n### 1. 递归\n```python\nclass Solution:\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return '1'\n\n        last_string = self.countAndSay(n-1)\n\n        match_char = last_string[0]\n        match_count = 0\n\n        result_string = ''\n\n        for char in last_string:\n            if char == match_char:\n                match_count += 1\n            else:\n                result_string += str(match_count) + match_char\n                match_char = char\n                match_count = 1\n        \n        result_string += str(match_count) + match_char\n        return result_string\n```","source":"_posts/leetcode-CountandSay.md","raw":"---\ntitle: LeetCode_Count and Say\ndate: 2018-12-24 18:15:52\ncategories: LeetCode\ntags: \n  - easy\n  - string\n---\n\n## [Count and Say](https://leetcode.com/problems/count-and-say/)\n\n读字符串\n\n<!--more-->\n\n这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：\n1. n = 1时，返回‘1’\n2. n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’\n3. n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’\n3. n时，对n-1的对应的字符串读取的过程进行输出。\n\n这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：\n\n### 1. 递归\n```python\nclass Solution:\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return '1'\n\n        last_string = self.countAndSay(n-1)\n\n        match_char = last_string[0]\n        match_count = 0\n\n        result_string = ''\n\n        for char in last_string:\n            if char == match_char:\n                match_count += 1\n            else:\n                result_string += str(match_count) + match_char\n                match_char = char\n                match_count = 1\n        \n        result_string += str(match_count) + match_char\n        return result_string\n```","slug":"leetcode-CountandSay","published":1,"updated":"2018-12-24T10:42:33.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8k002cc3zmzeh5ahib","content":"<h2 id=\"Count-and-Say\"><a href=\"#Count-and-Say\" class=\"headerlink\" title=\"Count and Say\"></a><a href=\"https://leetcode.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">Count and Say</a></h2><p>读字符串</p>\n<a id=\"more\"></a>\n<p>这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：</p>\n<ol>\n<li>n = 1时，返回‘1’</li>\n<li>n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’</li>\n<li>n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’</li>\n<li>n时，对n-1的对应的字符串读取的过程进行输出。</li>\n</ol>\n<p>这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：</p>\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">        last_string = self.countAndSay(n<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        match_char = last_string[<span class=\"number\">0</span>]</span><br><span class=\"line\">        match_count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        result_string = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> last_string:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char == match_char:</span><br><span class=\"line\">                match_count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result_string += str(match_count) + match_char</span><br><span class=\"line\">                match_char = char</span><br><span class=\"line\">                match_count = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result_string += str(match_count) + match_char</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result_string</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Count-and-Say\"><a href=\"#Count-and-Say\" class=\"headerlink\" title=\"Count and Say\"></a><a href=\"https://leetcode.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">Count and Say</a></h2><p>读字符串</p>","more":"<p>这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：</p>\n<ol>\n<li>n = 1时，返回‘1’</li>\n<li>n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’</li>\n<li>n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’</li>\n<li>n时，对n-1的对应的字符串读取的过程进行输出。</li>\n</ol>\n<p>这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：</p>\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">        last_string = self.countAndSay(n<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        match_char = last_string[<span class=\"number\">0</span>]</span><br><span class=\"line\">        match_count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        result_string = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> last_string:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char == match_char:</span><br><span class=\"line\">                match_count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result_string += str(match_count) + match_char</span><br><span class=\"line\">                match_char = char</span><br><span class=\"line\">                match_count = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result_string += str(match_count) + match_char</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result_string</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Reverse Nodes in k-Group","date":"2018-12-18T05:48:13.000Z","_content":"\n## [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n（链表分组倒排）\n\nNote:\n * Only constant extra memory is allowed.\n * You may not alter the values in the list's nodes, only nodes itself may be changed.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_25.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 链表指针问题（头节点）\n遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverse(self, p_prev_head, p_head, p_tail, k):\n        p = p_head\n        new_p = ListNode(0)\n        new_p.next = p_tail.next\n\n        while k != 0:\n            k -= 1\n            tmp = p.next\n            p.next = new_p.next\n            new_p.next = p\n            p = tmp\n        \n        p_prev_head.next = new_p.next\n         \n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if k == 1:\n            return head\n        \n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_prev_head = new_head\n        p_head = head\n        p_tail = head\n        \n        i = 1\n        while p_tail != None:\n            if i == k:\n                i = 1\n                self.reverse(p_prev_head, p_head, p_tail, k)\n                p_prev_head = p_head\n                p_head = p_prev_head.next\n                p_tail = p_head\n            else:\n                i += 1\n                p_tail = p_tail.next\n        \n        return new_head.next\n```\n\n","source":"_posts/leetcode-ReverseNodesink-Group.md","raw":"---\ntitle: LeetCode_Reverse Nodes in k-Group\ndate: 2018-12-18 13:48:13\ncategories: LeetCode\ntags: \n  - hard\n  - linked list\n---\n\n## [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n（链表分组倒排）\n\nNote:\n * Only constant extra memory is allowed.\n * You may not alter the values in the list's nodes, only nodes itself may be changed.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_25.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 链表指针问题（头节点）\n遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverse(self, p_prev_head, p_head, p_tail, k):\n        p = p_head\n        new_p = ListNode(0)\n        new_p.next = p_tail.next\n\n        while k != 0:\n            k -= 1\n            tmp = p.next\n            p.next = new_p.next\n            new_p.next = p\n            p = tmp\n        \n        p_prev_head.next = new_p.next\n         \n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if k == 1:\n            return head\n        \n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_prev_head = new_head\n        p_head = head\n        p_tail = head\n        \n        i = 1\n        while p_tail != None:\n            if i == k:\n                i = 1\n                self.reverse(p_prev_head, p_head, p_tail, k)\n                p_prev_head = p_head\n                p_head = p_prev_head.next\n                p_tail = p_head\n            else:\n                i += 1\n                p_tail = p_tail.next\n        \n        return new_head.next\n```\n\n","slug":"leetcode-ReverseNodesink-Group","published":1,"updated":"2018-12-18T06:48:30.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8m002fc3zmikqfs4as","content":"<h2 id=\"Reverse-Nodes-in-k-Group\"><a href=\"#Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"Reverse Nodes in k-Group\"></a><a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">Reverse Nodes in k-Group</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.<br>（链表分组倒排）</p>\n<p>Note:</p>\n<ul>\n<li>Only constant extra memory is allowed.</li>\n<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>\n</ul>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_25.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-链表指针问题（头节点）\"><a href=\"#1-链表指针问题（头节点）\" class=\"headerlink\" title=\"1. 链表指针问题（头节点）\"></a>1. 链表指针问题（头节点）</h3><p>遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, p_prev_head, p_head, p_tail, k)</span>:</span></span><br><span class=\"line\">        p = p_head</span><br><span class=\"line\">        new_p = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_p.next = p_tail.next</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">            tmp = p.next</span><br><span class=\"line\">            p.next = new_p.next</span><br><span class=\"line\">            new_p.next = p</span><br><span class=\"line\">            p = tmp</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head.next = new_p.next</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        </span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head = new_head</span><br><span class=\"line\">        p_head = head</span><br><span class=\"line\">        p_tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_tail != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == k:</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">                self.reverse(p_prev_head, p_head, p_tail, k)</span><br><span class=\"line\">                p_prev_head = p_head</span><br><span class=\"line\">                p_head = p_prev_head.next</span><br><span class=\"line\">                p_tail = p_head</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                p_tail = p_tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Reverse-Nodes-in-k-Group\"><a href=\"#Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"Reverse Nodes in k-Group\"></a><a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">Reverse Nodes in k-Group</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.<br>（链表分组倒排）</p>\n<p>Note:</p>\n<ul>\n<li>Only constant extra memory is allowed.</li>\n<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>\n</ul>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_25.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-链表指针问题（头节点）\"><a href=\"#1-链表指针问题（头节点）\" class=\"headerlink\" title=\"1. 链表指针问题（头节点）\"></a>1. 链表指针问题（头节点）</h3><p>遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, p_prev_head, p_head, p_tail, k)</span>:</span></span><br><span class=\"line\">        p = p_head</span><br><span class=\"line\">        new_p = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_p.next = p_tail.next</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">            tmp = p.next</span><br><span class=\"line\">            p.next = new_p.next</span><br><span class=\"line\">            new_p.next = p</span><br><span class=\"line\">            p = tmp</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head.next = new_p.next</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        </span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head = new_head</span><br><span class=\"line\">        p_head = head</span><br><span class=\"line\">        p_tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_tail != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == k:</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">                self.reverse(p_prev_head, p_head, p_tail, k)</span><br><span class=\"line\">                p_prev_head = p_head</span><br><span class=\"line\">                p_head = p_prev_head.next</span><br><span class=\"line\">                p_tail = p_head</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                p_tail = p_tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>"},{"title":"leetcode_Remove Nth Node From End of List","date":"2018-12-06T06:41:28.000Z","_content":"\n## [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\nGiven a linked list, remove the n-th node from the end of list and return its head.\n（删除链表尾开始的第 N 个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_19.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 正向定位\n这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        p = head\n        length = 0\n        while p != None:\n            p = p.next\n            length += 1\n        \n        if n > length:\n            return head\n        elif n == length:\n            return head.next\n        else:\n            p = head\n            k = length - n - 1\n            while k != 0:\n                k -= 1\n                p = p.next\n            p.next = p.next.next\n            return head\n```","source":"_posts/leetcode-RemoveNthNodeFromEndofList.md","raw":"---\ntitle: leetcode_Remove Nth Node From End of List\ndate: 2018-12-06 14:41:28\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n  - two pointers\n---\n\n## [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\nGiven a linked list, remove the n-th node from the end of list and return its head.\n（删除链表尾开始的第 N 个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_19.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 正向定位\n这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        p = head\n        length = 0\n        while p != None:\n            p = p.next\n            length += 1\n        \n        if n > length:\n            return head\n        elif n == length:\n            return head.next\n        else:\n            p = head\n            k = length - n - 1\n            while k != 0:\n                k -= 1\n                p = p.next\n            p.next = p.next.next\n            return head\n```","slug":"leetcode-RemoveNthNodeFromEndofList","published":1,"updated":"2018-12-06T07:43:15.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8o002jc3zmpzlwiitg","content":"<h2 id=\"Remove-Nth-Node-From-End-of-List\"><a href=\"#Remove-Nth-Node-From-End-of-List\" class=\"headerlink\" title=\"Remove Nth Node From End of List\"></a><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">Remove Nth Node From End of List</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.<br>（删除链表尾开始的第 N 个）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_19.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-正向定位\"><a href=\"#1-正向定位\" class=\"headerlink\" title=\"1. 正向定位\"></a>1. 正向定位</h3><p>这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        length = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = head</span><br><span class=\"line\">            k = length - n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            p.next = p.next.next</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Nth-Node-From-End-of-List\"><a href=\"#Remove-Nth-Node-From-End-of-List\" class=\"headerlink\" title=\"Remove Nth Node From End of List\"></a><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">Remove Nth Node From End of List</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.<br>（删除链表尾开始的第 N 个）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_19.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-正向定位\"><a href=\"#1-正向定位\" class=\"headerlink\" title=\"1. 正向定位\"></a>1. 正向定位</h3><p>这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        length = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = head</span><br><span class=\"line\">            k = length - n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            p.next = p.next.next</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Roman to Integer","date":"2018-11-29T02:29:41.000Z","_content":"\n# [Roman to Integer](https://leetcode.com/problems/roman-to-integer/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（罗马字符转整数）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_13.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历字符串_1\n遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M': 1000,\n            'CM': 900,\n            'D': 500,\n            'CD': 400,\n            'C': 100,\n            'XC': 90,\n            'L': 50,\n            'XL': 40,\n            'X': 10,\n            'IX': 9,\n            'V': 5,\n            'IV': 4,\n            'I': 1\n        }\n\n        result = 0\n        n = len(s)\n        i = 0\n        while i < n:\n            if i < n-1 and s[i:i+2] in base:\n                result += base[s[i:i+2]]\n                i += 2\n            elif s[i] in base:\n                result += base[s[i]]\n                i += 1\n            \n        return result \n```\n\n### 2. 遍历字符串_2\n直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M':1000,\n            'D':500,\n            'C':100,\n            'L':50,\n            'X':10,\n            'V':5,\n            'I':1\n        }\n        \n        temp = 0\n        result = 0\n        for ch in s:\n            if base[ch] > temp:\n                result -= 2 * temp\n            temp = base[ch]    \n            result += temp\n        \n        return result\n```\n        \n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-RomantoInteger.md","raw":"---\ntitle: LeetCode_Roman to Integer\ndate: 2018-11-29 10:29:41\ncategories: LeetCode\ntags: \n  - easy\n  - math\n  - string\n---\n\n# [Roman to Integer](https://leetcode.com/problems/roman-to-integer/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（罗马字符转整数）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_13.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历字符串_1\n遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M': 1000,\n            'CM': 900,\n            'D': 500,\n            'CD': 400,\n            'C': 100,\n            'XC': 90,\n            'L': 50,\n            'XL': 40,\n            'X': 10,\n            'IX': 9,\n            'V': 5,\n            'IV': 4,\n            'I': 1\n        }\n\n        result = 0\n        n = len(s)\n        i = 0\n        while i < n:\n            if i < n-1 and s[i:i+2] in base:\n                result += base[s[i:i+2]]\n                i += 2\n            elif s[i] in base:\n                result += base[s[i]]\n                i += 1\n            \n        return result \n```\n\n### 2. 遍历字符串_2\n直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M':1000,\n            'D':500,\n            'C':100,\n            'L':50,\n            'X':10,\n            'V':5,\n            'I':1\n        }\n        \n        temp = 0\n        result = 0\n        for ch in s:\n            if base[ch] > temp:\n                result -= 2 * temp\n            temp = base[ch]    \n            result += temp\n        \n        return result\n```\n        \n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-RomantoInteger","published":1,"updated":"2018-11-29T02:36:18.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8p002lc3zme6svzu74","content":"<h1 id=\"Roman-to-Integer\"><a href=\"#Roman-to-Integer\" class=\"headerlink\" title=\"Roman to Integer\"></a><a href=\"https://leetcode.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">Roman to Integer</a></h1><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（罗马字符转整数）</p>\n<a id=\"more\"></a>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_13.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历字符串-1\"><a href=\"#1-遍历字符串-1\" class=\"headerlink\" title=\"1. 遍历字符串_1\"></a>1. 遍历字符串_1</h3><p>遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'CM'</span>: <span class=\"number\">900</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'CD'</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'XC'</span>: <span class=\"number\">90</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>: <span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'XL'</span>: <span class=\"number\">40</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'IX'</span>: <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'IV'</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> s[i:i+<span class=\"number\">2</span>] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i:i+<span class=\"number\">2</span>]]</span><br><span class=\"line\">                i += <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> s[i] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i]]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-遍历字符串-2\"><a href=\"#2-遍历字符串-2\" class=\"headerlink\" title=\"2. 遍历字符串_2\"></a>2. 遍历字符串_2</h3><p>直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>:<span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>:<span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>:<span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>:<span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>:<span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>:<span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>:<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        temp = <span class=\"number\">0</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> base[ch] &gt; temp:</span><br><span class=\"line\">                result -= <span class=\"number\">2</span> * temp</span><br><span class=\"line\">            temp = base[ch]    </span><br><span class=\"line\">            result += temp</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"Roman-to-Integer\"><a href=\"#Roman-to-Integer\" class=\"headerlink\" title=\"Roman to Integer\"></a><a href=\"https://leetcode.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">Roman to Integer</a></h1><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（罗马字符转整数）</p>","more":"<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_13.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历字符串-1\"><a href=\"#1-遍历字符串-1\" class=\"headerlink\" title=\"1. 遍历字符串_1\"></a>1. 遍历字符串_1</h3><p>遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'CM'</span>: <span class=\"number\">900</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'CD'</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'XC'</span>: <span class=\"number\">90</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>: <span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'XL'</span>: <span class=\"number\">40</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'IX'</span>: <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'IV'</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> s[i:i+<span class=\"number\">2</span>] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i:i+<span class=\"number\">2</span>]]</span><br><span class=\"line\">                i += <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> s[i] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i]]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-遍历字符串-2\"><a href=\"#2-遍历字符串-2\" class=\"headerlink\" title=\"2. 遍历字符串_2\"></a>2. 遍历字符串_2</h3><p>直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>:<span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>:<span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>:<span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>:<span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>:<span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>:<span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>:<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        temp = <span class=\"number\">0</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> base[ch] &gt; temp:</span><br><span class=\"line\">                result -= <span class=\"number\">2</span> * temp</span><br><span class=\"line\">            temp = base[ch]    </span><br><span class=\"line\">            result += temp</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Search Insert Position","date":"2018-12-21T06:26:10.000Z","_content":"\n## [Search Insert Position](https://leetcode.com/problems/search-insert-position/)\n\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\n（在有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_35.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        left, right = 0, n-1\n    \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            elif target < nums[middle]:\n                right = middle - 1\n            else:\n                left = middle + 1\n                \n        return left\n```\n\n","source":"_posts/leetcode-SearchInsertPosition.md","raw":"---\ntitle: LeetCode_Search Insert Position\ndate: 2018-12-21 14:26:10\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - binary search\n---\n\n## [Search Insert Position](https://leetcode.com/problems/search-insert-position/)\n\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\n（在有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_35.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        left, right = 0, n-1\n    \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            elif target < nums[middle]:\n                right = middle - 1\n            else:\n                left = middle + 1\n                \n        return left\n```\n\n","slug":"leetcode-SearchInsertPosition","published":1,"updated":"2018-12-21T06:37:52.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8r002oc3zmhz6gwadm","content":"<h2 id=\"Search-Insert-Position\"><a href=\"#Search-Insert-Position\" class=\"headerlink\" title=\"Search Insert Position\"></a><a href=\"https://leetcode.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">Search Insert Position</a></h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.<br>（在有序数组中检索）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_35.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &lt; nums[middle]:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Search-Insert-Position\"><a href=\"#Search-Insert-Position\" class=\"headerlink\" title=\"Search Insert Position\"></a><a href=\"https://leetcode.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">Search Insert Position</a></h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.<br>（在有序数组中检索）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_35.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &lt; nums[middle]:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_String to Integer","date":"2018-11-26T08:23:21.000Z","_content":"\n## [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)\n\nImplement atoi which converts a string to an integer.\n（字符串转32位整形）\n\n<!--more-->\n\nNote:\n\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_8.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串过滤-正则表达式\n首先删除字符串首尾的空格，通过正则表达式过滤剩下以 \"+-0123456789\" 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）\n\n```python\nimport re\n\nclass Solution:\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        string = str.strip()\n        if not re.match(r'^(\\-|\\+)?\\d+', string):\n            return 0\n       \n        INT_MIN = -pow(2, 31)\n        INT_MAX = pow(2, 31) - 1\n        char_string = '+-0123456789'\n        \n        num_string = ''\n        for i, char in enumerate(string):\n            if char not in char_string:\n                break\n            if i != 0 and (char == '+' or char == '-'):\n                break\n            num_string += char\n       \n        if num_string[0] == '-':\n            result = int(num_string[1:])\n            result = max(result * - 1, INT_MIN)\n            return result\n        elif num_string[0] == '+': \n            result = int(num_string[1:])\n        else:\n            result = int(num_string)\n        result = min(result, INT_MAX)  \n        return result\n```\n**注**：需要考虑 \\\\(+/- \\\\) 出现在数字字符串中间的部分，因此 '0-1' 需要通过`if i != 0 and (char == '+' or char == '-')`过滤掉。","source":"_posts/leetcode-StringtoInteger.md","raw":"---\ntitle: LeetCode_String to Integer\ndate: 2018-11-26 16:23:21\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - string\n  - regular expression\n---\n\n## [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)\n\nImplement atoi which converts a string to an integer.\n（字符串转32位整形）\n\n<!--more-->\n\nNote:\n\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_8.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串过滤-正则表达式\n首先删除字符串首尾的空格，通过正则表达式过滤剩下以 \"+-0123456789\" 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）\n\n```python\nimport re\n\nclass Solution:\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        string = str.strip()\n        if not re.match(r'^(\\-|\\+)?\\d+', string):\n            return 0\n       \n        INT_MIN = -pow(2, 31)\n        INT_MAX = pow(2, 31) - 1\n        char_string = '+-0123456789'\n        \n        num_string = ''\n        for i, char in enumerate(string):\n            if char not in char_string:\n                break\n            if i != 0 and (char == '+' or char == '-'):\n                break\n            num_string += char\n       \n        if num_string[0] == '-':\n            result = int(num_string[1:])\n            result = max(result * - 1, INT_MIN)\n            return result\n        elif num_string[0] == '+': \n            result = int(num_string[1:])\n        else:\n            result = int(num_string)\n        result = min(result, INT_MAX)  \n        return result\n```\n**注**：需要考虑 \\\\(+/- \\\\) 出现在数字字符串中间的部分，因此 '0-1' 需要通过`if i != 0 and (char == '+' or char == '-')`过滤掉。","slug":"leetcode-StringtoInteger","published":1,"updated":"2018-11-27T06:25:14.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8s002qc3zmzqibkj43","content":"<h2 id=\"String-to-Integer-atoi\"><a href=\"#String-to-Integer-atoi\" class=\"headerlink\" title=\"String to Integer (atoi)\"></a><a href=\"https://leetcode.com/problems/string-to-integer-atoi/\" target=\"_blank\" rel=\"noopener\">String to Integer (atoi)</a></h2><p>Implement atoi which converts a string to an integer.<br>（字符串转32位整形）</p>\n<a id=\"more\"></a>\n<p>Note:</p>\n<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_8.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串过滤-正则表达式\"><a href=\"#字符串过滤-正则表达式\" class=\"headerlink\" title=\"字符串过滤-正则表达式\"></a>字符串过滤-正则表达式</h3><p>首先删除字符串首尾的空格，通过正则表达式过滤剩下以 “+-0123456789” 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myAtoi</span><span class=\"params\">(self, str)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type str: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str.strip()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re.match(<span class=\"string\">r'^(\\-|\\+)?\\d+'</span>, string):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        INT_MIN = -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\">        INT_MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        char_string = <span class=\"string\">'+-0123456789'</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        num_string = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, char <span class=\"keyword\">in</span> enumerate(string):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> char_string:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> (char == <span class=\"string\">'+'</span> <span class=\"keyword\">or</span> char == <span class=\"string\">'-'</span>):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            num_string += char</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">            result = max(result * - <span class=\"number\">1</span>, INT_MIN)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'+'</span>: </span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = int(num_string)</span><br><span class=\"line\">        result = min(result, INT_MAX)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：需要考虑 \\(+/- \\) 出现在数字字符串中间的部分，因此 ‘0-1’ 需要通过<code>if i != 0 and (char == &#39;+&#39; or char == &#39;-&#39;)</code>过滤掉。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"String-to-Integer-atoi\"><a href=\"#String-to-Integer-atoi\" class=\"headerlink\" title=\"String to Integer (atoi)\"></a><a href=\"https://leetcode.com/problems/string-to-integer-atoi/\" target=\"_blank\" rel=\"noopener\">String to Integer (atoi)</a></h2><p>Implement atoi which converts a string to an integer.<br>（字符串转32位整形）</p>","more":"<p>Note:</p>\n<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_8.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串过滤-正则表达式\"><a href=\"#字符串过滤-正则表达式\" class=\"headerlink\" title=\"字符串过滤-正则表达式\"></a>字符串过滤-正则表达式</h3><p>首先删除字符串首尾的空格，通过正则表达式过滤剩下以 “+-0123456789” 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myAtoi</span><span class=\"params\">(self, str)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type str: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str.strip()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re.match(<span class=\"string\">r'^(\\-|\\+)?\\d+'</span>, string):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        INT_MIN = -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\">        INT_MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        char_string = <span class=\"string\">'+-0123456789'</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        num_string = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, char <span class=\"keyword\">in</span> enumerate(string):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> char_string:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> (char == <span class=\"string\">'+'</span> <span class=\"keyword\">or</span> char == <span class=\"string\">'-'</span>):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            num_string += char</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">            result = max(result * - <span class=\"number\">1</span>, INT_MIN)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'+'</span>: </span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = int(num_string)</span><br><span class=\"line\">        result = min(result, INT_MAX)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：需要考虑 \\(+/- \\) 出现在数字字符串中间的部分，因此 ‘0-1’ 需要通过<code>if i != 0 and (char == &#39;+&#39; or char == &#39;-&#39;)</code>过滤掉。</p>"},{"title":"LeetCode_Search in Rotated Sorted Array","date":"2018-12-21T05:07:49.000Z","_content":"\n## [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\n\nSuppose an **array sorted in ascending order is rotated** at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of **O(log n)**.\n（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_33.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：\n\n```python\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            \n            if nums[left] <= nums[middle]:\n                if target < nums[middle] and target >= nums[left]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n    \n        return -1\n```","source":"_posts/leetcode-SearchinRotatedSortedArray.md","raw":"---\ntitle: LeetCode_Search in Rotated Sorted Array\ndate: 2018-12-21 13:07:49\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - binary search\n---\n\n## [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\n\nSuppose an **array sorted in ascending order is rotated** at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of **O(log n)**.\n（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_33.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：\n\n```python\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            \n            if nums[left] <= nums[middle]:\n                if target < nums[middle] and target >= nums[left]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n    \n        return -1\n```","slug":"leetcode-SearchinRotatedSortedArray","published":1,"updated":"2018-12-21T05:57:37.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8u002uc3zmzpedg9h8","content":"<h2 id=\"Search-in-Rotated-Sorted-Array\"><a href=\"#Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"Search in Rotated Sorted Array\"></a><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array</a></h2><p>Suppose an <strong>array sorted in ascending order is rotated</strong> at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of <strong>O(log n)</strong>.<br>（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_33.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &lt; nums[middle] <span class=\"keyword\">and</span> target &gt;= nums[left]:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &gt; nums[middle] <span class=\"keyword\">and</span> target &lt;= nums[right]:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Search-in-Rotated-Sorted-Array\"><a href=\"#Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"Search in Rotated Sorted Array\"></a><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array</a></h2><p>Suppose an <strong>array sorted in ascending order is rotated</strong> at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of <strong>O(log n)</strong>.<br>（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_33.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &lt; nums[middle] <span class=\"keyword\">and</span> target &gt;= nums[left]:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &gt; nums[middle] <span class=\"keyword\">and</span> target &lt;= nums[right]:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Substring with Concatenation of All Words","date":"2018-12-18T10:21:13.000Z","_content":"\n## [Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)\n\nYou are given a string **s**, and a list of words **words**, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n（找到字符串中所有的子串，其为字符串数组全排列形成）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_30.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 定长取字符串子串\n这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\\\(O(n!)\\\\)算法；而应该从另一个角度出发，遍历字符串。\n\n由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 **words** 是否一致，这里的判断就借用了dict / hash map 实现。\n\n**Note**：\n 1. 边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。\n 2. 边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 \n 3. 字符串切分为等长的字符子串：subs = re.findall('.{'+str(sub_length)+'}', sub)\n\n```python\nimport re\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0 or s == '':\n            return []\n        \n        dict = {}\n        for word in words:\n            if word in dict:\n                dict[word] += 1\n            else:\n                dict[word] = 1\n        \n        sub_length = len(words[0])\n        whole_length = len(words) * sub_length\n        \n        result = []\n        for i in range(len(s) - whole_length + 1):\n            sub = s[i:i + whole_length]\n            subs = re.findall('.{'+str(sub_length)+'}', sub)\n    \n            d = {}\n            flag = 1\n            for word in subs:\n                if word not in dict:\n                    flag = 0\n                    break\n                if word in d:\n                    d[word] += 1\n                else:\n                    d[word] = 1\n            if flag == 1:\n                for item in d:\n                    if d[item] != dict[item]:\n                        flag = 0\n                        break\n            if flag == 1:\n                result.append(i)\n            \n        return result \n```","source":"_posts/leetcode-SubstringwithConcatenationofAllWords.md","raw":"---\ntitle: LeetCode_Substring with Concatenation of All Words\ndate: 2018-12-18 18:21:13\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - hash table\n  - two pointers\n---\n\n## [Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)\n\nYou are given a string **s**, and a list of words **words**, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n（找到字符串中所有的子串，其为字符串数组全排列形成）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_30.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 定长取字符串子串\n这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\\\(O(n!)\\\\)算法；而应该从另一个角度出发，遍历字符串。\n\n由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 **words** 是否一致，这里的判断就借用了dict / hash map 实现。\n\n**Note**：\n 1. 边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。\n 2. 边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 \n 3. 字符串切分为等长的字符子串：subs = re.findall('.{'+str(sub_length)+'}', sub)\n\n```python\nimport re\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0 or s == '':\n            return []\n        \n        dict = {}\n        for word in words:\n            if word in dict:\n                dict[word] += 1\n            else:\n                dict[word] = 1\n        \n        sub_length = len(words[0])\n        whole_length = len(words) * sub_length\n        \n        result = []\n        for i in range(len(s) - whole_length + 1):\n            sub = s[i:i + whole_length]\n            subs = re.findall('.{'+str(sub_length)+'}', sub)\n    \n            d = {}\n            flag = 1\n            for word in subs:\n                if word not in dict:\n                    flag = 0\n                    break\n                if word in d:\n                    d[word] += 1\n                else:\n                    d[word] = 1\n            if flag == 1:\n                for item in d:\n                    if d[item] != dict[item]:\n                        flag = 0\n                        break\n            if flag == 1:\n                result.append(i)\n            \n        return result \n```","slug":"leetcode-SubstringwithConcatenationofAllWords","published":1,"updated":"2018-12-18T13:30:53.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8v002xc3zmeuljeifn","content":"<h2 id=\"Substring-with-Concatenation-of-All-Words\"><a href=\"#Substring-with-Concatenation-of-All-Words\" class=\"headerlink\" title=\"Substring with Concatenation of All Words\"></a><a href=\"https://leetcode.com/problems/substring-with-concatenation-of-all-words/\" target=\"_blank\" rel=\"noopener\">Substring with Concatenation of All Words</a></h2><p>You are given a string <strong>s</strong>, and a list of words <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.<br>（找到字符串中所有的子串，其为字符串数组全排列形成）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_30.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-定长取字符串子串\"><a href=\"#1-定长取字符串子串\" class=\"headerlink\" title=\"1. 定长取字符串子串\"></a>1. 定长取字符串子串</h3><p>这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\(O(n!)\\)算法；而应该从另一个角度出发，遍历字符串。</p>\n<p>由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 <strong>words</strong> 是否一致，这里的判断就借用了dict / hash map 实现。</p>\n<p><strong>Note</strong>：</p>\n<ol>\n<li>边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。</li>\n<li>边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 </li>\n<li>字符串切分为等长的字符子串：subs = re.findall(‘.{‘+str(sub_length)+’}’, sub)</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubstring</span><span class=\"params\">(self, s, words)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type words: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(words) == <span class=\"number\">0</span> <span class=\"keyword\">or</span> s == <span class=\"string\">''</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                dict[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dict[word] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sub_length = len(words[<span class=\"number\">0</span>])</span><br><span class=\"line\">        whole_length = len(words) * sub_length</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s) - whole_length + <span class=\"number\">1</span>):</span><br><span class=\"line\">            sub = s[i:i + whole_length]</span><br><span class=\"line\">            subs = re.findall(<span class=\"string\">'.&#123;'</span>+str(sub_length)+<span class=\"string\">'&#125;'</span>, sub)</span><br><span class=\"line\">    </span><br><span class=\"line\">            d = &#123;&#125;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> subs:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    d[word] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    d[word] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> d[item] != dict[item]:</span><br><span class=\"line\">                        flag = <span class=\"number\">0</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                result.append(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Substring-with-Concatenation-of-All-Words\"><a href=\"#Substring-with-Concatenation-of-All-Words\" class=\"headerlink\" title=\"Substring with Concatenation of All Words\"></a><a href=\"https://leetcode.com/problems/substring-with-concatenation-of-all-words/\" target=\"_blank\" rel=\"noopener\">Substring with Concatenation of All Words</a></h2><p>You are given a string <strong>s</strong>, and a list of words <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.<br>（找到字符串中所有的子串，其为字符串数组全排列形成）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_30.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-定长取字符串子串\"><a href=\"#1-定长取字符串子串\" class=\"headerlink\" title=\"1. 定长取字符串子串\"></a>1. 定长取字符串子串</h3><p>这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\(O(n!)\\)算法；而应该从另一个角度出发，遍历字符串。</p>\n<p>由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 <strong>words</strong> 是否一致，这里的判断就借用了dict / hash map 实现。</p>\n<p><strong>Note</strong>：</p>\n<ol>\n<li>边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。</li>\n<li>边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 </li>\n<li>字符串切分为等长的字符子串：subs = re.findall(‘.{‘+str(sub_length)+’}’, sub)</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubstring</span><span class=\"params\">(self, s, words)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type words: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(words) == <span class=\"number\">0</span> <span class=\"keyword\">or</span> s == <span class=\"string\">''</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                dict[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dict[word] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sub_length = len(words[<span class=\"number\">0</span>])</span><br><span class=\"line\">        whole_length = len(words) * sub_length</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s) - whole_length + <span class=\"number\">1</span>):</span><br><span class=\"line\">            sub = s[i:i + whole_length]</span><br><span class=\"line\">            subs = re.findall(<span class=\"string\">'.&#123;'</span>+str(sub_length)+<span class=\"string\">'&#125;'</span>, sub)</span><br><span class=\"line\">    </span><br><span class=\"line\">            d = &#123;&#125;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> subs:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    d[word] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    d[word] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> d[item] != dict[item]:</span><br><span class=\"line\">                        flag = <span class=\"number\">0</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                result.append(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Sudoku Solver","date":"2018-12-21T13:42:03.000Z","_content":"\n## [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n（求解数独盘）\n\n<!--more-->\n\nA sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits 1-9 must occur exactly once in each row.\n2. Each of the digits 1-9 must occur exactly once in each column.\n3. Each of the the digits 1-9 must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n4. Empty cells are indicated by the character '.'.\n\n**Note:**\n1. The given board contain only digits 1-9 and the character '.'.\n2. You may assume that the given Sudoku puzzle will have a single unique solution.\n3. The given board size is always 9x9.\n\n**Example:** \n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n<div align=center>\n\t<img src=\"/images/leetcode_37.png\" width = \"300\" align=center/>\n</div>\n\n\n### 1. 回溯法 Back Tracking\n求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：\n1. 寻找下一层节点，此处为find_next_empty()。\n2. 判断限制条件，此处为check_constraint()。\n3. 针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。\n\n```python\nclass Solution:\n\t# find the next entry need to fill\n\tdef find_next_empty(self):\n\t\tfor row in range(0, 9):\n\t\t\tfor col in range(0, 9):\n\t\t\t\tif self.board[row][col] == '.':\n\t\t\t\t\treturn [row, col]\n\t\treturn False\n\n\t# check the constraint \n\tdef check_constraint(self, x, y, num):\n\t\t# check row\n\t\tfor data in self.board[x]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check col\n\t\tfor data in list(zip(*self.board))[y]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check square\n\t\tsquare_row = x // 3 * 3\n\t\tsquare_col = y // 3 * 3\n\t\tdatas = []\n\t\tfor i in range(3):\n\t\t\tdatas += self.board[square_row + i][square_col: square_col + 3]\n\t\tfor data in datas:\n\t\t\tif data  == num:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef back_track(self):\n\t\tentry = self.find_next_empty()\n\t\tif entry == False:\n\t\t\treturn True\n\t\telse:\n\t\t\t[row, col] = entry\n\t\t\t# DFS\n\t\t\tfor i in range(1, 10):\n\t\t\t\tcheck = self.check_constraint(row, col, str(i))\n\t\t\t\t# pruning\n\t\t\t\tif check:\n\t\t\t\t\tself.board[row][col] = str(i)\n\t\t\t\t\tre = self.back_track()\n\t\t\t\t\t# back tracking\n\t\t\t\t\tif not re:\n\t\t\t\t\t\tself.board[row][col] = '.'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn True\n\t\t\t\t\t\t\n\t\t\treturn False\t\n\t\t\t\t\t\t\n\tdef solveSudoku(self, board):\n\t\t\"\"\"\n\t\t:type board: List[List[str]]\n\t\t:rtype: void Do not return anything, modify board in-place instead.\n\t\t\"\"\"\n\t\tself.board = board\n\t\tself.back_track()\n```","source":"_posts/leetcode-SudokuSolver.md","raw":"---\ntitle: LeetCode_Sudoku Solver\ndate: 2018-12-21 21:42:03\ncategories: LeetCode\ntags: \n  - hard\n  - hashed table\n  - back tracking\n---\n\n## [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n（求解数独盘）\n\n<!--more-->\n\nA sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits 1-9 must occur exactly once in each row.\n2. Each of the digits 1-9 must occur exactly once in each column.\n3. Each of the the digits 1-9 must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n4. Empty cells are indicated by the character '.'.\n\n**Note:**\n1. The given board contain only digits 1-9 and the character '.'.\n2. You may assume that the given Sudoku puzzle will have a single unique solution.\n3. The given board size is always 9x9.\n\n**Example:** \n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n<div align=center>\n\t<img src=\"/images/leetcode_37.png\" width = \"300\" align=center/>\n</div>\n\n\n### 1. 回溯法 Back Tracking\n求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：\n1. 寻找下一层节点，此处为find_next_empty()。\n2. 判断限制条件，此处为check_constraint()。\n3. 针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。\n\n```python\nclass Solution:\n\t# find the next entry need to fill\n\tdef find_next_empty(self):\n\t\tfor row in range(0, 9):\n\t\t\tfor col in range(0, 9):\n\t\t\t\tif self.board[row][col] == '.':\n\t\t\t\t\treturn [row, col]\n\t\treturn False\n\n\t# check the constraint \n\tdef check_constraint(self, x, y, num):\n\t\t# check row\n\t\tfor data in self.board[x]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check col\n\t\tfor data in list(zip(*self.board))[y]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check square\n\t\tsquare_row = x // 3 * 3\n\t\tsquare_col = y // 3 * 3\n\t\tdatas = []\n\t\tfor i in range(3):\n\t\t\tdatas += self.board[square_row + i][square_col: square_col + 3]\n\t\tfor data in datas:\n\t\t\tif data  == num:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef back_track(self):\n\t\tentry = self.find_next_empty()\n\t\tif entry == False:\n\t\t\treturn True\n\t\telse:\n\t\t\t[row, col] = entry\n\t\t\t# DFS\n\t\t\tfor i in range(1, 10):\n\t\t\t\tcheck = self.check_constraint(row, col, str(i))\n\t\t\t\t# pruning\n\t\t\t\tif check:\n\t\t\t\t\tself.board[row][col] = str(i)\n\t\t\t\t\tre = self.back_track()\n\t\t\t\t\t# back tracking\n\t\t\t\t\tif not re:\n\t\t\t\t\t\tself.board[row][col] = '.'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn True\n\t\t\t\t\t\t\n\t\t\treturn False\t\n\t\t\t\t\t\t\n\tdef solveSudoku(self, board):\n\t\t\"\"\"\n\t\t:type board: List[List[str]]\n\t\t:rtype: void Do not return anything, modify board in-place instead.\n\t\t\"\"\"\n\t\tself.board = board\n\t\tself.back_track()\n```","slug":"leetcode-SudokuSolver","published":1,"updated":"2018-12-24T09:34:56.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8w0031c3zmw7wsfjdn","content":"<h2 id=\"Sudoku-Solver\"><a href=\"#Sudoku-Solver\" class=\"headerlink\" title=\"Sudoku Solver\"></a><a href=\"https://leetcode.com/problems/sudoku-solver/\" target=\"_blank\" rel=\"noopener\">Sudoku Solver</a></h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br>（求解数独盘）</p>\n<a id=\"more\"></a>\n<p>A sudoku solution must satisfy all of the following rules:</p>\n<ol>\n<li>Each of the digits 1-9 must occur exactly once in each row.</li>\n<li>Each of the digits 1-9 must occur exactly once in each column.</li>\n<li>Each of the the digits 1-9 must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n<li>Empty cells are indicated by the character ‘.’.</li>\n</ol>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<div align=\"center\"><br>    <img src=\"/images/leetcode_37.png\" width=\"300\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法-Back-Tracking\"><a href=\"#1-回溯法-Back-Tracking\" class=\"headerlink\" title=\"1. 回溯法 Back Tracking\"></a>1. 回溯法 Back Tracking</h3><p>求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：</p>\n<ol>\n<li>寻找下一层节点，此处为find_next_empty()。</li>\n<li>判断限制条件，此处为check_constraint()。</li>\n<li>针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"comment\"># find the next entry need to fill</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_next_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.board[row][col] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> [row, col]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\"># check the constraint </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_constraint</span><span class=\"params\">(self, x, y, num)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check row</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> self.board[x]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check col</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> list(zip(*self.board))[y]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check square</span></span><br><span class=\"line\">\t\tsquare_row = x // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tsquare_col = y // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tdatas = []</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">\t\t\tdatas += self.board[square_row + i][square_col: square_col + <span class=\"number\">3</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> datas:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data  == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">back_track</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\tentry = self.find_next_empty()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> entry == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t[row, col] = entry</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># DFS</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">\t\t\t\tcheck = self.check_constraint(row, col, str(i))</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\"># pruning</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> check:</span><br><span class=\"line\">\t\t\t\t\tself.board[row][col] = str(i)</span><br><span class=\"line\">\t\t\t\t\tre = self.back_track()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># back tracking</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re:</span><br><span class=\"line\">\t\t\t\t\t\tself.board[row][col] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span>\t</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.board = board</span><br><span class=\"line\">\t\tself.back_track()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Sudoku-Solver\"><a href=\"#Sudoku-Solver\" class=\"headerlink\" title=\"Sudoku Solver\"></a><a href=\"https://leetcode.com/problems/sudoku-solver/\" target=\"_blank\" rel=\"noopener\">Sudoku Solver</a></h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br>（求解数独盘）</p>","more":"<p>A sudoku solution must satisfy all of the following rules:</p>\n<ol>\n<li>Each of the digits 1-9 must occur exactly once in each row.</li>\n<li>Each of the digits 1-9 must occur exactly once in each column.</li>\n<li>Each of the the digits 1-9 must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n<li>Empty cells are indicated by the character ‘.’.</li>\n</ol>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<div align=\"center\"><br>    <img src=\"/images/leetcode_37.png\" width=\"300\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法-Back-Tracking\"><a href=\"#1-回溯法-Back-Tracking\" class=\"headerlink\" title=\"1. 回溯法 Back Tracking\"></a>1. 回溯法 Back Tracking</h3><p>求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：</p>\n<ol>\n<li>寻找下一层节点，此处为find_next_empty()。</li>\n<li>判断限制条件，此处为check_constraint()。</li>\n<li>针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"comment\"># find the next entry need to fill</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_next_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.board[row][col] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> [row, col]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\"># check the constraint </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_constraint</span><span class=\"params\">(self, x, y, num)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check row</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> self.board[x]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check col</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> list(zip(*self.board))[y]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check square</span></span><br><span class=\"line\">\t\tsquare_row = x // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tsquare_col = y // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tdatas = []</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">\t\t\tdatas += self.board[square_row + i][square_col: square_col + <span class=\"number\">3</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> datas:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data  == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">back_track</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\tentry = self.find_next_empty()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> entry == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t[row, col] = entry</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># DFS</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">\t\t\t\tcheck = self.check_constraint(row, col, str(i))</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\"># pruning</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> check:</span><br><span class=\"line\">\t\t\t\t\tself.board[row][col] = str(i)</span><br><span class=\"line\">\t\t\t\t\tre = self.back_track()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># back tracking</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re:</span><br><span class=\"line\">\t\t\t\t\t\tself.board[row][col] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span>\t</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.board = board</span><br><span class=\"line\">\t\tself.back_track()</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Valid Parentheses","date":"2018-12-06T07:44:13.000Z","_content":"\n## [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n（判断有效的括号对）\n\n<!--more-->\n\nAn input string is valid if:\n - Open brackets must be closed by the same type of brackets.\n - Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_20.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 栈匹配\n括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {')': '(', ']': '[', '}': '{'}\n        \n        for ch in s:\n            if ch in mapping:\n                top = stack.pop() if stack else '#'\n                if top != mapping[ch]:\n                    return False\n            else:\n                stack.append(ch)\n                \n        return not stack\n```\n\n### 2. 栈匹配\n后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for c in s:\n            if c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif c == '(':\n                stack.append(')')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack\n```","source":"_posts/leetcode-ValidParentheses.md","raw":"---\ntitle: LeetCode_Valid Parentheses\ndate: 2018-12-06 15:44:13\ncategories: LeetCode\ntags: \n  - easy\n  - string\n  - stack\n---\n\n## [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n（判断有效的括号对）\n\n<!--more-->\n\nAn input string is valid if:\n - Open brackets must be closed by the same type of brackets.\n - Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_20.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 栈匹配\n括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {')': '(', ']': '[', '}': '{'}\n        \n        for ch in s:\n            if ch in mapping:\n                top = stack.pop() if stack else '#'\n                if top != mapping[ch]:\n                    return False\n            else:\n                stack.append(ch)\n                \n        return not stack\n```\n\n### 2. 栈匹配\n后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for c in s:\n            if c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif c == '(':\n                stack.append(')')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack\n```","slug":"leetcode-ValidParentheses","published":1,"updated":"2018-12-06T07:58:38.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8y0034c3zmsl9fqhe3","content":"<h2 id=\"Valid-Parentheses\"><a href=\"#Valid-Parentheses\" class=\"headerlink\" title=\"Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>（判断有效的括号对）</p>\n<a id=\"more\"></a>\n<p>An input string is valid if:</p>\n<ul>\n<li>Open brackets must be closed by the same type of brackets.</li>\n<li>Open brackets must be closed in the correct order.</li>\n</ul>\n<p>Note that an empty string is also considered valid.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_20.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-栈匹配\"><a href=\"#1-栈匹配\" class=\"headerlink\" title=\"1. 栈匹配\"></a>1. 栈匹配</h3><p>括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        mapping = &#123;<span class=\"string\">')'</span>: <span class=\"string\">'('</span>, <span class=\"string\">']'</span>: <span class=\"string\">'['</span>, <span class=\"string\">'&#125;'</span>: <span class=\"string\">'&#123;'</span>&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> mapping:</span><br><span class=\"line\">                top = stack.pop() <span class=\"keyword\">if</span> stack <span class=\"keyword\">else</span> <span class=\"string\">'#'</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> top != mapping[ch]:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.append(ch)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈匹配\"><a href=\"#2-栈匹配\" class=\"headerlink\" title=\"2. 栈匹配\"></a>2. 栈匹配</h3><p>后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == <span class=\"string\">'['</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">']'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">'&#125;'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">')'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> c != stack.pop():</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Valid-Parentheses\"><a href=\"#Valid-Parentheses\" class=\"headerlink\" title=\"Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>（判断有效的括号对）</p>","more":"<p>An input string is valid if:</p>\n<ul>\n<li>Open brackets must be closed by the same type of brackets.</li>\n<li>Open brackets must be closed in the correct order.</li>\n</ul>\n<p>Note that an empty string is also considered valid.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_20.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-栈匹配\"><a href=\"#1-栈匹配\" class=\"headerlink\" title=\"1. 栈匹配\"></a>1. 栈匹配</h3><p>括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        mapping = &#123;<span class=\"string\">')'</span>: <span class=\"string\">'('</span>, <span class=\"string\">']'</span>: <span class=\"string\">'['</span>, <span class=\"string\">'&#125;'</span>: <span class=\"string\">'&#123;'</span>&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> mapping:</span><br><span class=\"line\">                top = stack.pop() <span class=\"keyword\">if</span> stack <span class=\"keyword\">else</span> <span class=\"string\">'#'</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> top != mapping[ch]:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.append(ch)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈匹配\"><a href=\"#2-栈匹配\" class=\"headerlink\" title=\"2. 栈匹配\"></a>2. 栈匹配</h3><p>后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == <span class=\"string\">'['</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">']'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">'&#125;'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">')'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> c != stack.pop():</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Swap Nodes in Pairs","date":"2018-12-13T13:47:54.000Z","_content":"\n## [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\nGiven a linked list, swap every two adjacent nodes and return its head.\n（交换链表中相邻的两个值）\n\n<!--more-->\n\nNote:\n\nYour algorithm should use only **constant** extra space.\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_24.png\" width = \"500\" align=center/>\n</div>\n\n\n### 链表指针\n这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：\n**（引入头指针是一个链表中常用的方法）**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode = ListNode(0)\n        newNode.next = head\n        \n        p = newNode\n        while p.next and p.next.next:\n            q = p.next\n            p.next = q.next\n            q.next = p.next.next\n            p.next.next = q\n            p = q\n               \n        return newNode.next\n```\n\n","source":"_posts/leetcode-SwapNodesinPairs.md","raw":"---\ntitle: LeetCode_Swap Nodes in Pairs\ndate: 2018-12-13 21:47:54\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n---\n\n## [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\nGiven a linked list, swap every two adjacent nodes and return its head.\n（交换链表中相邻的两个值）\n\n<!--more-->\n\nNote:\n\nYour algorithm should use only **constant** extra space.\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_24.png\" width = \"500\" align=center/>\n</div>\n\n\n### 链表指针\n这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：\n**（引入头指针是一个链表中常用的方法）**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode = ListNode(0)\n        newNode.next = head\n        \n        p = newNode\n        while p.next and p.next.next:\n            q = p.next\n            p.next = q.next\n            q.next = p.next.next\n            p.next.next = q\n            p = q\n               \n        return newNode.next\n```\n\n","slug":"leetcode-SwapNodesinPairs","published":1,"updated":"2018-12-26T03:39:34.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh8z0038c3zmjpt71tl9","content":"<h2 id=\"Swap-Nodes-in-Pairs\"><a href=\"#Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"Swap Nodes in Pairs\"></a><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">Swap Nodes in Pairs</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.<br>（交换链表中相邻的两个值）</p>\n<a id=\"more\"></a>\n<p>Note:</p>\n<p>Your algorithm should use only <strong>constant</strong> extra space.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_24.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"链表指针\"><a href=\"#链表指针\" class=\"headerlink\" title=\"链表指针\"></a>链表指针</h3><p>这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：<br><strong>（引入头指针是一个链表中常用的方法）</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        newNode = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        newNode.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = newNode</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p.next <span class=\"keyword\">and</span> p.next.next:</span><br><span class=\"line\">            q = p.next</span><br><span class=\"line\">            p.next = q.next</span><br><span class=\"line\">            q.next = p.next.next</span><br><span class=\"line\">            p.next.next = q</span><br><span class=\"line\">            p = q</span><br><span class=\"line\">               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Swap-Nodes-in-Pairs\"><a href=\"#Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"Swap Nodes in Pairs\"></a><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">Swap Nodes in Pairs</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.<br>（交换链表中相邻的两个值）</p>","more":"<p>Note:</p>\n<p>Your algorithm should use only <strong>constant</strong> extra space.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_24.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"链表指针\"><a href=\"#链表指针\" class=\"headerlink\" title=\"链表指针\"></a>链表指针</h3><p>这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：<br><strong>（引入头指针是一个链表中常用的方法）</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        newNode = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        newNode.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = newNode</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p.next <span class=\"keyword\">and</span> p.next.next:</span><br><span class=\"line\">            q = p.next</span><br><span class=\"line\">            p.next = q.next</span><br><span class=\"line\">            q.next = p.next.next</span><br><span class=\"line\">            p.next.next = q</span><br><span class=\"line\">            p = q</span><br><span class=\"line\">               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Valid Sudoku","date":"2018-12-21T12:56:51.000Z","_content":"\n## [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)\n\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.\n（数独盘有效性判断）\n<!--more-->\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n**Note:**\n1. A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n2. Only the filled cells need to be validated according to the mentioned rules.\n3. The given board contain only digits 1-9 and the character '.'.\n4. The given board size is always 9x9.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_36.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 依次check\n根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。\n\n```python\nclass Solution:\n    def isListValid(self, list):\n        clean = [i for i in list if i != '.']\n        s = set(clean)\n        return len(s) == len(clean)\n    \n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # row check \n        for list in board:\n            if self.isListValid(list) == False:\n                return False\n        \n        # column check\n        for list in zip(*board):\n            if self.isListValid(list) == False:\n                return False\n            \n        # square check\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                list = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if self.isListValid(list) == False:\n                    return False\n        return True\n```\n\n\n### 2. 使用Hash Map\n只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        dict = {}\n        \n        for i, row in enumerate(board):\n            for j, ch in enumerate(row):\n                if ch == '.':\n                    continue\n                if ch in dict:\n                    result_index = dict[ch]\n                    for index in result_index:\n                        if index[0] == i or index[1] == j or index[2] == (i//3, j//3):\n                            return False\n                    dict[ch].append([i, j, (i//3, j//3)])\n                else:\n                    dict[ch] = [[i, j, (i//3, j//3)]]\n\n        return True\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-ValidSudoku.md","raw":"---\ntitle: LeetCode_Valid Sudoku\ndate: 2018-12-21 20:56:51\ncategories: LeetCode\ntags: \n  - medium\n  - hashed table\n---\n\n## [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)\n\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.\n（数独盘有效性判断）\n<!--more-->\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n**Note:**\n1. A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n2. Only the filled cells need to be validated according to the mentioned rules.\n3. The given board contain only digits 1-9 and the character '.'.\n4. The given board size is always 9x9.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_36.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 依次check\n根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。\n\n```python\nclass Solution:\n    def isListValid(self, list):\n        clean = [i for i in list if i != '.']\n        s = set(clean)\n        return len(s) == len(clean)\n    \n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # row check \n        for list in board:\n            if self.isListValid(list) == False:\n                return False\n        \n        # column check\n        for list in zip(*board):\n            if self.isListValid(list) == False:\n                return False\n            \n        # square check\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                list = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if self.isListValid(list) == False:\n                    return False\n        return True\n```\n\n\n### 2. 使用Hash Map\n只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        dict = {}\n        \n        for i, row in enumerate(board):\n            for j, ch in enumerate(row):\n                if ch == '.':\n                    continue\n                if ch in dict:\n                    result_index = dict[ch]\n                    for index in result_index:\n                        if index[0] == i or index[1] == j or index[2] == (i//3, j//3):\n                            return False\n                    dict[ch].append([i, j, (i//3, j//3)])\n                else:\n                    dict[ch] = [[i, j, (i//3, j//3)]]\n\n        return True\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-ValidSudoku","published":1,"updated":"2018-12-21T13:44:57.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh90003bc3zm2fgio1ri","content":"<h2 id=\"Valid-Sudoku\"><a href=\"#Valid-Sudoku\" class=\"headerlink\" title=\"Valid Sudoku\"></a><a href=\"https://leetcode.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">Valid Sudoku</a></h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.<br>（数独盘有效性判断）<br><a id=\"more\"></a></p>\n<ol>\n<li>Each row must contain the digits 1-9 without repetition.</li>\n<li>Each column must contain the digits 1-9 without repetition.</li>\n<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits 1-9 without repetition.</li>\n</ol>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n<li>Only the filled cells need to be validated according to the mentioned rules.</li>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-依次check\"><a href=\"#1-依次check\" class=\"headerlink\" title=\"1. 依次check\"></a>1. 依次check</h3><p>根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isListValid</span><span class=\"params\">(self, list)</span>:</span></span><br><span class=\"line\">        clean = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list <span class=\"keyword\">if</span> i != <span class=\"string\">'.'</span>]</span><br><span class=\"line\">        s = set(clean)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(s) == len(clean)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># row check </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> board:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># column check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> zip(*board):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># square check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                list = [board[x][y] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(i, i + <span class=\"number\">3</span>) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(j, j + <span class=\"number\">3</span>)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用Hash-Map\"><a href=\"#2-使用Hash-Map\" class=\"headerlink\" title=\"2. 使用Hash Map\"></a>2. 使用Hash Map</h3><p>只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j, ch <span class=\"keyword\">in</span> enumerate(row):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result_index = dict[ch]</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> result_index:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> index[<span class=\"number\">0</span>] == i <span class=\"keyword\">or</span> index[<span class=\"number\">1</span>] == j <span class=\"keyword\">or</span> index[<span class=\"number\">2</span>] == (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>):</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">                    dict[ch].append([i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[ch] = [[i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)]]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Valid-Sudoku\"><a href=\"#Valid-Sudoku\" class=\"headerlink\" title=\"Valid Sudoku\"></a><a href=\"https://leetcode.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">Valid Sudoku</a></h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.<br>（数独盘有效性判断）<br>","more":"</p>\n<ol>\n<li>Each row must contain the digits 1-9 without repetition.</li>\n<li>Each column must contain the digits 1-9 without repetition.</li>\n<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits 1-9 without repetition.</li>\n</ol>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n<li>Only the filled cells need to be validated according to the mentioned rules.</li>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-依次check\"><a href=\"#1-依次check\" class=\"headerlink\" title=\"1. 依次check\"></a>1. 依次check</h3><p>根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isListValid</span><span class=\"params\">(self, list)</span>:</span></span><br><span class=\"line\">        clean = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list <span class=\"keyword\">if</span> i != <span class=\"string\">'.'</span>]</span><br><span class=\"line\">        s = set(clean)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(s) == len(clean)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># row check </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> board:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># column check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> zip(*board):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># square check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                list = [board[x][y] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(i, i + <span class=\"number\">3</span>) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(j, j + <span class=\"number\">3</span>)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用Hash-Map\"><a href=\"#2-使用Hash-Map\" class=\"headerlink\" title=\"2. 使用Hash Map\"></a>2. 使用Hash Map</h3><p>只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j, ch <span class=\"keyword\">in</span> enumerate(row):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result_index = dict[ch]</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> result_index:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> index[<span class=\"number\">0</span>] == i <span class=\"keyword\">or</span> index[<span class=\"number\">1</span>] == j <span class=\"keyword\">or</span> index[<span class=\"number\">2</span>] == (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>):</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">                    dict[ch].append([i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[ch] = [[i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)]]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Trapping Rain Water","date":"2018-12-26T03:00:07.000Z","_content":"\n## [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n（收集雨水）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_42.png\" width = \"500\" align=center/>\n</div>\n\n根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。\n\n### 两个指针\n蓄水实质上是找从左到右或者从右到左高度下降的地方：\n设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。\n1. 假设 max_left <= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；\n2. 在 max_left > max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；\n\n最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：\n\n```python\nclass Solution:\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n       \n        result = 0\n\n        max_left, max_right = 0, 0\n        left, right = 0, len(height)-1\n        while left < right:\n            max_left = max(height[left], max_left)\n            max_right = max(height[right], max_right)\n            \n            if max_left <= max_right:\n                result += (max_left - height[left])\n                left += 1\n            else:\n                result += (max_right - height[right])\n                right -= 1\n                \n        return result\n```","source":"_posts/leetcode-TrappingRainWater.md","raw":"---\ntitle: LeetCode_Trapping Rain Water\ndate: 2018-12-26 11:00:07\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - two pointers\n  - stack\n---\n\n## [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n（收集雨水）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_42.png\" width = \"500\" align=center/>\n</div>\n\n根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。\n\n### 两个指针\n蓄水实质上是找从左到右或者从右到左高度下降的地方：\n设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。\n1. 假设 max_left <= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；\n2. 在 max_left > max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；\n\n最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：\n\n```python\nclass Solution:\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n       \n        result = 0\n\n        max_left, max_right = 0, 0\n        left, right = 0, len(height)-1\n        while left < right:\n            max_left = max(height[left], max_left)\n            max_right = max(height[right], max_right)\n            \n            if max_left <= max_right:\n                result += (max_left - height[left])\n                left += 1\n            else:\n                result += (max_right - height[right])\n                right -= 1\n                \n        return result\n```","slug":"leetcode-TrappingRainWater","published":1,"updated":"2019-01-02T12:37:25.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh93003ec3zmcjpqo2gr","content":"<h2 id=\"Trapping-Rain-Water\"><a href=\"#Trapping-Rain-Water\" class=\"headerlink\" title=\"Trapping Rain Water\"></a><a href=\"https://leetcode.com/problems/trapping-rain-water/\" target=\"_blank\" rel=\"noopener\">Trapping Rain Water</a></h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>（收集雨水）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_42.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。</p>\n<h3 id=\"两个指针\"><a href=\"#两个指针\" class=\"headerlink\" title=\"两个指针\"></a>两个指针</h3><p>蓄水实质上是找从左到右或者从右到左高度下降的地方：<br>设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。</p>\n<ol>\n<li>假设 max_left &lt;= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；</li>\n<li>在 max_left &gt; max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；</li>\n</ol>\n<p>最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        max_left, max_right = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, len(height)<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            max_left = max(height[left], max_left)</span><br><span class=\"line\">            max_right = max(height[right], max_right)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_left &lt;= max_right:</span><br><span class=\"line\">                result += (max_left - height[left])</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result += (max_right - height[right])</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Trapping-Rain-Water\"><a href=\"#Trapping-Rain-Water\" class=\"headerlink\" title=\"Trapping Rain Water\"></a><a href=\"https://leetcode.com/problems/trapping-rain-water/\" target=\"_blank\" rel=\"noopener\">Trapping Rain Water</a></h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>（收集雨水）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_42.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。</p>\n<h3 id=\"两个指针\"><a href=\"#两个指针\" class=\"headerlink\" title=\"两个指针\"></a>两个指针</h3><p>蓄水实质上是找从左到右或者从右到左高度下降的地方：<br>设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。</p>\n<ol>\n<li>假设 max_left &lt;= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；</li>\n<li>在 max_left &gt; max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；</li>\n</ol>\n<p>最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        max_left, max_right = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, len(height)<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            max_left = max(height[left], max_left)</span><br><span class=\"line\">            max_right = max(height[right], max_right)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_left &lt;= max_right:</span><br><span class=\"line\">                result += (max_left - height[left])</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result += (max_right - height[right])</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Wildcard Matching","date":"2019-01-06T07:49:16.000Z","_content":"\n## [Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)\n\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '\\*'.\n\n'?' Matches any single character.\n'\\*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n**Note:**\n s could be empty and contains only lowercase letters a-z.\n p could be empty and contains only lowercase letters a-z, and characters like ? or \\*.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_44.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 动态规划\n","source":"_posts/leetcode-WildcardMatching.md","raw":"---\ntitle: LeetCode_Wildcard Matching\ndate: 2019-01-06 15:49:16\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n  - back tracking\n  - greedy\n---\n\n## [Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)\n\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '\\*'.\n\n'?' Matches any single character.\n'\\*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n**Note:**\n s could be empty and contains only lowercase letters a-z.\n p could be empty and contains only lowercase letters a-z, and characters like ? or \\*.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_44.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 动态规划\n","slug":"leetcode-WildcardMatching","published":1,"updated":"2019-01-06T08:01:51.353Z","_id":"cjqkljh94003hc3zmvu19ndym","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Wildcard-Matching\"><a href=\"#Wildcard-Matching\" class=\"headerlink\" title=\"Wildcard Matching\"></a><a href=\"https://leetcode.com/problems/wildcard-matching/\" target=\"_blank\" rel=\"noopener\">Wildcard Matching</a></h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*‘.</p>\n<p>‘?’ Matches any single character.<br>‘*‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>\n<p><strong>Note:</strong><br> s could be empty and contains only lowercase letters a-z.<br> p could be empty and contains only lowercase letters a-z, and characters like ? or *.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_44.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Wildcard-Matching\"><a href=\"#Wildcard-Matching\" class=\"headerlink\" title=\"Wildcard Matching\"></a><a href=\"https://leetcode.com/problems/wildcard-matching/\" target=\"_blank\" rel=\"noopener\">Wildcard Matching</a></h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*‘.</p>\n<p>‘?’ Matches any single character.<br>‘*‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>\n<p><strong>Note:</strong><br> s could be empty and contains only lowercase letters a-z.<br> p could be empty and contains only lowercase letters a-z, and characters like ? or *.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_44.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3>"},{"title":"LeetCode_Add Two Numbers","date":"2018-11-23T03:59:43.000Z","_content":"\n## [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n（字符串/链表数值加法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_2.png\" width = \"500\" align=center/>\n</div>\n\n这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了**链表**的概念来表示组成数值的每个数字。\n\n### 1. 转换为数值计算\n\n很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\\\(O(m + n)\\\\)。\n\n```python\nclass Solution:\n    def list2num(self, l):\n        result = 0\n        j = 0\n        while l != None:\n            num =  10 ** j * l.val\n            result += num\n            l = l.next\n            j += 1 \n        return result\n    \n    def num2list(self, num):\n        if num == 0:\n            return ListNode(0)\n        l = ListNode(0)\n        p = l\n        while num != 0:\n            a = num % 10\n            num = num // 10\n            new_l = ListNode(a)\n            p.next = new_l\n            p = p.next \n        return l.next\n        \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        left = self.list2num(l1)\n        right = self.list2num(l2)\n        return self.num2list(left + right)\n```\n\n### 2. 加法器\n\n我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的**进位**。其时间复杂度为 \\\\(O(max(m + n))\\\\)。\n\n```python\nclass Solution:    \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n       \n        l = None\n        l3 = None\n        a = 0\n        \n        while l1 or l2 or a:\n            if l1:\n                a += l1.val\n                l1 = l1.next\n            if l2:\n                a +=l2.val\n                l2 = l2.next\n            if l3:\n                l3.next = ListNode(a % 10)\n                l3 = l3.next\n            else:\n                l3 = ListNode(a % 10)\n                l = l3\n            \n            a = a // 10\n        \n        return l\n```\n\n**注**：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。","source":"_posts/leetcode-addtwonumbers.md","raw":"---\ntitle: LeetCode_Add Two Numbers\ndate: 2018-11-23 11:59:43\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n  - math\n---\n\n## [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n（字符串/链表数值加法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_2.png\" width = \"500\" align=center/>\n</div>\n\n这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了**链表**的概念来表示组成数值的每个数字。\n\n### 1. 转换为数值计算\n\n很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\\\(O(m + n)\\\\)。\n\n```python\nclass Solution:\n    def list2num(self, l):\n        result = 0\n        j = 0\n        while l != None:\n            num =  10 ** j * l.val\n            result += num\n            l = l.next\n            j += 1 \n        return result\n    \n    def num2list(self, num):\n        if num == 0:\n            return ListNode(0)\n        l = ListNode(0)\n        p = l\n        while num != 0:\n            a = num % 10\n            num = num // 10\n            new_l = ListNode(a)\n            p.next = new_l\n            p = p.next \n        return l.next\n        \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        left = self.list2num(l1)\n        right = self.list2num(l2)\n        return self.num2list(left + right)\n```\n\n### 2. 加法器\n\n我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的**进位**。其时间复杂度为 \\\\(O(max(m + n))\\\\)。\n\n```python\nclass Solution:    \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n       \n        l = None\n        l3 = None\n        a = 0\n        \n        while l1 or l2 or a:\n            if l1:\n                a += l1.val\n                l1 = l1.next\n            if l2:\n                a +=l2.val\n                l2 = l2.next\n            if l3:\n                l3.next = ListNode(a % 10)\n                l3 = l3.next\n            else:\n                l3 = ListNode(a % 10)\n                l = l3\n            \n            a = a // 10\n        \n        return l\n```\n\n**注**：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。","slug":"leetcode-addtwonumbers","published":1,"updated":"2018-11-27T06:19:38.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh96003lc3zm70bel61s","content":"<h2 id=\"Add-Two-Numbers\"><a href=\"#Add-Two-Numbers\" class=\"headerlink\" title=\"Add Two Numbers\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">Add Two Numbers</a></h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>（字符串/链表数值加法）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_2.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了<strong>链表</strong>的概念来表示组成数值的每个数字。</p>\n<h3 id=\"1-转换为数值计算\"><a href=\"#1-转换为数值计算\" class=\"headerlink\" title=\"1. 转换为数值计算\"></a>1. 转换为数值计算</h3><p>很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\(O(m + n)\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list2num</span><span class=\"params\">(self, l)</span>:</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            num =  <span class=\"number\">10</span> ** j * l.val</span><br><span class=\"line\">            result += num</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">            j += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">num2list</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        l = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a = num % <span class=\"number\">10</span></span><br><span class=\"line\">            num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            new_l = ListNode(a)</span><br><span class=\"line\">            p.next = new_l</span><br><span class=\"line\">            p = p.next </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        left = self.list2num(l1)</span><br><span class=\"line\">        right = self.list2num(l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.num2list(left + right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-加法器\"><a href=\"#2-加法器\" class=\"headerlink\" title=\"2. 加法器\"></a>2. 加法器</h3><p>我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的<strong>进位</strong>。其时间复杂度为 \\(O(max(m + n))\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        l = <span class=\"keyword\">None</span></span><br><span class=\"line\">        l3 = <span class=\"keyword\">None</span></span><br><span class=\"line\">        a = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> a:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                a += l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                a +=l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l3:</span><br><span class=\"line\">                l3.next = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l3 = l3.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                l3 = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l = l3</span><br><span class=\"line\">            </span><br><span class=\"line\">            a = a // <span class=\"number\">10</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Add-Two-Numbers\"><a href=\"#Add-Two-Numbers\" class=\"headerlink\" title=\"Add Two Numbers\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">Add Two Numbers</a></h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>（字符串/链表数值加法）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_2.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了<strong>链表</strong>的概念来表示组成数值的每个数字。</p>\n<h3 id=\"1-转换为数值计算\"><a href=\"#1-转换为数值计算\" class=\"headerlink\" title=\"1. 转换为数值计算\"></a>1. 转换为数值计算</h3><p>很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\(O(m + n)\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list2num</span><span class=\"params\">(self, l)</span>:</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            num =  <span class=\"number\">10</span> ** j * l.val</span><br><span class=\"line\">            result += num</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">            j += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">num2list</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        l = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a = num % <span class=\"number\">10</span></span><br><span class=\"line\">            num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            new_l = ListNode(a)</span><br><span class=\"line\">            p.next = new_l</span><br><span class=\"line\">            p = p.next </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        left = self.list2num(l1)</span><br><span class=\"line\">        right = self.list2num(l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.num2list(left + right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-加法器\"><a href=\"#2-加法器\" class=\"headerlink\" title=\"2. 加法器\"></a>2. 加法器</h3><p>我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的<strong>进位</strong>。其时间复杂度为 \\(O(max(m + n))\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        l = <span class=\"keyword\">None</span></span><br><span class=\"line\">        l3 = <span class=\"keyword\">None</span></span><br><span class=\"line\">        a = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> a:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                a += l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                a +=l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l3:</span><br><span class=\"line\">                l3.next = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l3 = l3.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                l3 = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l = l3</span><br><span class=\"line\">            </span><br><span class=\"line\">            a = a // <span class=\"number\">10</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。</p>"},{"title":"LeetCode_Two Sum","date":"2018-11-23T02:57:23.000Z","_content":"\n## [Two Sum](https://leetcode.com/problems/two-sum/)\n\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have **exactly one solution**, and you may **not** use the **same element** twice.\n（一个数组中某两个元素的和为给定值）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_1.png\" width = \"500\" align=center/>\n</div>\n\n这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：\n\n### 1. 暴力循环\n这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\\\(O(n^2)\\\\), 空间复杂度为  \\\\(O(1)\\\\)。\n\n### 2. 构建哈希表\n构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\\\(O(n)\\\\), 空间复杂度为  \\\\(O(n)\\\\)。\n\n(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)\n\n```python\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i, number in enumerate(nums):\n            if (target - number) in d:\n                return [i, d[target-number]]\n            d[number] = i\n```\n\n**注**：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。","source":"_posts/leetcode-twosum.md","raw":"---\ntitle: LeetCode_Two Sum\ndate: 2018-11-23 10:57:23\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - hash table\n---\n\n## [Two Sum](https://leetcode.com/problems/two-sum/)\n\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have **exactly one solution**, and you may **not** use the **same element** twice.\n（一个数组中某两个元素的和为给定值）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_1.png\" width = \"500\" align=center/>\n</div>\n\n这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：\n\n### 1. 暴力循环\n这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\\\(O(n^2)\\\\), 空间复杂度为  \\\\(O(1)\\\\)。\n\n### 2. 构建哈希表\n构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\\\(O(n)\\\\), 空间复杂度为  \\\\(O(n)\\\\)。\n\n(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)\n\n```python\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i, number in enumerate(nums):\n            if (target - number) in d:\n                return [i, d[target-number]]\n            d[number] = i\n```\n\n**注**：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。","slug":"leetcode-twosum","published":1,"updated":"2018-11-27T06:25:21.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh9a003oc3zm4ugiwi1d","content":"<h2 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly one solution</strong>, and you may <strong>not</strong> use the <strong>same element</strong> twice.<br>（一个数组中某两个元素的和为给定值）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_1.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：</p>\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\(O(n^2)\\), 空间复杂度为  \\(O(1)\\)。</p>\n<h3 id=\"2-构建哈希表\"><a href=\"#2-构建哈希表\" class=\"headerlink\" title=\"2. 构建哈希表\"></a>2. 构建哈希表</h3><p>构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\(O(n)\\), 空间复杂度为  \\(O(n)\\)。</p>\n<p>(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, number <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target - number) <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [i, d[target-number]]</span><br><span class=\"line\">            d[number] = i</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly one solution</strong>, and you may <strong>not</strong> use the <strong>same element</strong> twice.<br>（一个数组中某两个元素的和为给定值）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_1.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：</p>\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\(O(n^2)\\), 空间复杂度为  \\(O(1)\\)。</p>\n<h3 id=\"2-构建哈希表\"><a href=\"#2-构建哈希表\" class=\"headerlink\" title=\"2. 构建哈希表\"></a>2. 构建哈希表</h3><p>构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\(O(n)\\), 空间复杂度为  \\(O(n)\\)。</p>\n<p>(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, number <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target - number) <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [i, d[target-number]]</span><br><span class=\"line\">            d[number] = i</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。</p>"},{"title":"Task-Oriented Dialog System","date":"2018-11-15T09:37:35.000Z","_content":"\n面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。\n\n<!--more-->\n\n#### [数据集 In-Car DataSet](https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/)\n数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：\n<div align=center>\n\t<img src=\"/images/diag_example.png\" width = \"600\" align=center/>\n</div>\n\n这个数据集中总共有3031次对话，具体信息如下：\n<div align=center>\n\t<img src=\"/images/diag_statistics.png\" width = \"600\" align=center/>\n</div>\n\n其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：\n<div align=center>\n\t<img src=\"/images/diag_statistics2.png\" width = \"600\" align=center/>\n</div>\n\n特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。\n\n#### Key Value Retrieval Networks [1]\n这个模型是针对此数据集提出的 baseline，将**End-to-End模型**与**信息检索模型**结合。\n\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - LSTM\n 输入：历史对话，\\\\((u_1, s_1, ..., s_{i-1}, u_i)\\\\)\n Hidden State: \\\\(h_i\\\\)\n\n- Decoder\n 输入：\\\\(h_i\\\\)\n Hidden State: \\\\(\\tilde{h_{t}}\\\\)\n 输出：\\\\(y_1, y_2, ..., y_n\\\\)\n 其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。\n\n- Attention\n 在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为**subject**和**relation**的embedding的和\\\\(k_j\\\\)。具体的attention计算过程如下：\n \\\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\\\] \\\\[a_i^t = softmax(u_i^t)\\\\]\\\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\\\]\\\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\\\]\\\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\\\]\\\\[y_t = Softmax(o_t)\\\\]\n 其中，\\\\(\\tilde{v_t}\\\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\\\(\\tilde{v_t}\\\\)中与知识库中相关的表示为\\\\(u_j^t\\\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\\\(v_t\\\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval_result.png\" width = \"600\" align=center/>\n</div>\n\n#### Mem2Seq [2]\n这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。\n\n<div align=center>\n\t<img src=\"/images/mem2seq.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - Multi-hop MemNN\n 输入：U = [B; X]，其中X = {x1, ..., xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, ..., bl}表示知识库。\n 输出：\\\\(o_k\\\\)\n\n \\\\[ p_k^i = Softmax(q_k)^T C_i^k\\\\] \\\\[o_k = \\sum p_k C_{k+1}\\\\] \\\\[q_{k+1} = q_k + o_k\\\\]\n\n 一般的MemNN过程，其中\\\\(C_i\\\\)为Encoder的memory。\n\n- Decoder - GRU + MemNN\n 输入：\\\\(o_k\\\\)\n HiddenState：\\\\(h_t\\\\)\n 输出：\\\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\\\)\n\n \\\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\\\] \\\\[P_{ptr} = p_t^K \\\\]\n\n 其中，\\\\(P_{vocab}(\\hat{y_t})\\\\)结合第一个hop的输出得到输出词在词典上的分布，\\\\(P_{ptr}\\\\)是Decoder中MemNN的最后一个hop的\\\\(p_t^K\\\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/mem2seq_result.png\" width = \"600\" align=center/>\n</div>\n 下面是一个具体的生成案例：\n<div align=center>\n\t<img src=\"/images/mem2seq_result2.png\" width = \"800\" align=center/>\n</div>\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.\n[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.\n\n","source":"_posts/task-oriented-dialog-systems.md","raw":"---\ntitle: Task-Oriented Dialog System\ndate: 2018-11-15 17:37:35\ncategories: Research\ntags: \n  - intent\n  - slot \n  - task-oriented\n---\n\n面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。\n\n<!--more-->\n\n#### [数据集 In-Car DataSet](https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/)\n数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：\n<div align=center>\n\t<img src=\"/images/diag_example.png\" width = \"600\" align=center/>\n</div>\n\n这个数据集中总共有3031次对话，具体信息如下：\n<div align=center>\n\t<img src=\"/images/diag_statistics.png\" width = \"600\" align=center/>\n</div>\n\n其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：\n<div align=center>\n\t<img src=\"/images/diag_statistics2.png\" width = \"600\" align=center/>\n</div>\n\n特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。\n\n#### Key Value Retrieval Networks [1]\n这个模型是针对此数据集提出的 baseline，将**End-to-End模型**与**信息检索模型**结合。\n\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - LSTM\n 输入：历史对话，\\\\((u_1, s_1, ..., s_{i-1}, u_i)\\\\)\n Hidden State: \\\\(h_i\\\\)\n\n- Decoder\n 输入：\\\\(h_i\\\\)\n Hidden State: \\\\(\\tilde{h_{t}}\\\\)\n 输出：\\\\(y_1, y_2, ..., y_n\\\\)\n 其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。\n\n- Attention\n 在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为**subject**和**relation**的embedding的和\\\\(k_j\\\\)。具体的attention计算过程如下：\n \\\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\\\] \\\\[a_i^t = softmax(u_i^t)\\\\]\\\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\\\]\\\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\\\]\\\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\\\]\\\\[y_t = Softmax(o_t)\\\\]\n 其中，\\\\(\\tilde{v_t}\\\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\\\(\\tilde{v_t}\\\\)中与知识库中相关的表示为\\\\(u_j^t\\\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\\\(v_t\\\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval_result.png\" width = \"600\" align=center/>\n</div>\n\n#### Mem2Seq [2]\n这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。\n\n<div align=center>\n\t<img src=\"/images/mem2seq.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - Multi-hop MemNN\n 输入：U = [B; X]，其中X = {x1, ..., xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, ..., bl}表示知识库。\n 输出：\\\\(o_k\\\\)\n\n \\\\[ p_k^i = Softmax(q_k)^T C_i^k\\\\] \\\\[o_k = \\sum p_k C_{k+1}\\\\] \\\\[q_{k+1} = q_k + o_k\\\\]\n\n 一般的MemNN过程，其中\\\\(C_i\\\\)为Encoder的memory。\n\n- Decoder - GRU + MemNN\n 输入：\\\\(o_k\\\\)\n HiddenState：\\\\(h_t\\\\)\n 输出：\\\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\\\)\n\n \\\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\\\] \\\\[P_{ptr} = p_t^K \\\\]\n\n 其中，\\\\(P_{vocab}(\\hat{y_t})\\\\)结合第一个hop的输出得到输出词在词典上的分布，\\\\(P_{ptr}\\\\)是Decoder中MemNN的最后一个hop的\\\\(p_t^K\\\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/mem2seq_result.png\" width = \"600\" align=center/>\n</div>\n 下面是一个具体的生成案例：\n<div align=center>\n\t<img src=\"/images/mem2seq_result2.png\" width = \"800\" align=center/>\n</div>\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.\n[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.\n\n","slug":"task-oriented-dialog-systems","published":1,"updated":"2018-11-27T03:23:40.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh9c003rc3zmm6ku6aka","content":"<p>面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。</p>\n<a id=\"more\"></a>\n<h4 id=\"数据集-In-Car-DataSet\"><a href=\"#数据集-In-Car-DataSet\" class=\"headerlink\" title=\"数据集 In-Car DataSet\"></a><a href=\"https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/\" target=\"_blank\" rel=\"noopener\">数据集 In-Car DataSet</a></h4><p>数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_example.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>这个数据集中总共有3031次对话，具体信息如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics2.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。</p>\n<h4 id=\"Key-Value-Retrieval-Networks-1\"><a href=\"#Key-Value-Retrieval-Networks-1\" class=\"headerlink\" title=\"Key Value Retrieval Networks [1]\"></a>Key Value Retrieval Networks [1]</h4><p>这个模型是针对此数据集提出的 baseline，将<strong>End-to-End模型</strong>与<strong>信息检索模型</strong>结合。</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_kv_retrieval.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - LSTM<br>输入：历史对话，\\((u_1, s_1, …, s_{i-1}, u_i)\\)<br>Hidden State: \\(h_i\\)</p>\n</li>\n<li><p>Decoder<br>输入：\\(h_i\\)<br>Hidden State: \\(\\tilde{h_{t}}\\)<br>输出：\\(y_1, y_2, …, y_n\\)<br>其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。</p>\n</li>\n<li><p>Attention<br>在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为<strong>subject</strong>和<strong>relation</strong>的embedding的和\\(k_j\\)。具体的attention计算过程如下：<br>\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\] \\[a_i^t = softmax(u_i^t)\\]\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\]\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\]\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\]\\[y_t = Softmax(o_t)\\]<br>其中，\\(\\tilde{v_t}\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\(\\tilde{v_t}\\)中与知识库中相关的表示为\\(u_j^t\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\(v_t\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/diag_kv_retrieval_result.png\" width=\"600\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<h4 id=\"Mem2Seq-2\"><a href=\"#Mem2Seq-2\" class=\"headerlink\" title=\"Mem2Seq [2]\"></a>Mem2Seq [2]</h4><p>这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。</p>\n<div align=\"center\"><br>    <img src=\"/images/mem2seq.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - Multi-hop MemNN<br>输入：U = [B; X]，其中X = {x1, …, xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, …, bl}表示知识库。<br>输出：\\(o_k\\)</p>\n<p>\\[ p_k^i = Softmax(q_k)^T C_i^k\\] \\[o_k = \\sum p_k C_{k+1}\\] \\[q_{k+1} = q_k + o_k\\]</p>\n<p>一般的MemNN过程，其中\\(C_i\\)为Encoder的memory。</p>\n</li>\n<li><p>Decoder - GRU + MemNN<br>输入：\\(o_k\\)<br>HiddenState：\\(h_t\\)<br>输出：\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\)</p>\n<p>\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\] \\[P_{ptr} = p_t^K \\]</p>\n<p>其中，\\(P_{vocab}(\\hat{y_t})\\)结合第一个hop的输出得到输出词在词典上的分布，\\(P_{ptr}\\)是Decoder中MemNN的最后一个hop的\\(p_t^K\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/mem2seq_result.png\" width=\"600\" align=\"center/\"><br></div><br>下面是一个具体的生成案例：<br><div align=\"center\"><br>  <img src=\"/images/mem2seq_result2.png\" width=\"800\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.<br>[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.</p>\n","site":{"data":{}},"excerpt":"<p>面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。</p>","more":"<h4 id=\"数据集-In-Car-DataSet\"><a href=\"#数据集-In-Car-DataSet\" class=\"headerlink\" title=\"数据集 In-Car DataSet\"></a><a href=\"https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/\" target=\"_blank\" rel=\"noopener\">数据集 In-Car DataSet</a></h4><p>数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_example.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>这个数据集中总共有3031次对话，具体信息如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics2.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。</p>\n<h4 id=\"Key-Value-Retrieval-Networks-1\"><a href=\"#Key-Value-Retrieval-Networks-1\" class=\"headerlink\" title=\"Key Value Retrieval Networks [1]\"></a>Key Value Retrieval Networks [1]</h4><p>这个模型是针对此数据集提出的 baseline，将<strong>End-to-End模型</strong>与<strong>信息检索模型</strong>结合。</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_kv_retrieval.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - LSTM<br>输入：历史对话，\\((u_1, s_1, …, s_{i-1}, u_i)\\)<br>Hidden State: \\(h_i\\)</p>\n</li>\n<li><p>Decoder<br>输入：\\(h_i\\)<br>Hidden State: \\(\\tilde{h_{t}}\\)<br>输出：\\(y_1, y_2, …, y_n\\)<br>其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。</p>\n</li>\n<li><p>Attention<br>在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为<strong>subject</strong>和<strong>relation</strong>的embedding的和\\(k_j\\)。具体的attention计算过程如下：<br>\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\] \\[a_i^t = softmax(u_i^t)\\]\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\]\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\]\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\]\\[y_t = Softmax(o_t)\\]<br>其中，\\(\\tilde{v_t}\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\(\\tilde{v_t}\\)中与知识库中相关的表示为\\(u_j^t\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\(v_t\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/diag_kv_retrieval_result.png\" width=\"600\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<h4 id=\"Mem2Seq-2\"><a href=\"#Mem2Seq-2\" class=\"headerlink\" title=\"Mem2Seq [2]\"></a>Mem2Seq [2]</h4><p>这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。</p>\n<div align=\"center\"><br>    <img src=\"/images/mem2seq.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - Multi-hop MemNN<br>输入：U = [B; X]，其中X = {x1, …, xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, …, bl}表示知识库。<br>输出：\\(o_k\\)</p>\n<p>\\[ p_k^i = Softmax(q_k)^T C_i^k\\] \\[o_k = \\sum p_k C_{k+1}\\] \\[q_{k+1} = q_k + o_k\\]</p>\n<p>一般的MemNN过程，其中\\(C_i\\)为Encoder的memory。</p>\n</li>\n<li><p>Decoder - GRU + MemNN<br>输入：\\(o_k\\)<br>HiddenState：\\(h_t\\)<br>输出：\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\)</p>\n<p>\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\] \\[P_{ptr} = p_t^K \\]</p>\n<p>其中，\\(P_{vocab}(\\hat{y_t})\\)结合第一个hop的输出得到输出词在词典上的分布，\\(P_{ptr}\\)是Decoder中MemNN的最后一个hop的\\(p_t^K\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/mem2seq_result.png\" width=\"600\" align=\"center/\"><br></div><br>下面是一个具体的生成案例：<br><div align=\"center\"><br>  <img src=\"/images/mem2seq_result2.png\" width=\"800\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.<br>[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.</p>"},{"title":"LeetCode_Zig Zag Conversion","date":"2018-11-26T06:49:30.000Z","_content":"\n## [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\nAnd then read line by line: \"PAHNAPLSIIGYIR\".\n（字符串ZIGZAG之后按行输出）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_6.png\" width = \"500\" align=center/>\n</div>\n\n### 规律\n根据ZigZag的规律，当行数为 numRows 时：\n  - ZigZag的第 i 行字符的序号为 \\\\(k \\* (2 \\* numRows - 2) + i \\\\) ；\n  - ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\\\((k + 1) \\* (2 \\* numRows - 2) - i \\\\)；\n其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n       \n        if numRows == 1:\n            return s\n        \n        result = \"\"\n        n = len(s)\n        add = 2 * numRows - 2 \n        \n        for i in range(numRows):\n            for j in range(0, n-i, add):\n                result += s[i+j]\n                if (i != 0 and i != numRows-1 and j+add-i<n):\n                    result += s[j+add-i]\n        return result\n```\n\n**注**：这里需要特别注意的是保证 \\\\(add = 2 * numRows - 2\\\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。\n\n\n### 变步长遍历字符串\n这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        if numRows == 1 or numRows >= n:\n            return s\n        \n        group_list = [\"\"] * numRows\n\n        index = 0\n        step = 1\n        for char in s:\n            group_list[index] += char\n            \n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n           \n        return \"\".join(group_list)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-ZigZagConversion.md","raw":"---\ntitle: LeetCode_Zig Zag Conversion\ndate: 2018-11-26 14:49:30\ncategories: LeetCode\ntags: \n  - medium\n  - string\n---\n\n## [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\nAnd then read line by line: \"PAHNAPLSIIGYIR\".\n（字符串ZIGZAG之后按行输出）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_6.png\" width = \"500\" align=center/>\n</div>\n\n### 规律\n根据ZigZag的规律，当行数为 numRows 时：\n  - ZigZag的第 i 行字符的序号为 \\\\(k \\* (2 \\* numRows - 2) + i \\\\) ；\n  - ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\\\((k + 1) \\* (2 \\* numRows - 2) - i \\\\)；\n其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n       \n        if numRows == 1:\n            return s\n        \n        result = \"\"\n        n = len(s)\n        add = 2 * numRows - 2 \n        \n        for i in range(numRows):\n            for j in range(0, n-i, add):\n                result += s[i+j]\n                if (i != 0 and i != numRows-1 and j+add-i<n):\n                    result += s[j+add-i]\n        return result\n```\n\n**注**：这里需要特别注意的是保证 \\\\(add = 2 * numRows - 2\\\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。\n\n\n### 变步长遍历字符串\n这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        if numRows == 1 or numRows >= n:\n            return s\n        \n        group_list = [\"\"] * numRows\n\n        index = 0\n        step = 1\n        for char in s:\n            group_list[index] += char\n            \n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n           \n        return \"\".join(group_list)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-ZigZagConversion","published":1,"updated":"2018-11-27T06:25:29.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljh9e003tc3zmu52ufjs1","content":"<h2 id=\"ZigZag-Conversion\"><a href=\"#ZigZag-Conversion\" class=\"headerlink\" title=\"ZigZag Conversion\"></a><a href=\"https://leetcode.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure></p>\n<p>And then read line by line: “PAHNAPLSIIGYIR”.<br>（字符串ZIGZAG之后按行输出）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_6.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"规律\"><a href=\"#规律\" class=\"headerlink\" title=\"规律\"></a>规律</h3><p>根据ZigZag的规律，当行数为 numRows 时：</p>\n<ul>\n<li>ZigZag的第 i 行字符的序号为 \\(k * (2 * numRows - 2) + i \\) ；</li>\n<li>ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\((k + 1) * (2 * numRows - 2) - i \\)；<br>其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        add = <span class=\"number\">2</span> * numRows - <span class=\"number\">2</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numRows):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n-i, add):</span><br><span class=\"line\">                result += s[i+j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> i != numRows<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j+add-i&lt;n):</span><br><span class=\"line\">                    result += s[j+add-i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong>：这里需要特别注意的是保证 \\(add = 2 * numRows - 2\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。</p>\n<h3 id=\"变步长遍历字符串\"><a href=\"#变步长遍历字符串\" class=\"headerlink\" title=\"变步长遍历字符串\"></a>变步长遍历字符串</h3><p>这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span> <span class=\"keyword\">or</span> numRows &gt;= n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        group_list = [<span class=\"string\">\"\"</span>] * numRows</span><br><span class=\"line\"></span><br><span class=\"line\">        index = <span class=\"number\">0</span></span><br><span class=\"line\">        step = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            group_list[index] += char</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> index == <span class=\"number\">0</span>:</span><br><span class=\"line\">                step = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> index == numRows - <span class=\"number\">1</span>:</span><br><span class=\"line\">                step = <span class=\"number\">-1</span></span><br><span class=\"line\">            index += step</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.join(group_list)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ZigZag-Conversion\"><a href=\"#ZigZag-Conversion\" class=\"headerlink\" title=\"ZigZag Conversion\"></a><a href=\"https://leetcode.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure></p>\n<p>And then read line by line: “PAHNAPLSIIGYIR”.<br>（字符串ZIGZAG之后按行输出）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_6.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"规律\"><a href=\"#规律\" class=\"headerlink\" title=\"规律\"></a>规律</h3><p>根据ZigZag的规律，当行数为 numRows 时：</p>\n<ul>\n<li>ZigZag的第 i 行字符的序号为 \\(k * (2 * numRows - 2) + i \\) ；</li>\n<li>ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\((k + 1) * (2 * numRows - 2) - i \\)；<br>其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        add = <span class=\"number\">2</span> * numRows - <span class=\"number\">2</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numRows):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n-i, add):</span><br><span class=\"line\">                result += s[i+j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> i != numRows<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j+add-i&lt;n):</span><br><span class=\"line\">                    result += s[j+add-i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong>：这里需要特别注意的是保证 \\(add = 2 * numRows - 2\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。</p>\n<h3 id=\"变步长遍历字符串\"><a href=\"#变步长遍历字符串\" class=\"headerlink\" title=\"变步长遍历字符串\"></a>变步长遍历字符串</h3><p>这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span> <span class=\"keyword\">or</span> numRows &gt;= n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        group_list = [<span class=\"string\">\"\"</span>] * numRows</span><br><span class=\"line\"></span><br><span class=\"line\">        index = <span class=\"number\">0</span></span><br><span class=\"line\">        step = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            group_list[index] += char</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> index == <span class=\"number\">0</span>:</span><br><span class=\"line\">                step = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> index == numRows - <span class=\"number\">1</span>:</span><br><span class=\"line\">                step = <span class=\"number\">-1</span></span><br><span class=\"line\">            index += step</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.join(group_list)</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Combination Sum II","date":"2018-12-25T10:22:35.000Z","_content":"\n# [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used **once** in the combination.\n（从集合中挑选和为特定值的数字组合，同一元素只可选一次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_40.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法\n\n这道题与上一题的区别在于：\n1. 这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。\n2. candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。\n\n```python\nclass Solution:\n    def backtracking(self, re_set, candidates, target):\n        if target == 0 and list(re_set) not in self.result: \n        \tself.result.append(list(re_set))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tbreak\n        \t\telse:\n        \t\t\tre_set.append(candidates[i])\n        \t\t\tself.backtracking(re_set, candidates[i+1:], target - candidates[i])\n        \t\t\tre_set.pop()\n\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n       \tre_set = []\n       \tcandidates.sort()\n\n        self.backtracking(re_set, candidates, target)\n        \n        return self.result\n```","source":"_posts/leetcode-CombinationSumII.md","raw":"---\ntitle: LeetCode_Combination Sum II\ndate: 2018-12-25 18:22:35\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n---\n\n# [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used **once** in the combination.\n（从集合中挑选和为特定值的数字组合，同一元素只可选一次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_40.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法\n\n这道题与上一题的区别在于：\n1. 这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。\n2. candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。\n\n```python\nclass Solution:\n    def backtracking(self, re_set, candidates, target):\n        if target == 0 and list(re_set) not in self.result: \n        \tself.result.append(list(re_set))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tbreak\n        \t\telse:\n        \t\t\tre_set.append(candidates[i])\n        \t\t\tself.backtracking(re_set, candidates[i+1:], target - candidates[i])\n        \t\t\tre_set.pop()\n\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n       \tre_set = []\n       \tcandidates.sort()\n\n        self.backtracking(re_set, candidates, target)\n        \n        return self.result\n```","slug":"leetcode-CombinationSumII","published":1,"updated":"2018-12-25T10:43:17.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqkljhbd0092c3zmiifvier2","content":"<h1 id=\"Combination-Sum-II\"><a href=\"#Combination-Sum-II\" class=\"headerlink\" title=\"Combination Sum II\"></a><a href=\"https://leetcode.com/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener\">Combination Sum II</a></h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used <strong>once</strong> in the combination.<br>（从集合中挑选和为特定值的数字组合，同一元素只可选一次）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_40.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>这道题与上一题的区别在于：</p>\n<ol>\n<li>这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。</li>\n<li>candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re_set, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span> <span class=\"keyword\">and</span> list(re_set) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.result: </span><br><span class=\"line\">        \tself.result.append(list(re_set))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">        \t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t\t\tre_set.append(candidates[i])</span><br><span class=\"line\">        \t\t\tself.backtracking(re_set, candidates[i+<span class=\"number\">1</span>:], target - candidates[i])</span><br><span class=\"line\">        \t\t\tre_set.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum2</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">       \tre_set = []</span><br><span class=\"line\">       \tcandidates.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        self.backtracking(re_set, candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Combination-Sum-II\"><a href=\"#Combination-Sum-II\" class=\"headerlink\" title=\"Combination Sum II\"></a><a href=\"https://leetcode.com/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener\">Combination Sum II</a></h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used <strong>once</strong> in the combination.<br>（从集合中挑选和为特定值的数字组合，同一元素只可选一次）</p>","more":"<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_40.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>这道题与上一题的区别在于：</p>\n<ol>\n<li>这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。</li>\n<li>candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re_set, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span> <span class=\"keyword\">and</span> list(re_set) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.result: </span><br><span class=\"line\">        \tself.result.append(list(re_set))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">        \t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t\t\tre_set.append(candidates[i])</span><br><span class=\"line\">        \t\t\tself.backtracking(re_set, candidates[i+<span class=\"number\">1</span>:], target - candidates[i])</span><br><span class=\"line\">        \t\t\tre_set.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum2</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">       \tre_set = []</span><br><span class=\"line\">       \tcandidates.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        self.backtracking(re_set, candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjqkljh6c0001c3zm6b9fmc1x","category_id":"cjqkljh6o0005c3zmklcywnmd","_id":"cjqkljh73000ec3zm9jwfsdpf"},{"post_id":"cjqkljh71000cc3zmrxl3ae0e","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh78000kc3zmphubug7f"},{"post_id":"cjqkljh6i0003c3zma2honljq","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7c000pc3zmsgzvginb"},{"post_id":"cjqkljh72000dc3zm7e546yi1","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7e000rc3zmuuwzxxy3"},{"post_id":"cjqkljh74000hc3zm1bl1aiko","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7h000vc3zmbe477svc"},{"post_id":"cjqkljh6r0007c3zmh02uewyo","category_id":"cjqkljh74000fc3zm0yukcp0z","_id":"cjqkljh7i000xc3zmid2bs3pb"},{"post_id":"cjqkljh77000jc3zm26gz3ol7","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7k000zc3zmcfx0ysmg"},{"post_id":"cjqkljh7b000oc3zmdi4mlc46","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7m0013c3zmfr43u3zn"},{"post_id":"cjqkljh6v0008c3zmu5eguc2r","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7n0016c3zm9gojxqqx"},{"post_id":"cjqkljh7d000qc3zmn63au84b","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7p001ac3zmngsovhgi"},{"post_id":"cjqkljh7g000uc3zmcekrenvk","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7r001dc3zmqwyd3whk"},{"post_id":"cjqkljh6z0009c3zmekqhvlku","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7u001gc3zm5gglj2j8"},{"post_id":"cjqkljh7h000wc3zmy54sxpcm","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7x001ic3zm17aun957"},{"post_id":"cjqkljh7j000yc3zmjqzf6svv","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7y001lc3zmjjbhmifi"},{"post_id":"cjqkljh7l0012c3zm7k3ejr0v","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh7z001nc3zmut2d7xvl"},{"post_id":"cjqkljh7n0015c3zmu41a24ud","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh82001qc3zm5cxr16j3"},{"post_id":"cjqkljh7o0019c3zmohxwan20","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh84001tc3zm03z4h8k9"},{"post_id":"cjqkljh7q001cc3zmd3436ac2","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh86001xc3zmg6ume5df"},{"post_id":"cjqkljh7t001fc3zm7cnxcosi","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh880020c3zmv9y0ifcn"},{"post_id":"cjqkljh7v001hc3zmo55xdy00","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8c0024c3zmmfsy5z7y"},{"post_id":"cjqkljh7x001kc3zm16id2nwh","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8e0027c3zmj8xupqdf"},{"post_id":"cjqkljh7y001mc3zmn0jycm9c","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8j0029c3zm47c67obk"},{"post_id":"cjqkljh80001pc3zmduj943i5","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8k002dc3zm6qixdq07"},{"post_id":"cjqkljh83001sc3zm181cvidw","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8n002gc3zm0zigd151"},{"post_id":"cjqkljh84001wc3zm96wc77qf","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8p002kc3zmhsnixnpm"},{"post_id":"cjqkljh87001zc3zmtkw2y8vr","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8q002mc3zmue78ft5p"},{"post_id":"cjqkljh8a0023c3zm8ncrbsyr","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8s002pc3zmjw6osgue"},{"post_id":"cjqkljh8d0026c3zm7d9rdd0d","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8t002rc3zmcjnq8gcc"},{"post_id":"cjqkljh8f0028c3zmobee82r8","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8u002vc3zm7pwqteux"},{"post_id":"cjqkljh8k002cc3zmzeh5ahib","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8v002yc3zmnb9wl6ma"},{"post_id":"cjqkljh8m002fc3zmikqfs4as","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8x0032c3zm204jupff"},{"post_id":"cjqkljh8o002jc3zmpzlwiitg","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh8z0035c3zmvkg0w4g4"},{"post_id":"cjqkljh8p002lc3zme6svzu74","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh900039c3zmgspqwmgu"},{"post_id":"cjqkljh8r002oc3zmhz6gwadm","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh92003cc3zmblw16ec0"},{"post_id":"cjqkljh8s002qc3zmzqibkj43","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh93003fc3zme8zn6oyh"},{"post_id":"cjqkljh8u002uc3zmzpedg9h8","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh95003ic3zmsrcaz6ai"},{"post_id":"cjqkljh8v002xc3zmeuljeifn","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh99003mc3zml6tblxjn"},{"post_id":"cjqkljh8w0031c3zmw7wsfjdn","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9c003pc3zm2vy218gm"},{"post_id":"cjqkljh8y0034c3zmsl9fqhe3","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9d003sc3zmku1h3jr5"},{"post_id":"cjqkljh8z0038c3zmjpt71tl9","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9j003uc3zm5uvxgnlq"},{"post_id":"cjqkljh90003bc3zm2fgio1ri","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9k003wc3zmjxozb15a"},{"post_id":"cjqkljh93003ec3zmcjpqo2gr","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9l003yc3zm52v28s2e"},{"post_id":"cjqkljh96003lc3zm70bel61s","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9m0041c3zmccbrywvn"},{"post_id":"cjqkljh9a003oc3zm4ugiwi1d","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9m0043c3zm0cj1zi8i"},{"post_id":"cjqkljh9c003rc3zmm6ku6aka","category_id":"cjqkljh6o0005c3zmklcywnmd","_id":"cjqkljh9n0046c3zmutuny2e2"},{"post_id":"cjqkljh9e003tc3zmu52ufjs1","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljh9n0048c3zm1e6480b4"},{"post_id":"cjqkljhbd0092c3zmiifvier2","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqkljhbg0095c3zmmvtsp8rx"},{"post_id":"cjqkljh94003hc3zmvu19ndym","category_id":"cjqkljh70000ac3zml9ymvcs8","_id":"cjqnmfi680001f8zmvihf8c0v"}],"PostTag":[{"post_id":"cjqkljh6c0001c3zm6b9fmc1x","tag_id":"cjqkljh6r0006c3zm740n1y2h","_id":"cjqkljh76000ic3zm0xpjag3c"},{"post_id":"cjqkljh6c0001c3zm6b9fmc1x","tag_id":"cjqkljh70000bc3zmjkogsnds","_id":"cjqkljh78000lc3zml3ipwyiz"},{"post_id":"cjqkljh6i0003c3zma2honljq","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh7k0011c3zmfwnmn2yh"},{"post_id":"cjqkljh6i0003c3zma2honljq","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh7m0014c3zmou6goozg"},{"post_id":"cjqkljh6i0003c3zma2honljq","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljh7o0018c3zm3zr718mk"},{"post_id":"cjqkljh6r0007c3zmh02uewyo","tag_id":"cjqkljh7k0010c3zmjeo3m0lc","_id":"cjqkljh7p001bc3zmn3uc6ppl"},{"post_id":"cjqkljh6v0008c3zmu5eguc2r","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh82001rc3zmi66o8w64"},{"post_id":"cjqkljh6v0008c3zmu5eguc2r","tag_id":"cjqkljh7r001ec3zmiqdxjl8o","_id":"cjqkljh84001uc3zmuq729jiw"},{"post_id":"cjqkljh6v0008c3zmu5eguc2r","tag_id":"cjqkljh7x001jc3zm1c2nd1am","_id":"cjqkljh87001yc3zmc6p6v71t"},{"post_id":"cjqkljh80001pc3zmduj943i5","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh890021c3zmh4q45ggg"},{"post_id":"cjqkljh80001pc3zmduj943i5","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh8d0025c3zmy9raj7gr"},{"post_id":"cjqkljh6z0009c3zmekqhvlku","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh8k002bc3zmr2u319ku"},{"post_id":"cjqkljh6z0009c3zmekqhvlku","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh8m002ec3zmf42gpo0g"},{"post_id":"cjqkljh6z0009c3zmekqhvlku","tag_id":"cjqkljh890022c3zmrwdzawyl","_id":"cjqkljh8o002ic3zmf2stuccr"},{"post_id":"cjqkljh71000cc3zmrxl3ae0e","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh8u002tc3zm8xjk8gme"},{"post_id":"cjqkljh71000cc3zmrxl3ae0e","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh8v002wc3zmv0l2nfs3"},{"post_id":"cjqkljh71000cc3zmrxl3ae0e","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljh8w0030c3zm8o53k3s0"},{"post_id":"cjqkljh8u002uc3zmzpedg9h8","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh8y0033c3zm8pkd4g9j"},{"post_id":"cjqkljh8u002uc3zmzpedg9h8","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh8z0037c3zm3u145xlm"},{"post_id":"cjqkljh8u002uc3zmzpedg9h8","tag_id":"cjqkljh7r001ec3zmiqdxjl8o","_id":"cjqkljh90003ac3zmu24y7uw6"},{"post_id":"cjqkljh72000dc3zm7e546yi1","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh93003gc3zmtkcvj08g"},{"post_id":"cjqkljh72000dc3zm7e546yi1","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh95003jc3zmxb1vfpqa"},{"post_id":"cjqkljh72000dc3zm7e546yi1","tag_id":"cjqkljh8z0036c3zm9ceikten","_id":"cjqkljh99003nc3zm28tz4mdo"},{"post_id":"cjqkljh74000hc3zm1bl1aiko","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9k003xc3zm34vta1wt"},{"post_id":"cjqkljh74000hc3zm1bl1aiko","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh9l003zc3zmvozxnkv2"},{"post_id":"cjqkljh74000hc3zm1bl1aiko","tag_id":"cjqkljh7x001jc3zm1c2nd1am","_id":"cjqkljh9m0042c3zm6gf5n3oz"},{"post_id":"cjqkljh74000hc3zm1bl1aiko","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljh9n0044c3zmfq5qz11o"},{"post_id":"cjqkljh77000jc3zm26gz3ol7","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9n0047c3zmxnrgb8tr"},{"post_id":"cjqkljh77000jc3zm26gz3ol7","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljh9n0049c3zmlunjn8tr"},{"post_id":"cjqkljh77000jc3zm26gz3ol7","tag_id":"cjqkljh7r001ec3zmiqdxjl8o","_id":"cjqkljh9o004bc3zm3ofshvbf"},{"post_id":"cjqkljh7b000oc3zmdi4mlc46","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9p004cc3zmwkfel41z"},{"post_id":"cjqkljh7b000oc3zmdi4mlc46","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh9p004ec3zm3nmy87i7"},{"post_id":"cjqkljh7b000oc3zmdi4mlc46","tag_id":"cjqkljh7r001ec3zmiqdxjl8o","_id":"cjqkljh9p004fc3zmnynf4k82"},{"post_id":"cjqkljh7d000qc3zmn63au84b","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljh9q004hc3zm6h4gop9n"},{"post_id":"cjqkljh7d000qc3zmn63au84b","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljh9q004ic3zmh7mwna59"},{"post_id":"cjqkljh7g000uc3zmcekrenvk","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljh9s004lc3zm407bbrdb"},{"post_id":"cjqkljh7g000uc3zmcekrenvk","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9s004mc3zmxb3b9zhi"},{"post_id":"cjqkljh7g000uc3zmcekrenvk","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljh9t004oc3zmzvw6pqy6"},{"post_id":"cjqkljh7h000wc3zmy54sxpcm","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9t004qc3zmeaukhku7"},{"post_id":"cjqkljh7h000wc3zmy54sxpcm","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9t004rc3zmz1m2hny9"},{"post_id":"cjqkljh7h000wc3zmy54sxpcm","tag_id":"cjqkljh9s004nc3zmrhwjnubd","_id":"cjqkljh9t004tc3zmbq01duai"},{"post_id":"cjqkljh7j000yc3zmjqzf6svv","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9u004vc3zm3odaxk8o"},{"post_id":"cjqkljh7j000yc3zmjqzf6svv","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9u004wc3zm18utuy1f"},{"post_id":"cjqkljh7j000yc3zmjqzf6svv","tag_id":"cjqkljh9s004nc3zmrhwjnubd","_id":"cjqkljh9u004yc3zmwhn5xt39"},{"post_id":"cjqkljh7l0012c3zm7k3ejr0v","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9w0050c3zm93hf9xil"},{"post_id":"cjqkljh7l0012c3zm7k3ejr0v","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljh9w0051c3zm93zw54du"},{"post_id":"cjqkljh7l0012c3zm7k3ejr0v","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9x0053c3zm247asuu3"},{"post_id":"cjqkljh7n0015c3zmu41a24ud","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljh9x0055c3zm165xhqze"},{"post_id":"cjqkljh7n0015c3zmu41a24ud","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9x0056c3zm6xq97p00"},{"post_id":"cjqkljh7o0019c3zmohxwan20","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9y005ac3zmv26ttnqa"},{"post_id":"cjqkljh7o0019c3zmohxwan20","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9y005bc3zmsralh7aq"},{"post_id":"cjqkljh7o0019c3zmohxwan20","tag_id":"cjqkljh7x001jc3zm1c2nd1am","_id":"cjqkljh9y005dc3zmngq06jsl"},{"post_id":"cjqkljh7o0019c3zmohxwan20","tag_id":"cjqkljh9x0058c3zmqxwzf4uw","_id":"cjqkljh9y005ec3zmchadoqo8"},{"post_id":"cjqkljh7q001cc3zmd3436ac2","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljh9y005gc3zm3slnrfmj"},{"post_id":"cjqkljh7q001cc3zmd3436ac2","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9y005hc3zmsefz5uob"},{"post_id":"cjqkljh7q001cc3zmd3436ac2","tag_id":"cjqkljh9x0058c3zmqxwzf4uw","_id":"cjqkljh9z005jc3zmwbd4t722"},{"post_id":"cjqkljh7t001fc3zm7cnxcosi","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljh9z005mc3zm7ee198kd"},{"post_id":"cjqkljh7t001fc3zm7cnxcosi","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljh9z005nc3zmxu73m662"},{"post_id":"cjqkljh7t001fc3zm7cnxcosi","tag_id":"cjqkljh9x0058c3zmqxwzf4uw","_id":"cjqkljh9z005pc3zmplz8yyj1"},{"post_id":"cjqkljh7v001hc3zmo55xdy00","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljha0005rc3zmxxuxde40"},{"post_id":"cjqkljh7v001hc3zmo55xdy00","tag_id":"cjqkljh9z005oc3zmuz6vl9gt","_id":"cjqkljha0005sc3zmnp5sbcs0"},{"post_id":"cjqkljh7x001kc3zm16id2nwh","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljha1005xc3zm77k3wwz2"},{"post_id":"cjqkljh7x001kc3zm16id2nwh","tag_id":"cjqkljh9z005oc3zmuz6vl9gt","_id":"cjqkljha1005yc3zmpn9o9r3a"},{"post_id":"cjqkljh7x001kc3zm16id2nwh","tag_id":"cjqkljha0005uc3zmis2382xs","_id":"cjqkljha10060c3zmw4v9qdvz"},{"post_id":"cjqkljh7x001kc3zm16id2nwh","tag_id":"cjqkljha0005vc3zm9qb0p3z5","_id":"cjqkljha10061c3zmj5u633u1"},{"post_id":"cjqkljh7y001mc3zmn0jycm9c","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljha10063c3zmh815yk1q"},{"post_id":"cjqkljh7y001mc3zmn0jycm9c","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljha10064c3zmzcn5ta02"},{"post_id":"cjqkljh7y001mc3zmn0jycm9c","tag_id":"cjqkljh7r001ec3zmiqdxjl8o","_id":"cjqkljha20066c3zmgmp4xw1c"},{"post_id":"cjqkljh7y001mc3zmn0jycm9c","tag_id":"cjqkljha0005vc3zm9qb0p3z5","_id":"cjqkljha20067c3zma26aaezu"},{"post_id":"cjqkljh83001sc3zm181cvidw","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljha20069c3zmk0a57xjf"},{"post_id":"cjqkljh83001sc3zm181cvidw","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljha2006ac3zmwgfny1bo"},{"post_id":"cjqkljh84001wc3zm96wc77qf","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljha3006dc3zm5tpznfxs"},{"post_id":"cjqkljh84001wc3zm96wc77qf","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljha3006ec3zmt3mygo6w"},{"post_id":"cjqkljh84001wc3zm96wc77qf","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljha3006gc3zmqm1labwn"},{"post_id":"cjqkljh87001zc3zmtkw2y8vr","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljha4006kc3zmresqibwz"},{"post_id":"cjqkljh87001zc3zmtkw2y8vr","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljha5006lc3zmq9glpvih"},{"post_id":"cjqkljh87001zc3zmtkw2y8vr","tag_id":"cjqkljh9x0058c3zmqxwzf4uw","_id":"cjqkljha6006nc3zm1f2egbz2"},{"post_id":"cjqkljh87001zc3zmtkw2y8vr","tag_id":"cjqkljh9s004nc3zmrhwjnubd","_id":"cjqkljha6006oc3zm10yjh8ck"},{"post_id":"cjqkljh8a0023c3zm8ncrbsyr","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljha6006qc3zmkipn4ic6"},{"post_id":"cjqkljh8a0023c3zm8ncrbsyr","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljha6006rc3zm3d5t3bza"},{"post_id":"cjqkljh8a0023c3zm8ncrbsyr","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljha6006tc3zmcrgplhes"},{"post_id":"cjqkljh8d0026c3zm7d9rdd0d","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljha6006uc3zmkz0inivx"},{"post_id":"cjqkljh8d0026c3zm7d9rdd0d","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljha7006wc3zmmfdxws7b"},{"post_id":"cjqkljh8d0026c3zm7d9rdd0d","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljha7006xc3zmxwsxiuma"},{"post_id":"cjqkljh8f0028c3zmobee82r8","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljha7006zc3zmy8moulfj"},{"post_id":"cjqkljh8f0028c3zmobee82r8","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljha70070c3zma9sagl5h"},{"post_id":"cjqkljh8k002cc3zmzeh5ahib","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljha70072c3zmb2x4ff76"},{"post_id":"cjqkljh8k002cc3zmzeh5ahib","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljha80073c3zmhi276cye"},{"post_id":"cjqkljh8m002fc3zmikqfs4as","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljha80076c3zmjx3ckgn6"},{"post_id":"cjqkljh8m002fc3zmikqfs4as","tag_id":"cjqkljh9z005oc3zmuz6vl9gt","_id":"cjqkljha80077c3zm4gws70af"},{"post_id":"cjqkljh8o002jc3zmpzlwiitg","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljha80079c3zmi3b9xmlx"},{"post_id":"cjqkljh8o002jc3zmpzlwiitg","tag_id":"cjqkljh9z005oc3zmuz6vl9gt","_id":"cjqkljha9007ac3zmy7vbhgpx"},{"post_id":"cjqkljh8o002jc3zmpzlwiitg","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljha9007cc3zm9nkrcbaf"},{"post_id":"cjqkljh8p002lc3zme6svzu74","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljhab007fc3zmb36mptcd"},{"post_id":"cjqkljh8p002lc3zme6svzu74","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljhab007gc3zmxdd5itog"},{"post_id":"cjqkljh8p002lc3zme6svzu74","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljhad007ic3zmjxt2cwr7"},{"post_id":"cjqkljh8r002oc3zmhz6gwadm","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljhad007jc3zmn9vnetg7"},{"post_id":"cjqkljh8r002oc3zmhz6gwadm","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljhae007lc3zmq5v54fup"},{"post_id":"cjqkljh8r002oc3zmhz6gwadm","tag_id":"cjqkljh7r001ec3zmiqdxjl8o","_id":"cjqkljhae007mc3zmcsgi069n"},{"post_id":"cjqkljh8s002qc3zmzqibkj43","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljhah007pc3zmoy6t0qa7"},{"post_id":"cjqkljh8s002qc3zmzqibkj43","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljhah007qc3zmkyumtdhq"},{"post_id":"cjqkljh8s002qc3zmzqibkj43","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljhai007sc3zm1s772v70"},{"post_id":"cjqkljh8s002qc3zmzqibkj43","tag_id":"cjqkljhae007nc3zmvmkrhz63","_id":"cjqkljhai007tc3zm1vjer6k1"},{"post_id":"cjqkljh8v002xc3zmeuljeifn","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljhaj007vc3zmwmlqwwcc"},{"post_id":"cjqkljh8v002xc3zmeuljeifn","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljhaj007wc3zm6da7k7nk"},{"post_id":"cjqkljh8v002xc3zmeuljeifn","tag_id":"cjqkljh7x001jc3zm1c2nd1am","_id":"cjqkljhak007yc3zmjnhxrnma"},{"post_id":"cjqkljh8v002xc3zmeuljeifn","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljhak007zc3zm39pf9cof"},{"post_id":"cjqkljh8w0031c3zmw7wsfjdn","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljhak0082c3zmhdopmiwm"},{"post_id":"cjqkljh8w0031c3zmw7wsfjdn","tag_id":"cjqkljhaj007xc3zmrqoscn7y","_id":"cjqkljhak0083c3zmk8s5zws6"},{"post_id":"cjqkljh8w0031c3zmw7wsfjdn","tag_id":"cjqkljh8z0036c3zm9ceikten","_id":"cjqkljhal0085c3zm8u7hkqn7"},{"post_id":"cjqkljh8y0034c3zmsl9fqhe3","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljhal0088c3zmf5o87d0c"},{"post_id":"cjqkljh8y0034c3zmsl9fqhe3","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljhal0089c3zmczo9ti5i"},{"post_id":"cjqkljh8y0034c3zmsl9fqhe3","tag_id":"cjqkljhal0086c3zm8ave3qlk","_id":"cjqkljham008bc3zm9nds309c"},{"post_id":"cjqkljh8z0038c3zmjpt71tl9","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljham008cc3zmdpnlxuy9"},{"post_id":"cjqkljh8z0038c3zmjpt71tl9","tag_id":"cjqkljh9z005oc3zmuz6vl9gt","_id":"cjqkljham008ec3zm1obr6548"},{"post_id":"cjqkljh90003bc3zm2fgio1ri","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljham008fc3zmwuzfo8fm"},{"post_id":"cjqkljh90003bc3zm2fgio1ri","tag_id":"cjqkljhaj007xc3zmrqoscn7y","_id":"cjqkljham008hc3zm45vs03km"},{"post_id":"cjqkljh93003ec3zmcjpqo2gr","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqkljhan008jc3zmfax8wd2s"},{"post_id":"cjqkljh93003ec3zmcjpqo2gr","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljhan008kc3zmmytlyb8j"},{"post_id":"cjqkljh93003ec3zmcjpqo2gr","tag_id":"cjqkljh7g000tc3zm8v8tofss","_id":"cjqkljhan008mc3zmdirxisr7"},{"post_id":"cjqkljh93003ec3zmcjpqo2gr","tag_id":"cjqkljhal0086c3zm8ave3qlk","_id":"cjqkljhan008nc3zmzfut06zs"},{"post_id":"cjqkljh96003lc3zm70bel61s","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljhan008pc3zmuwkxco32"},{"post_id":"cjqkljh96003lc3zm70bel61s","tag_id":"cjqkljh9z005oc3zmuz6vl9gt","_id":"cjqkljhan008qc3zmiij6vl7k"},{"post_id":"cjqkljh96003lc3zm70bel61s","tag_id":"cjqkljh9j003vc3zm96c4xwpy","_id":"cjqkljhao008sc3zmrojpnvbr"},{"post_id":"cjqkljh9a003oc3zm4ugiwi1d","tag_id":"cjqkljh9p004dc3zm2mhqcne8","_id":"cjqkljhao008tc3zm9gqh1imk"},{"post_id":"cjqkljh9a003oc3zm4ugiwi1d","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljhao008vc3zmks3emdzp"},{"post_id":"cjqkljh9a003oc3zm4ugiwi1d","tag_id":"cjqkljh7x001jc3zm1c2nd1am","_id":"cjqkljhao008wc3zm2j3nvxwf"},{"post_id":"cjqkljh9c003rc3zmm6ku6aka","tag_id":"cjqkljh6r0006c3zm740n1y2h","_id":"cjqkljhap008xc3zmp8bswp37"},{"post_id":"cjqkljh9c003rc3zmm6ku6aka","tag_id":"cjqkljh70000bc3zmjkogsnds","_id":"cjqkljhap008yc3zm7z2ufmki"},{"post_id":"cjqkljh9c003rc3zmm6ku6aka","tag_id":"cjqkljhan008rc3zm4vq0ayb9","_id":"cjqkljhap008zc3zmvsestlyl"},{"post_id":"cjqkljh9e003tc3zmu52ufjs1","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljhap0090c3zm81s7naks"},{"post_id":"cjqkljh9e003tc3zmu52ufjs1","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqkljhap0091c3zm4vjrr7ry"},{"post_id":"cjqkljhbd0092c3zmiifvier2","tag_id":"cjqkljh74000gc3zmgq48ms85","_id":"cjqkljhbg0093c3zmk2d0pmfj"},{"post_id":"cjqkljhbd0092c3zmiifvier2","tag_id":"cjqkljh78000nc3zmzmpvrw1y","_id":"cjqkljhbg0094c3zmjb6yh354"},{"post_id":"cjqkljhbd0092c3zmiifvier2","tag_id":"cjqkljh8z0036c3zm9ceikten","_id":"cjqkljhbg0096c3zmdq45gbs9"},{"post_id":"cjqkljh94003hc3zmvu19ndym","tag_id":"cjqkljh9n004ac3zm4qa02ter","_id":"cjqnmfi6g0002f8zmb0bcew8m"},{"post_id":"cjqkljh94003hc3zmvu19ndym","tag_id":"cjqkljh9q004gc3zmzemyzssu","_id":"cjqnmfi6g0003f8zmi2c853mm"},{"post_id":"cjqkljh94003hc3zmvu19ndym","tag_id":"cjqkljh9x0058c3zmqxwzf4uw","_id":"cjqnmfi6g0004f8zmv72qwgao"},{"post_id":"cjqkljh94003hc3zmvu19ndym","tag_id":"cjqkljh8z0036c3zm9ceikten","_id":"cjqnmfi6g0005f8zmczahksrm"},{"post_id":"cjqkljh94003hc3zmvu19ndym","tag_id":"cjqnmfi5p0000f8zmd6o8ld2h","_id":"cjqnmfi6g0006f8zm869jqxfw"}],"Tag":[{"name":"intent","_id":"cjqkljh6r0006c3zm740n1y2h"},{"name":"slot","_id":"cjqkljh70000bc3zmjkogsnds"},{"name":"medium","_id":"cjqkljh74000gc3zmgq48ms85"},{"name":"array","_id":"cjqkljh78000nc3zmzmpvrw1y"},{"name":"two pointers","_id":"cjqkljh7g000tc3zm8v8tofss"},{"name":"tools","_id":"cjqkljh7k0010c3zmjeo3m0lc"},{"name":"binary search","_id":"cjqkljh7r001ec3zmiqdxjl8o"},{"name":"hash table","_id":"cjqkljh7x001jc3zm1c2nd1am"},{"name":"pointer","_id":"cjqkljh890022c3zmrwdzawyl"},{"name":"back tracking","_id":"cjqkljh8z0036c3zm9ceikten"},{"name":"math","_id":"cjqkljh9j003vc3zm96c4xwpy"},{"name":"hard","_id":"cjqkljh9n004ac3zm4qa02ter"},{"name":"easy","_id":"cjqkljh9p004dc3zm2mhqcne8"},{"name":"string","_id":"cjqkljh9q004gc3zmzemyzssu"},{"name":"backtracking","_id":"cjqkljh9s004nc3zmrhwjnubd"},{"name":"dynamic programming","_id":"cjqkljh9x0058c3zmqxwzf4uw"},{"name":"linked list","_id":"cjqkljh9z005oc3zmuz6vl9gt"},{"name":"heap","_id":"cjqkljha0005uc3zmis2382xs"},{"name":"divide and conquer","_id":"cjqkljha0005vc3zm9qb0p3z5"},{"name":"regular expression","_id":"cjqkljhae007nc3zmvmkrhz63"},{"name":"hashed table","_id":"cjqkljhaj007xc3zmrqoscn7y"},{"name":"stack","_id":"cjqkljhal0086c3zm8ave3qlk"},{"name":"task-oriented","_id":"cjqkljhan008rc3zm4vq0ayb9"},{"name":"greedy","_id":"cjqnmfi5p0000f8zmd6o8ld2h"}]}}