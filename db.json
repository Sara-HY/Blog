{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/diag_statistics2.png","path":"images/diag_statistics2.png","modified":1,"renderable":0},{"_id":"source/images/intent_input.png","path":"images/intent_input.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_1.png","path":"images/leetcode_1.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_101.png","path":"images/leetcode_101.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_102.png","path":"images/leetcode_102.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_103.png","path":"images/leetcode_103.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_104.png","path":"images/leetcode_104.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_105.png","path":"images/leetcode_105.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_106.png","path":"images/leetcode_106.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_107.png","path":"images/leetcode_107.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_108.png","path":"images/leetcode_108.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_109.png","path":"images/leetcode_109.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_111.png","path":"images/leetcode_111.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_112.png","path":"images/leetcode_112.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_113.png","path":"images/leetcode_113.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_114.png","path":"images/leetcode_114.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_14.png","path":"images/leetcode_14.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_16.png","path":"images/leetcode_16.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_18.png","path":"images/leetcode_18.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_2.png","path":"images/leetcode_2.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_21.png","path":"images/leetcode_21.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_22.png","path":"images/leetcode_22.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_23.png","path":"images/leetcode_23.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_24.png","path":"images/leetcode_24.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_25.png","path":"images/leetcode_25.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_28.png","path":"images/leetcode_28.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_29.png","path":"images/leetcode_29.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_31.png","path":"images/leetcode_31.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_32.png","path":"images/leetcode_32.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_33.png","path":"images/leetcode_33.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_34.png","path":"images/leetcode_34.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_36_1.png","path":"images/leetcode_36_1.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_4.png","path":"images/leetcode_4.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_41.png","path":"images/leetcode_41.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_43.png","path":"images/leetcode_43.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_45.png","path":"images/leetcode_45.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_454.png","path":"images/leetcode_454.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_46.png","path":"images/leetcode_46.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_47.png","path":"images/leetcode_47.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_49.png","path":"images/leetcode_49.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_5.png","path":"images/leetcode_5.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_51.png","path":"images/leetcode_51.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_15.png","path":"images/leetcode_15.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_19.png","path":"images/leetcode_19.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_52.png","path":"images/leetcode_52.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_53.png","path":"images/leetcode_53.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_58.png","path":"images/leetcode_58.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_6.png","path":"images/leetcode_6.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_59.png","path":"images/leetcode_59.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_60.png","path":"images/leetcode_60.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_64.png","path":"images/leetcode_64.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_67.png","path":"images/leetcode_67.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_66.png","path":"images/leetcode_66.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_69.png","path":"images/leetcode_69.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_7.png","path":"images/leetcode_7.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_75.png","path":"images/leetcode_75.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_76.png","path":"images/leetcode_76.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_78.png","path":"images/leetcode_78.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_79.png","path":"images/leetcode_79.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_82.png","path":"images/leetcode_82.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_81.png","path":"images/leetcode_81.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_83.png","path":"images/leetcode_83.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_77.png","path":"images/leetcode_77.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_88.png","path":"images/leetcode_88.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_85.png","path":"images/leetcode_85.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_86.png","path":"images/leetcode_86.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_92.png","path":"images/leetcode_92.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_90.png","path":"images/leetcode_90.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_93.png","path":"images/leetcode_93.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_97.png","path":"images/leetcode_97.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_96.png","path":"images/leetcode_96.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_94.png","path":"images/leetcode_94.png","modified":1,"renderable":0},{"_id":"source/images/diag_statistics.png","path":"images/diag_statistics.png","modified":1,"renderable":0},{"_id":"source/images/diag_kv_retrieval_result.png","path":"images/diag_kv_retrieval_result.png","modified":1,"renderable":0},{"_id":"source/images/intent_f1.png","path":"images/intent_f1.png","modified":1,"renderable":0},{"_id":"source/images/intent_frame.png","path":"images/intent_frame.png","modified":1,"renderable":0},{"_id":"source/images/intent_frame_baseline.png","path":"images/intent_frame_baseline.png","modified":1,"renderable":0},{"_id":"source/images/intent_frame_model.png","path":"images/intent_frame_model.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_100.png","path":"images/leetcode_100.png","modified":1,"renderable":0},{"_id":"source/images/intent_hlstm.png","path":"images/intent_hlstm.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_11.png","path":"images/leetcode_11.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_110.png","path":"images/leetcode_110.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_116.png","path":"images/leetcode_116.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_12.png","path":"images/leetcode_12.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_13.png","path":"images/leetcode_13.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_17.png","path":"images/leetcode_17.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_117.png","path":"images/leetcode_117.png","modified":1,"renderable":0},{"_id":"source/images/diag_example.png","path":"images/diag_example.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_27.png","path":"images/leetcode_27.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_3.png","path":"images/leetcode_3.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_30.png","path":"images/leetcode_30.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_26.png","path":"images/leetcode_26.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_35.png","path":"images/leetcode_35.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_39.png","path":"images/leetcode_39.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_40.png","path":"images/leetcode_40.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_42.png","path":"images/leetcode_42.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_48.png","path":"images/leetcode_48.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_50.png","path":"images/leetcode_50.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_51_1.png","path":"images/leetcode_51_1.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_20.png","path":"images/leetcode_20.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_54.png","path":"images/leetcode_54.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_57.png","path":"images/leetcode_57.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_56.png","path":"images/leetcode_56.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_55.png","path":"images/leetcode_55.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_62.png","path":"images/leetcode_62.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_61.png","path":"images/leetcode_61.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_63.png","path":"images/leetcode_63.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_65.png","path":"images/leetcode_65.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_70.png","path":"images/leetcode_70.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_73.png","path":"images/leetcode_73.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_72.png","path":"images/leetcode_72.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_74.png","path":"images/leetcode_74.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_84.png","path":"images/leetcode_84.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_80.png","path":"images/leetcode_80.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_91.png","path":"images/leetcode_91.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_9.png","path":"images/leetcode_9.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_95.png","path":"images/leetcode_95.png","modified":1,"renderable":0},{"_id":"source/images/mem2seq_result.png","path":"images/mem2seq_result.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_99.png","path":"images/leetcode_99.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_98.png","path":"images/leetcode_98.png","modified":1,"renderable":0},{"_id":"source/images/mem2seq.png","path":"images/mem2seq.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_37.png","path":"images/leetcode_37.png","modified":1,"renderable":0},{"_id":"source/images/intent_dstc_rnn.png","path":"images/intent_dstc_rnn.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_10.png","path":"images/leetcode_10.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_115.png","path":"images/leetcode_115.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_8.png","path":"images/leetcode_8.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_89.png","path":"images/leetcode_89.png","modified":1,"renderable":0},{"_id":"source/images/mem2seq_result2.png","path":"images/mem2seq_result2.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/images/leetcode_36.png","path":"images/leetcode_36.png","modified":1,"renderable":0},{"_id":"source/images/intent_results.png","path":"images/intent_results.png","modified":1,"renderable":0},{"_id":"source/images/diag_kv_retrieval.png","path":"images/diag_kv_retrieval.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_65_2.png","path":"images/leetcode_65_2.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"source/images/leetcode_87.png","path":"images/leetcode_87.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_68.png","path":"images/leetcode_68.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_71.png","path":"images/leetcode_71.png","modified":1,"renderable":0},{"_id":"source/images/leetcode_44.png","path":"images/leetcode_44.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/google10bb50e0b38f396b.html","hash":"1ee7a6da9197409280def29033e0a3a5629a7e32","modified":1543289020030},{"_id":"source/.DS_Store","hash":"84cd3e2bcbd281c91569d2c6fd51cf04804d6fab","modified":1551096633538},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1543289020047},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543289020048},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543289020048},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1543289020050},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1543289020048},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543289020050},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1543289020050},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543289020048},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1543289020050},{"_id":"themes/next/bower.json","hash":"23379fec9b4f70bc2611433ac3770445a8ca18d9","modified":1543289020051},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1543289020051},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1543289020057},{"_id":"themes/next/package.json","hash":"901c9bf4743df8f1806b5bcb5e93b54f6aee0ea3","modified":1543289020107},{"_id":"themes/next/_config.yml","hash":"530e1a0bdbda92d9e6d77e3a9827b72f6476bc41","modified":1543289020051},{"_id":"themes/next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1543289020050},{"_id":"source/_posts/intent_slot.md","hash":"aa762a757b8cc615b906ecd9bfe93a75afe1e128","modified":1543289020028},{"_id":"source/_posts/leetcode-3SumClosest.md","hash":"0ca084d0d387c9ef73ade1611e1faf25fe4415b4","modified":1543470793165},{"_id":"source/_posts/leetcode-3Sum.md","hash":"b84ed71f13a5bb2b9f79430af0a31b072148a93c","modified":1543464727782},{"_id":"source/_posts/leetcode-4Sum.md","hash":"1ee4b4efec4acbdbd27cf89d934bb915ca8ef414","modified":1544069716227},{"_id":"source/_posts/leetcode-4SumII.md","hash":"094852f278016ee86913fe8860ff0c0002234352","modified":1544078542218},{"_id":"source/_posts/leetcode-BinaryTreeInorderTraversal.md","hash":"31a5959a102f23655530e054285dbba63d1a44cf","modified":1551243320737},{"_id":"source/_posts/leetcode-BinaryTreeLevelOrderTraversal.md","hash":"30a44af971bd294198df948ca9eac6351f3ecf6c","modified":1551690524922},{"_id":"source/_posts/leetcode-BalancedBinaryTree.md","hash":"8c156ed8e3345bc99c9995ce725e392acf6bdd96","modified":1551706789551},{"_id":"source/_posts/leetcode-AddBinary.md","hash":"b7b8e3d8b865a9eb165d05234c05f2c14365d2ac","modified":1548338760770},{"_id":"source/_posts/leetcode-BinaryTreeZigzagLevelOrderTraversal.md","hash":"68a9c8890d78640578b8c798c2164ce9ea44a931","modified":1551690542033},{"_id":"source/_posts/leetcode-ClimbingStairs.md","hash":"2da46267c1451aa69354cc7a41bd60d75d5bee20","modified":1550320616710},{"_id":"source/_posts/leetcode-BinaryTreeLevelOrderTraversalII.md","hash":"2c0625c376d129fa94a9e082add9e077e7ff7d40","modified":1551696593483},{"_id":"source/_posts/leetcode-CombinationSum.md","hash":"e05764292d54728f274de06812efe68e5563865e","modified":1545733254807},{"_id":"source/_posts/leetcode-CombinationSumII.md","hash":"b8f759c7e3907dfd39028aa3360d8aa632280d34","modified":1545734597106},{"_id":"source/_posts/leetcode-ConstructBinaryTreefromInorderandPostorderTraversal.md","hash":"c3e80cb11978eeac9be7b079a4ae2ebeef5256af","modified":1551692432204},{"_id":"source/_posts/leetcode-Combinations.md","hash":"c5719b4290625c715c7561d81f2d69f7067c8d36","modified":1550903397855},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1543459329495},{"_id":"source/_posts/leetcode-ConstructBinaryTreefromPreorderandInorderTraversal.md","hash":"9239cc5d24051c3f16d9a7f64890949da4e6222e","modified":1551692332868},{"_id":"source/_posts/leetcode-ContainerWithMostWater.md","hash":"0bfa58fa4162bb38422156d9241b0b6b11eca22d","modified":1547130399331},{"_id":"source/_posts/leetcode-ConvertSortedArraytoBinarySearchTree.md","hash":"30f0b57908201a13c188ab5e90164baf765f026c","modified":1551705819371},{"_id":"source/_posts/leetcode-CountandSay.md","hash":"a07f7f560e5d734d2427480290edbcd4bdae1c78","modified":1548384510567},{"_id":"source/_posts/leetcode-ConvertSortedListtoBinarySearchTree.md","hash":"b1eb363f049bdde6d43cc453e67546af4545542a","modified":1551705340027},{"_id":"source/_posts/leetcode-DecodeWays.md","hash":"fb3d32cdd56f628d3993e48d61816b772007f81f","modified":1551186144268},{"_id":"source/_posts/leetcode-DistinctSubsequences.md","hash":"7c8686887ecfc610d418995a7c4bd961874779cc","modified":1551776429140},{"_id":"source/_posts/leetcode-DivideTwoIntegers.md","hash":"35f6383661b7ac3302da977b36c827d42093d9d0","modified":1545128429003},{"_id":"source/_posts/leetcode-EditDistance.md","hash":"d5d37f79fce9fa2e6ab346462e6cafef3d8ac7a0","modified":1550592978125},{"_id":"source/_posts/leetcode-FirstMissingPositive.md","hash":"66f50feaf33fcef6ee9fd7bf2003f42b9ca0a1ba","modified":1545741359009},{"_id":"source/_posts/leetcode-FindFirstandLastPositionofElementinSortedArray.md","hash":"172083c48ea4166226bcdcef0abda479636b415a","modified":1545373523753},{"_id":"source/_posts/leetcode-FlattenBinaryTreetoLinkedList.md","hash":"cba9e7826f84def0b9f685afe5cd67ef5af1d687","modified":1551771128681},{"_id":"source/_posts/leetcode-GrayCode.md","hash":"18e3211012c39d95da3ca0afa36e4aea73d4ee3d","modified":1551148489347},{"_id":"source/_posts/leetcode-GenerateParentheses.md","hash":"5fcac2741e4f00f5b3ed4fb07189d18b9bf44374","modified":1547027492053},{"_id":"source/_posts/leetcode-GroupAnagrams.md","hash":"67b50de5713a9f7f0e83ad1cce6f4950544ff9eb","modified":1547017246778},{"_id":"source/_posts/leetcode-InsertInterval.md","hash":"91039506db3a1f798b70b7f7d134e9cb093a6088","modified":1547276135777},{"_id":"source/_posts/leetcode-IntegertoRoman.md","hash":"2c785e1f2191e9ca6ae5f3e727a2a02c8fa38182","modified":1543459289125},{"_id":"source/_posts/leetcode-ImplementstrStr.md","hash":"adec66d4c5337fdd8130e35aba4e7f1b2ddca39d","modified":1545122460662},{"_id":"source/_posts/leetcode-InterleavingString.md","hash":"23aaf67c1f9cb62e59f5502ca540072117266c19","modified":1551272780373},{"_id":"source/_posts/leetcode-JumpGame.md","hash":"d07d119d4b9f9ff53f325ae716da7a2caef216bf","modified":1547127354852},{"_id":"source/_posts/leetcode-JumpGameII.md","hash":"db3f6247695359472d86bacbfa018376b5d8dbd0","modified":1547126254752},{"_id":"source/_posts/leetcode-LargestRectangleinHistogram.md","hash":"89a9437e109dda5488197a18171bd22fdbf68f4e","modified":1551073703413},{"_id":"source/_posts/leetcode-LetterCombinationsofaPhoneNumber.md","hash":"918f3b816a31ac993c75b6519e8048b79965f229","modified":1547027483765},{"_id":"source/_posts/leetcode-LongestCommonPrefix.md","hash":"34533adfbca8aa39d639da16821c6b4848c14e74","modified":1543462529152},{"_id":"source/_posts/leetcode-LengthofLastWord.md","hash":"78b0c98220cdc319d3ffbb449fd5832bc9b1d65d","modified":1547364646579},{"_id":"source/_posts/leetcode-LongestSubstringWithoutRepeatingCharacters.md","hash":"cce1b0e83efd163e78062eadd7042f9c58505d16","modified":1543299888995},{"_id":"source/_posts/leetcode-LongestPalindromicSubstring.md","hash":"b7eda1b9b1f801f39312dfbe5a75f1badaed96e8","modified":1543299880362},{"_id":"source/_posts/leetcode-MaximumDepthofBinaryTree.md","hash":"903fe46441ad5995d4ab49a323c6f453da3c7ff0","modified":1551690991124},{"_id":"source/_posts/leetcode-LongestValidParentheses.md","hash":"3b00a3388307764ef6d6b298041505a47b716057","modified":1545364862455},{"_id":"source/_posts/leetcode-MaximalRectangle.md","hash":"659e918ec2f3da86d48fed29b8d75f46ade17321","modified":1551076263946},{"_id":"source/_posts/leetcode-MedianofTwoSortedArrays.md","hash":"1c3d189d8feb376bbaecc409ed28ed8aa40f5c3b","modified":1543461817414},{"_id":"source/_posts/leetcode-MaximumSubarray.md","hash":"15ac05efc0fd14e2e59eabc5c90a100c37a764da","modified":1547090151182},{"_id":"source/_posts/leetcode-MergeIntervals.md","hash":"38e556940d92504650c7f2368d52445454da4401","modified":1547129764232},{"_id":"source/_posts/leetcode-MergeTwoSortedLists.md","hash":"f44e8a2f20eaabb82c3a906be25d9c6d80f40dc7","modified":1544086139665},{"_id":"source/_posts/leetcode-MergeSortedArray.md","hash":"d1bda8932192b19d8539450bb486819e63802f3b","modified":1551147729230},{"_id":"source/_posts/leetcode-MinimumDepthofBinaryTree.md","hash":"276bc36f7641c52ac7f3f59440ba61befc721bdc","modified":1551752092178},{"_id":"source/_posts/leetcode-MergekSortedLists.md","hash":"c48526c5a7f569af608ad9bbc862ced0fea24bcb","modified":1544541091880},{"_id":"source/_posts/leetcode-MinimumWindowSubstring.md","hash":"5a3f4c23174061e816dcbd151d94bc6d76d7e3cc","modified":1550901378031},{"_id":"source/_posts/leetcode-MinimumPathSum.md","hash":"71a31df207a2d679146337fe0fdb5bfb3ccddc1e","modified":1547533464041},{"_id":"source/_posts/leetcode-MultiplyStrings.md","hash":"c181c0e9be7d81605e3a4907c96dcea007ce9f75","modified":1546527756618},{"_id":"source/_posts/leetcode-N-Queens.md","hash":"2a35b97dd2cc8503f6a3010c580916722cde8449","modified":1547043165614},{"_id":"source/_posts/leetcode-NextPermutation.md","hash":"6012d1d653fd7fba92a120203216d1f2f166bc94","modified":1545360855745},{"_id":"source/_posts/leetcode-PalindromeNumber.md","hash":"5834456b1951699f75c82a5b7f27a665f867986c","modified":1543299898406},{"_id":"source/_posts/leetcode-PartitionList.md","hash":"647bfe2b712cdbd6162bfaab866ea65fb426f48c","modified":1551081610554},{"_id":"source/_posts/leetcode-N-QueensII.md","hash":"4af518fa3f2c77bfa9f608d7fe43837d01587523","modified":1547043667444},{"_id":"source/_posts/leetcode-PathSum.md","hash":"6a65c0c3a9fb9c888d4d173285f9305d43e42157","modified":1551752566137},{"_id":"source/_posts/leetcode-PathSumII.md","hash":"1b24af16657a5501b4b8eccde547e731cdfe95e5","modified":1551766456009},{"_id":"source/_posts/leetcode-Permutations.md","hash":"563e0992a973ad4d9dea2554dc2e40d5ec48d477","modified":1547462988905},{"_id":"source/_posts/leetcode-PermutationSequence.md","hash":"f28287bde856e997af2331b0490d1ccd8a1bf155","modified":1547399422710},{"_id":"source/_posts/leetcode-PermutationsII.md","hash":"10ae62d9d33ad6c341749b6185b7f2343b5441e6","modified":1547014032526},{"_id":"source/_posts/leetcode-PopulatingNextRightPointersinEachNode.md","hash":"c30848c08a74352ba741a533b92fed05d8ddfce3","modified":1551858493208},{"_id":"source/_posts/leetcode-PopulatingNextRightPointersinEachNodeII.md","hash":"542240f26f88874ffa2ab74dc5e9ac969f35914e","modified":1551857006830},{"_id":"source/_posts/leetcode-PlusOne.md","hash":"cb6c6f6bcb2daa843570fbf25835fefda2e4b008","modified":1548326877410},{"_id":"source/_posts/leetcode-Pow-x-n.md","hash":"a8aaad56d7701fb6ea775e9717de37881fe90014","modified":1547018688255},{"_id":"source/_posts/leetcode-RecoverBinarySearchTree.md","hash":"198831b794ab42abc71f8c44782964bca2de309d","modified":1551280081730},{"_id":"source/_posts/leetcode-RegularExpressionMatching.md","hash":"1aae06e1805fd970c015e3c606abb6fdc306c6df","modified":1547027470573},{"_id":"source/_posts/leetcode-RemoveDuplicatesfromSortedArray.md","hash":"bd2d74e3eb4ba126c12395b0c615afff192753af","modified":1545120803098},{"_id":"source/_posts/leetcode-RemoveDuplicatesfromSortedArrayII.md","hash":"a5ad76d9cd178645ebcf059b44b706fcf60a1cb0","modified":1550907920582},{"_id":"source/_posts/leetcode-RemoveDuplicatesfromSortedList.md","hash":"dbaa4884b716858d95fed184bfd4fa7557c82f49","modified":1550911684258},{"_id":"source/_posts/leetcode-RemoveDuplicatesfromSortedListII.md","hash":"c52b181fc9a125019cbf63bbdfab88d8bf338068","modified":1550911164161},{"_id":"source/_posts/leetcode-RemoveElement.md","hash":"6347643a93ba85272293e0fea1f271f90f1d7dc6","modified":1545121202632},{"_id":"source/_posts/leetcode-RestoreIPAddresses.md","hash":"87a0fa76dfce78d9fc8d96a0b6c6a6f1e01ce4a6","modified":1551240409619},{"_id":"source/_posts/leetcode-RemoveNthNodeFromEndofList.md","hash":"2735a9b1da895d5a11961f746ce237b036aecf81","modified":1544082195892},{"_id":"source/_posts/leetcode-ReverseInteger.md","hash":"efb316cbdb0ae739ff5163c6a62fa8a6893f5ed9","modified":1543299910710},{"_id":"source/_posts/leetcode-ReverseLinkedListII.md","hash":"9b5de55c7a122c32905362cfc571b3f48b4b1763","modified":1551200754106},{"_id":"source/_posts/leetcode-ReverseNodesink-Group.md","hash":"32bf7589821db767181cf4392dffd547ad71aca9","modified":1545115710144},{"_id":"source/_posts/leetcode-RomantoInteger.md","hash":"1584dd7916d628d44d0468d16dddd26a8340e704","modified":1543458978324},{"_id":"source/_posts/leetcode-RotateImage.md","hash":"e1f4551e80e547fcf65dac24d630c680e0e84379","modified":1547463209322},{"_id":"source/_posts/leetcode-RotateList.md","hash":"f1f66e2920551010b01f4788b6dac84a07c63764","modified":1547462277360},{"_id":"source/_posts/leetcode-ScrambleString.md","hash":"c1bd6142f9d3b77844bdf0003a0c8a41e7ac015c","modified":1551101887482},{"_id":"source/_posts/leetcode-SameTree.md","hash":"717ed7224cf4348f019836e9ff39641a541d563c","modified":1551280432096},{"_id":"source/_posts/leetcode-SearchA2dMatrix.md","hash":"be0870f42e253482f6f4a2dff502512a358d14c2","modified":1550742053708},{"_id":"source/_posts/leetcode-SearchInsertPosition.md","hash":"a2fbcbbb0bc9207a6551b90a1909c559047b4c8c","modified":1545374272352},{"_id":"source/_posts/leetcode-SearchinRotatedSortedArray.md","hash":"e6e9da3a2e9aee8b6b3bea7dcc082ff2566b0949","modified":1545371857652},{"_id":"source/_posts/leetcode-SearchinRotatedSortedArrayII.md","hash":"b6c60f38ae67411b2dd459a5d08f6eaf44a3e9cc","modified":1550909103520},{"_id":"source/_posts/leetcode-SimplifyPath.md","hash":"531993e85e3e41b7df1e5b9bfafe0ec8256ff249","modified":1550321927983},{"_id":"source/_posts/leetcode-SortColors.md","hash":"3cf0e12296e0687b6958ef2c255c27caa1b95a37","modified":1550761498474},{"_id":"source/_posts/leetcode-SpiralMatrix.md","hash":"0e4e54193fce5b5471962c17c104f32ab98abb43","modified":1547365624569},{"_id":"source/_posts/leetcode-StringtoInteger.md","hash":"b431f28d00b385aa6b09e40c480672eb6fb2e586","modified":1547131591793},{"_id":"source/_posts/leetcode-Subsets.md","hash":"25b4e6b4f3d98affa09c8da8bb456b3d9f20441f","modified":1550904557361},{"_id":"source/_posts/leetcode-SpiralMatrixII.md","hash":"0cb033685119fd4a846c909c614ca33ce633a49b","modified":1547365641425},{"_id":"source/_posts/leetcode-SubsetsII.md","hash":"eef80d972c09b4239e015cfe0f3238452998a422","modified":1551183753514},{"_id":"source/_posts/leetcode-SymmetricTree.md","hash":"f79bd35ab3c8cdcbda4bbc5057ea7c48b895bedb","modified":1551679720403},{"_id":"source/_posts/leetcode-SubstringwithConcatenationofAllWords.md","hash":"34be7e05ae6ac18702c573b9d09909e18b893b7e","modified":1545139853446},{"_id":"source/_posts/leetcode-SudokuSolver.md","hash":"dbb614a1ec801ee84bd5f983e57ee0c0a237a979","modified":1551099093592},{"_id":"source/_posts/leetcode-TextJustification.md","hash":"89c1096bee1ad11d95113258ae74f4aee52c563c","modified":1550568793089},{"_id":"source/_posts/leetcode-SwapNodesinPairs.md","hash":"d885fb098d8170a510030d00f98875a5ada57ebd","modified":1545795574299},{"_id":"source/_posts/leetcode-TrappingRainWater.md","hash":"9b7f7d005fae2bfdd1016f60cd202d9bbe977155","modified":1546432645778},{"_id":"source/_posts/leetcode-UniqueBinarySearchTrees.md","hash":"4945950bd0301bbb5247c31088096870f96a6508","modified":1551258334406},{"_id":"source/_posts/leetcode-UniqueBinarySearchTreesII.md","hash":"e99b78dc1e782ebb55859135ed4f8b0c6976cfc6","modified":1551271439141},{"_id":"source/_posts/leetcode-UniquePathsII.md","hash":"3ca213385676e6fdb7a0b27e634dc699acc11e82","modified":1547532605618},{"_id":"source/_posts/leetcode-UniquePaths.md","hash":"e83c1d5936aa627cefd3328c003c8b0bbdb9103a","modified":1547523601739},{"_id":"source/_posts/leetcode-ValidNumber.md","hash":"b5c305c1b3dcdac28bccdbaf4fbc5ea5cd86d090","modified":1547537376566},{"_id":"source/_posts/leetcode-ValidParentheses.md","hash":"3c9048ab850b440038294e81b65ea7117c1a6e2a","modified":1544083118012},{"_id":"source/_posts/leetcode-ValidateBinarySearchTree.md","hash":"e4ffbb71f1c5e81e1529feeea137a2328cbeec6a","modified":1551277230069},{"_id":"source/_posts/leetcode-ValidSudoku.md","hash":"ebe506ca7f9ae2ba133d84bd13b4d1c3562e2097","modified":1551099101506},{"_id":"source/_posts/leetcode-WildcardMatching.md","hash":"548ac8721c1a30c8df6fa45cdd7295f000c7f594","modified":1547006737847},{"_id":"source/_posts/leetcode-ZigZagConversion.md","hash":"2054a9575741c36e9cb6ac8890ef48685d6cf2d4","modified":1543299929850},{"_id":"source/_posts/leetcode-WordSearch.md","hash":"0fd7d93a082b8d14b574816b3f5b53e4da74bf75","modified":1550906236484},{"_id":"source/_posts/leetcode-twosum.md","hash":"c84e9d1266b8ab04a94fcb42b572b9911557462b","modified":1543299921090},{"_id":"source/_posts/leetcode-addtwonumbers.md","hash":"1a6dc38891c924d6d5c5c0d9ce3a2b9d2401db52","modified":1543299578462},{"_id":"source/_posts/leetcode-sqrtx.md","hash":"bbff2d055fb52ce9780771fa7789633fe3d3c7e7","modified":1550309294132},{"_id":"source/_posts/task-oriented-dialog-systems.md","hash":"568918d11ae061fada310fc2d1fdf2c7abe73b40","modified":1543289020030},{"_id":"source/tags/index.md","hash":"a646cf4e1109228f6b7c730b86fce3c0bed1dd35","modified":1543289020047},{"_id":"source/categories/index.md","hash":"2c2ba4b201afe11dfe8b79a1926dfb1951c8bbb2","modified":1543289020030},{"_id":"source/_posts/leetcode-SetMatrixZeroes.md","hash":"b1a0b7d50e4b57b720f186c7619130a228cab6ae","modified":1550324042149},{"_id":"source/images/diag_statistics2.png","hash":"c003b21e7aa9e513f6ba11c480e559bdacd6832f","modified":1543289020034},{"_id":"source/images/intent_input.png","hash":"d675f4a9e795484f2c37fcddce7e4017b8793549","modified":1543289020039},{"_id":"source/images/leetcode_1.png","hash":"7ddb17e84181eb4d0ea5c25afaa75bffec0aaa8b","modified":1543289020040},{"_id":"source/images/leetcode_101.png","hash":"a01706b55c920c7797463b7ae64ad0c79fb24678","modified":1551667669531},{"_id":"source/images/leetcode_102.png","hash":"2dbd5d6ab92898964d1dc2b2c6992d51b7e0d3ed","modified":1551683025036},{"_id":"source/images/leetcode_103.png","hash":"6939eb013d67ed50cb8ba2b295726bdff5af01c8","modified":1551686061982},{"_id":"source/images/leetcode_104.png","hash":"f76b2ecc3809a4950be6a918625f19626baead36","modified":1551690779188},{"_id":"source/images/leetcode_105.png","hash":"e92b125a8c8feafc7b756344923933cb7d93b64f","modified":1551691264580},{"_id":"source/images/leetcode_106.png","hash":"68a4e6446a95e352941ee760ee692ab2314a15c7","modified":1551692422392},{"_id":"source/images/leetcode_107.png","hash":"a94357e7113cf65c0dcc41a08804d7d910eac20d","modified":1551692728436},{"_id":"source/images/leetcode_108.png","hash":"c29010a0c9bca069b0f0be166613415f694357b9","modified":1551696577942},{"_id":"source/images/leetcode_109.png","hash":"dc7843486a0b8d4b9496b2702cc87f2a7d2a4322","modified":1551703668539},{"_id":"source/images/leetcode_111.png","hash":"b607e11116c7346bc662f40d30bd1ae7558f29a2","modified":1551751266478},{"_id":"source/images/leetcode_112.png","hash":"b6bec2aca0fa72014c5f8a4b76eb5e148df0add7","modified":1551752320135},{"_id":"source/images/leetcode_113.png","hash":"5331c280c7c1198afe634007bd18ce773ee06b05","modified":1551757534143},{"_id":"source/images/leetcode_114.png","hash":"abcd16822be88a31cf4e1872b6d2b6a6a9cbb1c0","modified":1551770063890},{"_id":"source/images/leetcode_14.png","hash":"3d3f55344113cdda0066ebd31e864dd8ffaec7e8","modified":1543459466660},{"_id":"source/images/leetcode_16.png","hash":"d8221d2fb73a7ce34fc59d51184bc491764b5308","modified":1543464788335},{"_id":"source/_posts/first_step.md","hash":"ae1f6cb8bc3541958668d424a19fc85fcff66e0b","modified":1543289186978},{"_id":"source/images/leetcode_18.png","hash":"cab88ccc4aa82ac3f6b09fb9a5151e0e0909d0f5","modified":1543921196929},{"_id":"source/images/leetcode_2.png","hash":"8104864998b47dacc3946c32ababcfa9b5ebb245","modified":1543289020041},{"_id":"source/images/leetcode_21.png","hash":"3473cb34ea043f6c16a7fc0a6956fd0a89c1c2cd","modified":1544083489328},{"_id":"source/images/leetcode_22.png","hash":"69bcb0880b3d05345b40be93199220716e96311b","modified":1544171782769},{"_id":"source/images/leetcode_23.png","hash":"487c3432b7c1756a4610849f232f2105e4b84dc6","modified":1544539018550},{"_id":"source/images/leetcode_24.png","hash":"522467e5ce64da859c8f35871301f93aa3a296df","modified":1544709061218},{"_id":"source/images/leetcode_25.png","hash":"ea4bd1aaa8041cf3bf4ff154ec2e10b77d361caa","modified":1545112426660},{"_id":"source/images/leetcode_28.png","hash":"cb918d02a5385c3b9a7e51b7a68870465b78efab","modified":1545121597971},{"_id":"source/images/leetcode_29.png","hash":"8081d530fca880f297e78105ba845216722b1fa6","modified":1545122566692},{"_id":"source/images/leetcode_31.png","hash":"f7b069384669cb63e74cad8d7e085741157648f0","modified":1545358542112},{"_id":"source/images/leetcode_32.png","hash":"f642d733b8e34d915a1ca825d1e6edade437218d","modified":1545364860041},{"_id":"source/images/leetcode_33.png","hash":"c82e686acf0e077fc8816caac6fb8fa70cd7a714","modified":1545369091438},{"_id":"source/images/leetcode_34.png","hash":"3b393863535693f8e0de6789d0300bedbe0340d2","modified":1545372206581},{"_id":"source/images/leetcode_36_1.png","hash":"4239a4e946b1e0e51865c6d26f5ffb126bae4fa2","modified":1545397343852},{"_id":"source/images/leetcode_4.png","hash":"864675976c2b1b3b52df0fee2f138dbcfaa65188","modified":1543289020042},{"_id":"source/images/leetcode_41.png","hash":"64e6d045387ce40d8a59883f7ab7dc72fe7f245d","modified":1545734675436},{"_id":"source/images/leetcode_43.png","hash":"18aabda72fd30490b1f2b2ac76878de86afef18e","modified":1546526848571},{"_id":"source/images/leetcode_45.png","hash":"10cb33589b0b084002cfd391d8c4fd0a9eeedf41","modified":1547003763690},{"_id":"source/images/leetcode_454.png","hash":"df05a7be515dc197fc840b4bf4c6c303daae8263","modified":1544069628254},{"_id":"source/images/leetcode_46.png","hash":"e9bfc514e1bc28beef7365c93b3f3362b79967e0","modified":1547011570466},{"_id":"source/images/leetcode_47.png","hash":"28b0380975d30cd3e01c7aaaf4d755275a07c328","modified":1547013157407},{"_id":"source/images/leetcode_49.png","hash":"90b33a011b1e673658dec89bc0882bb68ed6edd9","modified":1547016656012},{"_id":"source/images/leetcode_5.png","hash":"1b740e42ca94e7d307c3131e9ba5b77774005f03","modified":1543289020042},{"_id":"source/images/leetcode_51.png","hash":"395fc2813ad06291e702bf188e76181cf42599be","modified":1547019174524},{"_id":"source/images/leetcode_15.png","hash":"c29707cff0825a96368a6b20e1cc9863712c456c","modified":1543462677770},{"_id":"source/images/leetcode_19.png","hash":"46b24ebf11818ae25a499069dd367c615c612ff6","modified":1544078584061},{"_id":"source/images/leetcode_52.png","hash":"9479f15aa7fc4f0df6197c13203337580306dad3","modified":1547043627780},{"_id":"source/images/leetcode_53.png","hash":"010f7f6dc92f3569737846210e51133c095e8022","modified":1547043606936},{"_id":"source/images/leetcode_58.png","hash":"4830fdf1632a82211462db1bb8c8a8312ab459b5","modified":1547364169410},{"_id":"source/images/leetcode_6.png","hash":"0ce62cedfeef09ab72e938bcc878f1eedadec98e","modified":1543289020043},{"_id":"source/images/leetcode_59.png","hash":"3fedc0f118ed76cbcb31050b189c3fde99205832","modified":1547364791628},{"_id":"source/images/leetcode_60.png","hash":"31c02751c021c1b07488c004ebf246beb0ee968c","modified":1547365908174},{"_id":"source/images/leetcode_64.png","hash":"2dd218e0fb295305b8f7910f377a863f5e0ed3f0","modified":1547532650985},{"_id":"source/images/leetcode_67.png","hash":"d8dc971f46c75d392abaff70b592e6c62602bb2f","modified":1548326917150},{"_id":"source/images/leetcode_66.png","hash":"095e2025b6f519c8cdc85902adcc64f886d5fd1b","modified":1548322646242},{"_id":"source/images/leetcode_69.png","hash":"fe9a1feeebcf818230a38c6d5a6ebeafd320a9c9","modified":1550308568296},{"_id":"source/images/leetcode_7.png","hash":"af9a31892c21918c3890a814b006682d53431517","modified":1543289020043},{"_id":"source/images/leetcode_75.png","hash":"08fc10c84127eada4c575d6278f2d74375cf2f0b","modified":1550742321471},{"_id":"source/images/leetcode_76.png","hash":"127ebe0fe538aad1005f09263390a695b25a88bb","modified":1550831858126},{"_id":"source/images/leetcode_78.png","hash":"c1c7108686e1e263497072fd0df7a84ac7ea2215","modified":1550903536467},{"_id":"source/images/leetcode_79.png","hash":"6d3ff919883bfd97c11c78070d57fd10cc69a575","modified":1550904807112},{"_id":"source/images/leetcode_82.png","hash":"99fac9bb3658414d48a1bc6093427f2d10432292","modified":1550909647060},{"_id":"source/images/leetcode_81.png","hash":"cd79d0112dcfd81198b225a14d7059bdd621113c","modified":1550909064011},{"_id":"source/images/leetcode_83.png","hash":"ed712081db1862f65e3b9671d22063333307de7c","modified":1550911644585},{"_id":"source/images/leetcode_77.png","hash":"75d2b70ffa55f9a55258932dd0b38b37c559d33d","modified":1550901743834},{"_id":"source/images/leetcode_88.png","hash":"346140df1078725cfdf5762d8d9b79c340139f07","modified":1551102849392},{"_id":"source/images/leetcode_85.png","hash":"3275ede0d3492bf5d45d28b4a7eb79f22dd069eb","modified":1551065769223},{"_id":"source/images/leetcode_86.png","hash":"7ae13f210fb432e84775cf7fe2d469e3376ae63b","modified":1551076691235},{"_id":"source/images/leetcode_92.png","hash":"81be8a735131881d6eee25ca2aebf2af2b1bbd52","modified":1551196883148},{"_id":"source/images/leetcode_90.png","hash":"b7ff2756276b1c91e069217b677632d39f1af3e9","modified":1551183655095},{"_id":"source/images/leetcode_93.png","hash":"4723c65a5ea75d75f217a6ab7a64b1c69b45eea6","modified":1551201116749},{"_id":"source/images/leetcode_97.png","hash":"b85887cef3feab386940cc7be50f781cecabedee","modified":1551271744758},{"_id":"source/images/leetcode_96.png","hash":"8afa3dac740d48ee9dee8cfea38acd5c343ea55a","modified":1551257108149},{"_id":"source/images/leetcode_94.png","hash":"a5cbfd2a6d5fd14fc840cdc02bcd20d7b34f1e2f","modified":1551240979954},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1543289020049},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543289020050},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1543289020049},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1543289020049},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1543289020049},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1543289020050},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1543289020052},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1543289020052},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1543289020052},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1543289020052},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1543289020053},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1543289020054},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1543289020053},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1543289020053},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1543289020057},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543289020057},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1543289020057},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1543289020058},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1543289020058},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1543289020058},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1543289020058},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1543289020058},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543289020057},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1543289020058},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1543289020058},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1543289020059},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1543289020059},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1543289020059},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1543289020059},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1543289020059},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1543289020060},{"_id":"themes/next/layout/_layout.swig","hash":"85de0662a1b136277a72f8d8b4b1425a006f377e","modified":1543289020062},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1543289020104},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1543289020105},{"_id":"themes/next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1543289020106},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1543289020105},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1543289020106},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1543289020107},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1543289020107},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1543289020108},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1543289020108},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543289020108},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543289020155},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543289020155},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543289020156},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1543289020051},{"_id":"source/images/diag_statistics.png","hash":"ffea765a9ffd3ff05537247b871b3882b2e02740","modified":1543289020034},{"_id":"source/images/diag_kv_retrieval_result.png","hash":"4ee9f97f0a5a0dd9fb3a8c254aaa34b70d345040","modified":1543289020033},{"_id":"source/images/intent_f1.png","hash":"65871d1178789be68a95ff07defba29b40bfde42","modified":1543289020036},{"_id":"source/images/intent_frame.png","hash":"777c14e60195e28f7a7d70337b317ae8f3de24b7","modified":1543289020036},{"_id":"source/images/intent_frame_baseline.png","hash":"9a156d1c2723e56017e3e6180109b68e3d834942","modified":1543289020037},{"_id":"source/images/intent_frame_model.png","hash":"9c7fa05f1214bf92990c604ce56c03413e8a16db","modified":1543289020038},{"_id":"source/images/leetcode_100.png","hash":"1327e7ed3ee957ec87e93ec975116a30f8af4b97","modified":1551280250773},{"_id":"source/images/intent_hlstm.png","hash":"caa761afe4039ce40ce441c0e0322cb985dd9896","modified":1543289020038},{"_id":"source/images/leetcode_11.png","hash":"8a40e6634dac9df53cf08f6d36ca0279a15f921d","modified":1543375724577},{"_id":"source/images/leetcode_110.png","hash":"a38b33e4e7c827a9aa80553e9a722586c14c73d3","modified":1551706252727},{"_id":"source/images/leetcode_116.png","hash":"b6554b4a6d2eb5582d577d3d8947a64453b05fcd","modified":1551854643400},{"_id":"source/images/leetcode_12.png","hash":"0b3f43a72b5384a44561d2a48f2f6fef3ce160ff","modified":1543391040079},{"_id":"source/images/leetcode_13.png","hash":"96f88529d99488afd8b0480db038bb1adf21a2d4","modified":1543458664924},{"_id":"source/images/leetcode_17.png","hash":"d949502f6a8246ef7e881a2662989ad7fcaaa540","modified":1543581371166},{"_id":"source/images/leetcode_117.png","hash":"098a694218aa81cdd8fdef7825e25d061b8b8028","modified":1551856661485},{"_id":"source/images/diag_example.png","hash":"31b505dd9f41ef86fbbc68cb233082fc4384ceca","modified":1543289020031},{"_id":"source/images/leetcode_27.png","hash":"9a066ce8ea60b15dc8a0e21fc55eee23b5566149","modified":1545121057439},{"_id":"source/images/leetcode_3.png","hash":"cf5d340924afbaab4f36d751648b7db3a32a6b39","modified":1543289020041},{"_id":"source/images/leetcode_30.png","hash":"f2e7573056a47d7f4f137b46b49fb810fa8d02cb","modified":1545128656590},{"_id":"source/images/leetcode_26.png","hash":"71c6ecb7f1bddbce6186617534d8070c0e61cd70","modified":1545115835436},{"_id":"source/images/leetcode_35.png","hash":"427ff4ce97d1d8811c659bce06197a6cee9135b0","modified":1545373651119},{"_id":"source/images/leetcode_39.png","hash":"6033c6a25a5027645b9ce20d6742381b2c0489ea","modified":1545730194469},{"_id":"source/images/leetcode_40.png","hash":"ffca14bcb72c147b577ae883e37a5271ed364644","modified":1545733463229},{"_id":"source/images/leetcode_42.png","hash":"4db8020ca946703fe655d5debe7f993810e7a4e3","modified":1545796345770},{"_id":"source/images/leetcode_48.png","hash":"8f39e2ea8913874d945bb0e99ffd743fe74ce93e","modified":1547014383202},{"_id":"source/images/leetcode_50.png","hash":"e30124f0a32e86e2db45eed72a3c7b183a145da9","modified":1547017456329},{"_id":"source/images/leetcode_51_1.png","hash":"6a380607dcc9e71396966661f55089749aa5c489","modified":1547019162541},{"_id":"source/images/leetcode_20.png","hash":"398a51b6fae2a4292b44d6135a90b2a41a151a0f","modified":1544082388558},{"_id":"source/images/leetcode_54.png","hash":"426af83b3e81d586ad038d7b508f510ff1ca927f","modified":1547114583631},{"_id":"source/images/leetcode_57.png","hash":"cffbef1f805f04041d867fe00b73c86762a18dd0","modified":1547273490842},{"_id":"source/images/leetcode_56.png","hash":"fe533846b9e14606cb0770d1afbd07dec18c7576","modified":1547127650907},{"_id":"source/images/leetcode_55.png","hash":"d6537713132a49b3826b0f3e8df041d046bcfadd","modified":1547126309058},{"_id":"source/images/leetcode_62.png","hash":"59d4bd86d84471fa15b326f595930b9450106cff","modified":1547520822177},{"_id":"source/images/leetcode_61.png","hash":"8d2779484d2453195ab6145044f44321e8308af7","modified":1547461615921},{"_id":"source/images/leetcode_63.png","hash":"c5b1a3e554d8ed794c155b5581748ae352b7a0c7","modified":1547532631616},{"_id":"source/images/leetcode_65.png","hash":"85df8d917aa37f89becc2b646498e13cc60d8b6f","modified":1547533738757},{"_id":"source/images/leetcode_70.png","hash":"a47c1406650b879262961bf3e4ef027243e796f7","modified":1550317764565},{"_id":"source/images/leetcode_73.png","hash":"0b03bc42c822bc7b4da95b4a0393c8b6e36305ca","modified":1550323319630},{"_id":"source/images/leetcode_72.png","hash":"df764b3e3464f78ef8fbd6ad4b47c52151dab8c7","modified":1550569271086},{"_id":"source/images/leetcode_74.png","hash":"ec7824f21751bac77df80979d45a3b589e211f96","modified":1550737274150},{"_id":"source/images/leetcode_84.png","hash":"21c4ebaa020111c974fcd7ff8a3a52708488ad10","modified":1550911980742},{"_id":"source/images/leetcode_80.png","hash":"4392a496de4d63e439a3539b8946ef51ae93cc2b","modified":1550906608851},{"_id":"source/images/leetcode_91.png","hash":"8bf23a378313e0c174e26b55ada9d13f8aef3170","modified":1551183565007},{"_id":"source/images/leetcode_9.png","hash":"28a3e03eb39d10d0e37d54640a4a82cdf1c01ca8","modified":1543240724911},{"_id":"source/images/leetcode_95.png","hash":"73da5812f0b813c442b656da93227b3c5d4a9430","modified":1551256129420},{"_id":"source/images/mem2seq_result.png","hash":"685fd2616a59a850b69e34f03034ca84421536f9","modified":1543289020046},{"_id":"source/images/leetcode_99.png","hash":"c8c64d8098100d79a05c67f8e9be2eac705ca083","modified":1551277505252},{"_id":"source/images/leetcode_98.png","hash":"a4c66675b3ece7ec7b3ecc2779511eb0cb923e65","modified":1551273165823},{"_id":"source/images/mem2seq.png","hash":"9cd4573451de0668f7ec93363063566a333b0519","modified":1543289020045},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020142},{"_id":"source/images/leetcode_37.png","hash":"14b1d520bf39b87d4c71856f593386346ad78bed","modified":1545399912605},{"_id":"source/images/intent_dstc_rnn.png","hash":"f96016561fbc376a220790b4d58c472f6ab9b5d5","modified":1543289020035},{"_id":"source/images/leetcode_10.png","hash":"11dc2c98bc132577a4d851a6c539df05921ca2a4","modified":1543301993137},{"_id":"source/images/leetcode_115.png","hash":"090fab6b7ef467f20c0a60585a935026637af528","modified":1551771088300},{"_id":"source/images/leetcode_8.png","hash":"33698546ff3681d0fa969306fdd95cb4c7e9fde2","modified":1543289020044},{"_id":"source/images/leetcode_89.png","hash":"f960d8602bfd549e51990a92d8d3388f8e186fbf","modified":1551106297522},{"_id":"source/images/mem2seq_result2.png","hash":"5c09b80aa39ecb507d4b89a352324618ee449a73","modified":1543289020047},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1543289020054},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1543289020054},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1543289020054},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1543289020055},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1543289020056},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1543289020057},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543289020061},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543289020061},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1543289020070},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543289020060},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1543289020070},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1543289020071},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1543289020073},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1543289020082},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1543289020082},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1543289020082},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1543289020083},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d15a983de60d4c0bdd23cd31cd49de876ed2310c","modified":1543289020083},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1543289020086},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1543289020086},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1543289020090},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1543289020090},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1543289020090},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1543289020092},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1543289020095},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1543289020097},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1543289020097},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1543289020098},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1543289020100},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1543289020100},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543289020101},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1543289020101},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543289020101},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1543289020109},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1543289020109},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1543289020109},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1543289020109},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1543289020109},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1543289020110},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1543289020110},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1543289020110},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1543289020110},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1543289020141},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543289020142},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543289020142},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543289020142},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543289020142},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543289020142},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543289020143},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543289020143},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543289020143},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543289020143},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543289020143},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543289020143},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543289020144},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543289020144},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543289020144},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543289020144},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543289020144},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543289020145},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543289020145},{"_id":"source/images/leetcode_36.png","hash":"beebba1481cbacc8d7b67b2a60d339f34e9cf332","modified":1545397212119},{"_id":"themes/next/layout/_macro/post.swig","hash":"5767eccaf3951151e01c61189016932e9516c8b9","modified":1543289020072},{"_id":"source/images/intent_results.png","hash":"66dba505ee2feffe151e2bfedf2f3a4520de8bf4","modified":1543289020040},{"_id":"source/images/diag_kv_retrieval.png","hash":"a2f728eac72580c85a45923a4df0c9d20ad47857","modified":1543289020032},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020091},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020091},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020131},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020141},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543289020141},{"_id":"source/images/leetcode_65_2.png","hash":"afd61b00dd83631e1cf8525c8b31ac77280dc127","modified":1547536806306},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1543289020070},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1543289020083},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1543289020084},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1543289020084},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1543289020085},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1543289020085},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1543289020086},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1543289020086},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1543289020087},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543289020087},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543289020088},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543289020088},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543289020088},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543289020089},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543289020089},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543289020091},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1543289020090},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543289020091},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1543289020092},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543289020092},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543289020092},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1543289020093},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543289020095},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1543289020094},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543289020095},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1543289020096},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1543289020097},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1543289020097},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1543289020099},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1543289020099},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1543289020099},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543289020103},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543289020104},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1543289020103},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543289020104},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1543289020131},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543289020130},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1543289020131},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1543289020131},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1543289020141},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1543289020141},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1543289020141},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1543289020141},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543289020145},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543289020145},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543289020145},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543289020145},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543289020146},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543289020146},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543289020146},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543289020147},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543289020147},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543289020147},{"_id":"themes/next/source/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1543289020147},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543289020148},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543289020148},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543289020148},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543289020148},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543289020154},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543289020154},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543289020154},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1543289020063},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543289020152},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1543289020102},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1543289020110},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543289020102},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1543289020117},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543289020125},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1543289020130},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1543289020129},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543289020130},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1543289020133},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1543289020130},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1543289020132},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543289020134},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543289020133},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1543289020134},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1543289020134},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543289020135},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1543289020135},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543289020137},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543289020138},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543289020139},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1543289020140},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1543289020141},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1543289020146},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543289020152},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543289020152},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543289020129},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543289020149},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543289020149},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543289020148},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543289020153},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543289020151},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1543289020111},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543289020114},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1543289020114},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1543289020112},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1543289020112},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543289020112},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543289020113},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1543289020115},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1543289020115},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1543289020116},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543289020115},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1543289020117},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543289020116},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1543289020118},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1543289020118},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1543289020119},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543289020120},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1543289020120},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1543289020120},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1543289020121},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1543289020122},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543289020121},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1543289020122},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1543289020123},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543289020122},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1543289020123},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1543289020124},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1543289020124},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1543289020125},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1543289020124},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1543289020126},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1543289020127},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1543289020128},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1543289020129},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543289020136},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543289020136},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543289020139},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543289020151},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543289020150},{"_id":"source/images/leetcode_87.png","hash":"85ea667a2b0e57f7cfea65f3a4ed64ee08c89995","modified":1551095842021},{"_id":"source/images/leetcode_68.png","hash":"334769e6b270ce6618adfdf6bb8cc2c9a8bd1e30","modified":1550559590495},{"_id":"source/images/leetcode_71.png","hash":"a842053c6f45a414c166ef837c83f2458126613e","modified":1550321066938},{"_id":"source/images/leetcode_44.png","hash":"e96cadc33c3bc927d22870427031e9203647870d","modified":1546951814970}],"Category":[{"name":"Research","_id":"cjszht7z10005kvpxqgq138iq"},{"name":"LeetCode","_id":"cjszht7zh000akvpxc2soe4eg"},{"name":"Note","_id":"cjszht8h000l1kvpxm4m7yeb6"}],"Data":[],"Page":[{"_content":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html","source":"google10bb50e0b38f396b.html","raw":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html","date":"2019-01-09T05:23:10.206Z","updated":"2018-11-27T03:23:40.030Z","path":"google10bb50e0b38f396b.html","title":"","comments":1,"layout":"page","_id":"cjszht7wl0000kvpxdq84nj7g","content":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google10bb50e0b38f396b.html\nskip_render: googled6054e120f1a1419.html"},{"title":"tags","date":"2018-10-30T09:23:49.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-10-30 17:23:49\ntype: \"tags\"\n---\n","updated":"2018-11-27T03:23:40.047Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjszht7yr0002kvpxow5igixi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-10-30T09:23:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-10-30 17:23:43\ntype: \"categories\"\n---\n","updated":"2018-11-27T03:23:40.030Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjszht7yw0004kvpx3cgtj1ge","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Review on Intent Classification and Slot Filling","date":"2018-11-02T02:41:02.000Z","_content":"\n自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。\n\n<!--more-->\n\n意图分类时一个典型的文本分类的问题，常用的方法如下：\n- 基于规则的方法\n 用户人工定义一些匹配规则进行分类。\n- 机器学习的方法\n SVM, Decision Tree等等。\n- 深度学习的方法\n 目前更加推崇使用 End-to-End 的网络进行分类。\n\n最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。\n\n## 中文数据集\n\n### [NLPCC 2018 Task4](http://tcci.ccf.org.cn/conference/2018/taskdata.php) - Spoken Language Understanding in Task-Oriented Dialogue Systems\n\n#### 数据描述 [1]\n这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 **5.8K** 次会话，总共有 **26K** 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。\n\n - 训练集：4705次会话, 21352次叙述。\n - 验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）\n\n数据格式\n``` bash\nsession ID    用户query              意图                       语义槽标注\n    1           打电话\t   phone_call.make_a_phone_call\t        打电话\n    1\t      我想听美观\t        music.play\t          我想听<song>美观</song>\n    1\t      我想听什话\t        music.play\t          我想听<song>什话||神话</song>\n```\n\n#### 评估方法\n这个比赛主要有两个评估方法:\n\n- 意图分类，评估方法为F1值，具体的计算方法如下：\n<div align=center>\n\t<img src=\"/images/intent_f1.png\" width = \"500\"/>\n</div>\n\n- 意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。\n\n#### 主要算法\n总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：\n<div align=center>\n\t<img src=\"/images/intent_results.png\" width = \"500\" align=center/>\n</div>\n\n##### HLSTM-SLU [2]\n这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：\n<div align=center>\n\t<img src=\"/images/intent_hlstm.png\" width = \"500\" align=center/>\n</div>\n\n这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。\n\n- 输入Bi-LSTM\n 输入：Character Embedding + POS + Domain \n 其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：\n\n<div align=center>\n\t<img src=\"/images/intent_input.png\" width = \"500\" align=center/>\n</div>\n\n- Session LSTM\n 输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。\n 输出：**意图的类别**\n\n- 输出Bi-LSTM\n 输入：Session LSTM + 输入Bi-LSTM\n 输出：**槽位标注**\n\n注：并没有直接使用LSTM的结果作为最终的结果，而是根据 **CRF** 预测最优的序列。\n\n**Trick**: 使用 **over sampling** 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。\n\n**结果**：这个模型在两个评估方法的结果最终为94.19%，90.84%。\n\n##### Sogou [3]\n这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用**基于规则**的处理的方法进行标注；剩下的部分采用**基于模型**的方法，具体的模型方法分为5步：\n\n1. 对query进行分词和词性标注（POS）。\n\n2. 寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。\n\n3. 槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。\n\n4. 槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。\n\n5. 意图分类：使用**XGBoost**的方法，根据word embedding，query长度，槽类别进行意图分类。\n\n注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。\n\n**结果**：这个模型在两个评估方法的结果最终为96.11%，94.49%。\n\n## 英文数据集\n\n### [Frame](https://datasets.maluuba.com/Frames/dl)\n\n#### 数据描述 [4]\n这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 **1369** 个对话, 总共有 **19986** 轮。\n\n**数据格式**\n每一次叙述都包含 'author', 'text', 'labels', 'timestamp', 'frames'('frame id', 'frame parent id', 'requests, binary questions, compare requests', 'info'), 'db'字段。其中 'labels'记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， 'info'字段主要为了标注对于槽位值是否为否定的。\n\n**Act类型**：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye.....\n\n\n#### 评估方法\n微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：\n<div align=center>\n\t<img src=\"/images/intent_frame.png\" width = \"300\" align=center/>\n</div>\n\n这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。\n\n#### 主要算法\n\n##### Baseline [4]\n由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。\n<div align=center>\n\t<img src=\"/images/intent_frame_baseline.png\" width = \"300\" align=center/>\n</div>\n\n**结果**：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。\n\n##### Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\n微软的团队随后提出了一个新的模型来处理这个问题。\n\n###### 输入预处理\n\n- Token Encoding：每个词用trigrams的形式表示。如：“hello” -> #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 \n\n- 用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。\n\n- Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。\n\n- Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。\n\n\n###### 模型输入\n\n- 当前轮之前所有的frames （Slot ID, Trigrams ID）\n\n- 叙述 （Trigrams ID）\n\n- 当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）\n\n###### 模型结构\n\n<div align=center>\n\t<img src=\"/images/intent_frame_model.png\" width = \"400\" align=center/>\n</div>\n\n1. 对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\\\(m_f\\\\) （|F| \\* 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\\\(m_{asv}\\\\) （N \\* 256, N为act的数量）来表示acts；\n\n2. 通过计算 \\\\(m_f\\\\) 和 \\\\(m_{asv}\\\\) 的点乘的结果 \\\\(S_m\\\\) （N \\* |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\\\(S_L\\\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。\n\n3. 在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\\\(p_{asv, f}\\\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。\n\n4. 另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\\\(p_{a, f}\\\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。\n\n**注**：这里没有详细介绍实验的一些完善trick，如模型图中的\\\\(g_c\\\\)， \\\\(g_n\\\\)， \\\\(h_d\\\\)， \\\\(h_c\\\\)，详情请看论文。\n\n**结果**：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。\n\n\n### [DSTC](https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/) (Dialog State Tracking Challenge) [6, 7]\n\n#### 数据描述\nDSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。\n- DSTC 1\n 这个数据集包括城市BUS的预定电话中的对话数据。**12963**轮训练数据，**2485**轮测试数据。\n\n- DSTC 2&3\n 在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括**2218**轮训练数据，**1117**轮测试数据；DSTC3包括**3235**轮训练数据，**2275**轮测试数据。数据中的`semantics`字段会对对话中的槽slot和目的act标注。下面是一个数据样例：\n ```bash\n DSTC2 and DSTC3 (Training Set)\n SYS: Which part of town?\n USR: The north uh area\n SYS: Which part of town?\n USR: A cheap place in the north\n SYS: Clown cafe is a cheap restaurant in the north part of town. USR: Do you have any others like that?\n SYS: Galleria is another cheap restaurant in the north. USR: What is their phone number and address?\n ```\n\n- DSTC 4 \n 这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：\n - SVM分类模型\n  输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）\n - 逻辑回归模型 \n  输入：同上。\n - 随机森林模型\n  输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）\n\n- DSTC 5\n 这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。\n\n- DSTC 6\n 这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。\n\n#### 评估方法 （DSTC2 & 3）\n- 准确度：正确预测的轮数占数据总轮数的百分数。\n- L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。\n\n#### 主要算法\n这里我们主要关注在DSTC3上的四个模型。\n\n##### 马尔科夫判别模型 [8]\n<!-- team7 -->\n这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。\n$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\\\(H_t^s\\\\)是在t轮对于槽类型s的假设的集合。\n\n另外，也是本文中比较新的一点是**马尔科夫判别模型**，也就是将生成模型和判别模型相结合：\n\n生成模型： \\\\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\\\)\n\n判别模型： \\\\(P(S_t | O_1^t) = f(O_1^t)\\\\)\n\n马尔科夫判别模型：\\\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\\\)\n\n在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作**标签过耦合**问题。为了解决这个问题，他们设计了一个2步训练法：\n\n- 第一步：训练一个传统的判别模型。\n\n- 第二部：在第一步的基础上训练状态转移特征。\n\n这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 \n\n##### 循环神经网络 [9] \n<!-- team 3 -->\n这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用<slot\\>和<value\\>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。\n\n<div align=center>\n\t<img src=\"/images/intent_dstc_rnn.png\" width = \"400\" align=center/>\n</div>\n\n通过上图的过程，我们可以得出 \"Jamaican food\"标记为 \"s=food and v=jamaican\"，若新的叙述为 \"The Girton area\" 其替换为<slot\\>和<value\\>的概率分布与前者类似，因此可以得出 \"s=area and v=girton\"。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。\n\n##### 基于规则的模型 [10] \n<!-- team 5 -->\n这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，**马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)**。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 \n\n\n##### 知识驱动的基于规则的模型 [11] \n<!-- team 4 -->\n这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n\n\n\n\n[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems\n[2] Learning Dialogue History for Spoken Language Understanding.\n[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.\n[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.\n[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.\n[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.\n[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.\n[8] Markovian discriminative modeling for cross-domain dialog state tracking. \n[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.\n[10] A generalized rule based tracker for dialogue state tracking. \n[11] Knowledge-based dialog state tracking.\n\n","source":"_posts/intent_slot.md","raw":"---\ntitle: Review on Intent Classification and Slot Filling\ndate: 2018-11-02 10:41:02\ncategories: Research\ntags: \n  - intent\n  - slot \n---\n\n自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。\n\n<!--more-->\n\n意图分类时一个典型的文本分类的问题，常用的方法如下：\n- 基于规则的方法\n 用户人工定义一些匹配规则进行分类。\n- 机器学习的方法\n SVM, Decision Tree等等。\n- 深度学习的方法\n 目前更加推崇使用 End-to-End 的网络进行分类。\n\n最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。\n\n## 中文数据集\n\n### [NLPCC 2018 Task4](http://tcci.ccf.org.cn/conference/2018/taskdata.php) - Spoken Language Understanding in Task-Oriented Dialogue Systems\n\n#### 数据描述 [1]\n这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 **5.8K** 次会话，总共有 **26K** 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。\n\n - 训练集：4705次会话, 21352次叙述。\n - 验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）\n\n数据格式\n``` bash\nsession ID    用户query              意图                       语义槽标注\n    1           打电话\t   phone_call.make_a_phone_call\t        打电话\n    1\t      我想听美观\t        music.play\t          我想听<song>美观</song>\n    1\t      我想听什话\t        music.play\t          我想听<song>什话||神话</song>\n```\n\n#### 评估方法\n这个比赛主要有两个评估方法:\n\n- 意图分类，评估方法为F1值，具体的计算方法如下：\n<div align=center>\n\t<img src=\"/images/intent_f1.png\" width = \"500\"/>\n</div>\n\n- 意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。\n\n#### 主要算法\n总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：\n<div align=center>\n\t<img src=\"/images/intent_results.png\" width = \"500\" align=center/>\n</div>\n\n##### HLSTM-SLU [2]\n这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：\n<div align=center>\n\t<img src=\"/images/intent_hlstm.png\" width = \"500\" align=center/>\n</div>\n\n这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。\n\n- 输入Bi-LSTM\n 输入：Character Embedding + POS + Domain \n 其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：\n\n<div align=center>\n\t<img src=\"/images/intent_input.png\" width = \"500\" align=center/>\n</div>\n\n- Session LSTM\n 输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。\n 输出：**意图的类别**\n\n- 输出Bi-LSTM\n 输入：Session LSTM + 输入Bi-LSTM\n 输出：**槽位标注**\n\n注：并没有直接使用LSTM的结果作为最终的结果，而是根据 **CRF** 预测最优的序列。\n\n**Trick**: 使用 **over sampling** 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。\n\n**结果**：这个模型在两个评估方法的结果最终为94.19%，90.84%。\n\n##### Sogou [3]\n这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用**基于规则**的处理的方法进行标注；剩下的部分采用**基于模型**的方法，具体的模型方法分为5步：\n\n1. 对query进行分词和词性标注（POS）。\n\n2. 寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。\n\n3. 槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。\n\n4. 槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。\n\n5. 意图分类：使用**XGBoost**的方法，根据word embedding，query长度，槽类别进行意图分类。\n\n注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。\n\n**结果**：这个模型在两个评估方法的结果最终为96.11%，94.49%。\n\n## 英文数据集\n\n### [Frame](https://datasets.maluuba.com/Frames/dl)\n\n#### 数据描述 [4]\n这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 **1369** 个对话, 总共有 **19986** 轮。\n\n**数据格式**\n每一次叙述都包含 'author', 'text', 'labels', 'timestamp', 'frames'('frame id', 'frame parent id', 'requests, binary questions, compare requests', 'info'), 'db'字段。其中 'labels'记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， 'info'字段主要为了标注对于槽位值是否为否定的。\n\n**Act类型**：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye.....\n\n\n#### 评估方法\n微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：\n<div align=center>\n\t<img src=\"/images/intent_frame.png\" width = \"300\" align=center/>\n</div>\n\n这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。\n\n#### 主要算法\n\n##### Baseline [4]\n由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。\n<div align=center>\n\t<img src=\"/images/intent_frame_baseline.png\" width = \"300\" align=center/>\n</div>\n\n**结果**：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。\n\n##### Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\n微软的团队随后提出了一个新的模型来处理这个问题。\n\n###### 输入预处理\n\n- Token Encoding：每个词用trigrams的形式表示。如：“hello” -> #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 \n\n- 用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。\n\n- Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。\n\n- Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。\n\n\n###### 模型输入\n\n- 当前轮之前所有的frames （Slot ID, Trigrams ID）\n\n- 叙述 （Trigrams ID）\n\n- 当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）\n\n###### 模型结构\n\n<div align=center>\n\t<img src=\"/images/intent_frame_model.png\" width = \"400\" align=center/>\n</div>\n\n1. 对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\\\(m_f\\\\) （|F| \\* 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\\\(m_{asv}\\\\) （N \\* 256, N为act的数量）来表示acts；\n\n2. 通过计算 \\\\(m_f\\\\) 和 \\\\(m_{asv}\\\\) 的点乘的结果 \\\\(S_m\\\\) （N \\* |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\\\(S_L\\\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。\n\n3. 在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\\\(p_{asv, f}\\\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。\n\n4. 另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\\\(p_{a, f}\\\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。\n\n**注**：这里没有详细介绍实验的一些完善trick，如模型图中的\\\\(g_c\\\\)， \\\\(g_n\\\\)， \\\\(h_d\\\\)， \\\\(h_c\\\\)，详情请看论文。\n\n**结果**：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。\n\n\n### [DSTC](https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/) (Dialog State Tracking Challenge) [6, 7]\n\n#### 数据描述\nDSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。\n- DSTC 1\n 这个数据集包括城市BUS的预定电话中的对话数据。**12963**轮训练数据，**2485**轮测试数据。\n\n- DSTC 2&3\n 在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括**2218**轮训练数据，**1117**轮测试数据；DSTC3包括**3235**轮训练数据，**2275**轮测试数据。数据中的`semantics`字段会对对话中的槽slot和目的act标注。下面是一个数据样例：\n ```bash\n DSTC2 and DSTC3 (Training Set)\n SYS: Which part of town?\n USR: The north uh area\n SYS: Which part of town?\n USR: A cheap place in the north\n SYS: Clown cafe is a cheap restaurant in the north part of town. USR: Do you have any others like that?\n SYS: Galleria is another cheap restaurant in the north. USR: What is their phone number and address?\n ```\n\n- DSTC 4 \n 这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：\n - SVM分类模型\n  输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）\n - 逻辑回归模型 \n  输入：同上。\n - 随机森林模型\n  输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）\n\n- DSTC 5\n 这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。\n\n- DSTC 6\n 这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。\n\n#### 评估方法 （DSTC2 & 3）\n- 准确度：正确预测的轮数占数据总轮数的百分数。\n- L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。\n\n#### 主要算法\n这里我们主要关注在DSTC3上的四个模型。\n\n##### 马尔科夫判别模型 [8]\n<!-- team7 -->\n这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。\n$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\\\(H_t^s\\\\)是在t轮对于槽类型s的假设的集合。\n\n另外，也是本文中比较新的一点是**马尔科夫判别模型**，也就是将生成模型和判别模型相结合：\n\n生成模型： \\\\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\\\)\n\n判别模型： \\\\(P(S_t | O_1^t) = f(O_1^t)\\\\)\n\n马尔科夫判别模型：\\\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\\\)\n\n在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作**标签过耦合**问题。为了解决这个问题，他们设计了一个2步训练法：\n\n- 第一步：训练一个传统的判别模型。\n\n- 第二部：在第一步的基础上训练状态转移特征。\n\n这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 \n\n##### 循环神经网络 [9] \n<!-- team 3 -->\n这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用<slot\\>和<value\\>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。\n\n<div align=center>\n\t<img src=\"/images/intent_dstc_rnn.png\" width = \"400\" align=center/>\n</div>\n\n通过上图的过程，我们可以得出 \"Jamaican food\"标记为 \"s=food and v=jamaican\"，若新的叙述为 \"The Girton area\" 其替换为<slot\\>和<value\\>的概率分布与前者类似，因此可以得出 \"s=area and v=girton\"。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。\n\n##### 基于规则的模型 [10] \n<!-- team 5 -->\n这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，**马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)**。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 \n\n\n##### 知识驱动的基于规则的模型 [11] \n<!-- team 4 -->\n这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n\n\n\n\n[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems\n[2] Learning Dialogue History for Spoken Language Understanding.\n[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.\n[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.\n[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.\n[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.\n[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.\n[8] Markovian discriminative modeling for cross-domain dialog state tracking. \n[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.\n[10] A generalized rule based tracker for dialogue state tracking. \n[11] Knowledge-based dialog state tracking.\n\n","slug":"intent_slot","published":1,"updated":"2018-11-27T03:23:40.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7yl0001kvpxxvogkhbc","content":"<p>自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。</p>\n<a id=\"more\"></a>\n<p>意图分类时一个典型的文本分类的问题，常用的方法如下：</p>\n<ul>\n<li>基于规则的方法<br>用户人工定义一些匹配规则进行分类。</li>\n<li>机器学习的方法<br>SVM, Decision Tree等等。</li>\n<li>深度学习的方法<br>目前更加推崇使用 End-to-End 的网络进行分类。</li>\n</ul>\n<p>最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。</p>\n<h2 id=\"中文数据集\"><a href=\"#中文数据集\" class=\"headerlink\" title=\"中文数据集\"></a>中文数据集</h2><h3 id=\"NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\"><a href=\"#NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\" class=\"headerlink\" title=\"NLPCC 2018 Task4 - Spoken Language Understanding in Task-Oriented Dialogue Systems\"></a><a href=\"http://tcci.ccf.org.cn/conference/2018/taskdata.php\" target=\"_blank\" rel=\"noopener\">NLPCC 2018 Task4</a> - Spoken Language Understanding in Task-Oriented Dialogue Systems</h3><h4 id=\"数据描述-1\"><a href=\"#数据描述-1\" class=\"headerlink\" title=\"数据描述 [1]\"></a>数据描述 [1]</h4><p>这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 <strong>5.8K</strong> 次会话，总共有 <strong>26K</strong> 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。</p>\n<ul>\n<li>训练集：4705次会话, 21352次叙述。</li>\n<li>验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）</li>\n</ul>\n<p>数据格式<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">session ID    用户query              意图                       语义槽标注</span><br><span class=\"line\">    1           打电话\t   phone_call.make_a_phone_call\t        打电话</span><br><span class=\"line\">    1\t      我想听美观\t        music.play\t          我想听&lt;song&gt;美观&lt;/song&gt;</span><br><span class=\"line\">    1\t      我想听什话\t        music.play\t          我想听&lt;song&gt;什话||神话&lt;/song&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"评估方法\"><a href=\"#评估方法\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>这个比赛主要有两个评估方法:</p>\n<ul>\n<li><p>意图分类，评估方法为F1值，具体的计算方法如下：</p>\n<div align=\"center\"><br>  <img src=\"/images/intent_f1.png\" width=\"500\"><br></div>\n</li>\n<li><p>意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。</p>\n</li>\n</ul>\n<h4 id=\"主要算法\"><a href=\"#主要算法\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_results.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h5 id=\"HLSTM-SLU-2\"><a href=\"#HLSTM-SLU-2\" class=\"headerlink\" title=\"HLSTM-SLU [2]\"></a>HLSTM-SLU [2]</h5><p>这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_hlstm.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。</p>\n<ul>\n<li>输入Bi-LSTM<br>输入：Character Embedding + POS + Domain<br>其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：</li>\n</ul>\n<div align=\"center\"><br>    <img src=\"/images/intent_input.png\" width=\"500\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Session LSTM<br>输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。<br>输出：<strong>意图的类别</strong></p>\n</li>\n<li><p>输出Bi-LSTM<br>输入：Session LSTM + 输入Bi-LSTM<br>输出：<strong>槽位标注</strong></p>\n</li>\n</ul>\n<p>注：并没有直接使用LSTM的结果作为最终的结果，而是根据 <strong>CRF</strong> 预测最优的序列。</p>\n<p><strong>Trick</strong>: 使用 <strong>over sampling</strong> 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为94.19%，90.84%。</p>\n<h5 id=\"Sogou-3\"><a href=\"#Sogou-3\" class=\"headerlink\" title=\"Sogou [3]\"></a>Sogou [3]</h5><p>这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用<strong>基于规则</strong>的处理的方法进行标注；剩下的部分采用<strong>基于模型</strong>的方法，具体的模型方法分为5步：</p>\n<ol>\n<li><p>对query进行分词和词性标注（POS）。</p>\n</li>\n<li><p>寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。</p>\n</li>\n<li><p>槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。</p>\n</li>\n<li><p>槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。</p>\n</li>\n<li><p>意图分类：使用<strong>XGBoost</strong>的方法，根据word embedding，query长度，槽类别进行意图分类。</p>\n</li>\n</ol>\n<p>注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为96.11%，94.49%。</p>\n<h2 id=\"英文数据集\"><a href=\"#英文数据集\" class=\"headerlink\" title=\"英文数据集\"></a>英文数据集</h2><h3 id=\"Frame\"><a href=\"#Frame\" class=\"headerlink\" title=\"Frame\"></a><a href=\"https://datasets.maluuba.com/Frames/dl\" target=\"_blank\" rel=\"noopener\">Frame</a></h3><h4 id=\"数据描述-4\"><a href=\"#数据描述-4\" class=\"headerlink\" title=\"数据描述 [4]\"></a>数据描述 [4]</h4><p>这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 <strong>1369</strong> 个对话, 总共有 <strong>19986</strong> 轮。</p>\n<p><strong>数据格式</strong><br>每一次叙述都包含 ‘author’, ‘text’, ‘labels’, ‘timestamp’, ‘frames’(‘frame id’, ‘frame parent id’, ‘requests, binary questions, compare requests’, ‘info’), ‘db’字段。其中 ‘labels’记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， ‘info’字段主要为了标注对于槽位值是否为否定的。</p>\n<p><strong>Act类型</strong>：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye…..</p>\n<h4 id=\"评估方法-1\"><a href=\"#评估方法-1\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p>这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。</p>\n<h4 id=\"主要算法-1\"><a href=\"#主要算法-1\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><h5 id=\"Baseline-4\"><a href=\"#Baseline-4\" class=\"headerlink\" title=\"Baseline [4]\"></a>Baseline [4]</h5><p>由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame_baseline.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。</p>\n<h5 id=\"Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\"><a href=\"#Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\" class=\"headerlink\" title=\"Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\"></a>Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]</h5><p>微软的团队随后提出了一个新的模型来处理这个问题。</p>\n<h6 id=\"输入预处理\"><a href=\"#输入预处理\" class=\"headerlink\" title=\"输入预处理\"></a>输入预处理</h6><ul>\n<li><p>Token Encoding：每个词用trigrams的形式表示。如：“hello” -&gt; #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 </p>\n</li>\n<li><p>用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。</p>\n</li>\n<li><p>Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。</p>\n</li>\n<li><p>Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。</p>\n</li>\n</ul>\n<h6 id=\"模型输入\"><a href=\"#模型输入\" class=\"headerlink\" title=\"模型输入\"></a>模型输入</h6><ul>\n<li><p>当前轮之前所有的frames （Slot ID, Trigrams ID）</p>\n</li>\n<li><p>叙述 （Trigrams ID）</p>\n</li>\n<li><p>当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）</p>\n</li>\n</ul>\n<h6 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h6><div align=\"center\"><br>    <img src=\"/images/intent_frame_model.png\" width=\"400\" align=\"center/\"><br></div>\n\n<ol>\n<li><p>对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\(m_f\\) （|F| * 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\(m_{asv}\\) （N * 256, N为act的数量）来表示acts；</p>\n</li>\n<li><p>通过计算 \\(m_f\\) 和 \\(m_{asv}\\) 的点乘的结果 \\(S_m\\) （N * |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\(S_L\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。</p>\n</li>\n<li><p>在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\(p_{asv, f}\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。</p>\n</li>\n<li><p>另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\(p_{a, f}\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。</p>\n</li>\n</ol>\n<p><strong>注</strong>：这里没有详细介绍实验的一些完善trick，如模型图中的\\(g_c\\)， \\(g_n\\)， \\(h_d\\)， \\(h_c\\)，详情请看论文。</p>\n<p><strong>结果</strong>：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。</p>\n<h3 id=\"DSTC-Dialog-State-Tracking-Challenge-6-7\"><a href=\"#DSTC-Dialog-State-Tracking-Challenge-6-7\" class=\"headerlink\" title=\"DSTC (Dialog State Tracking Challenge) [6, 7]\"></a><a href=\"https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/\" target=\"_blank\" rel=\"noopener\">DSTC</a> (Dialog State Tracking Challenge) [6, 7]</h3><h4 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h4><p>DSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。</p>\n<ul>\n<li><p>DSTC 1<br>这个数据集包括城市BUS的预定电话中的对话数据。<strong>12963</strong>轮训练数据，<strong>2485</strong>轮测试数据。</p>\n</li>\n<li><p>DSTC 2&amp;3<br>在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括<strong>2218</strong>轮训练数据，<strong>1117</strong>轮测试数据；DSTC3包括<strong>3235</strong>轮训练数据，<strong>2275</strong>轮测试数据。数据中的<code>semantics</code>字段会对对话中的槽slot和目的act标注。下面是一个数据样例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DSTC2 and DSTC3 (Training Set)</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: The north uh area</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: A cheap place <span class=\"keyword\">in</span> the north</span><br><span class=\"line\">SYS: Clown cafe is a cheap restaurant <span class=\"keyword\">in</span> the north part of town. USR: Do you have any others like that?</span><br><span class=\"line\">SYS: Galleria is another cheap restaurant <span class=\"keyword\">in</span> the north. USR: What is their phone number and address?</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DSTC 4<br>这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：</p>\n<ul>\n<li>SVM分类模型<br>输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）</li>\n<li>逻辑回归模型<br>输入：同上。</li>\n<li>随机森林模型<br>输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）</li>\n</ul>\n</li>\n<li><p>DSTC 5<br>这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。</p>\n</li>\n<li><p>DSTC 6<br>这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。</p>\n</li>\n</ul>\n<h4 id=\"评估方法-（DSTC2-amp-3）\"><a href=\"#评估方法-（DSTC2-amp-3）\" class=\"headerlink\" title=\"评估方法 （DSTC2 &amp; 3）\"></a>评估方法 （DSTC2 &amp; 3）</h4><ul>\n<li>准确度：正确预测的轮数占数据总轮数的百分数。</li>\n<li>L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。</li>\n</ul>\n<h4 id=\"主要算法-2\"><a href=\"#主要算法-2\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>这里我们主要关注在DSTC3上的四个模型。</p>\n<h5 id=\"马尔科夫判别模型-8\"><a href=\"#马尔科夫判别模型-8\" class=\"headerlink\" title=\"马尔科夫判别模型 [8]\"></a>马尔科夫判别模型 [8]</h5><!-- team7 -->\n<p>这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。<br>$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\(H_t^s\\)是在t轮对于槽类型s的假设的集合。</p>\n<p>另外，也是本文中比较新的一点是<strong>马尔科夫判别模型</strong>，也就是将生成模型和判别模型相结合：</p>\n<p>生成模型： \\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\)</p>\n<p>判别模型： \\(P(S_t | O_1^t) = f(O_1^t)\\)</p>\n<p>马尔科夫判别模型：\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\)</p>\n<p>在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作<strong>标签过耦合</strong>问题。为了解决这个问题，他们设计了一个2步训练法：</p>\n<ul>\n<li><p>第一步：训练一个传统的判别模型。</p>\n</li>\n<li><p>第二部：在第一步的基础上训练状态转移特征。</p>\n</li>\n</ul>\n<p>这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 </p>\n<h5 id=\"循环神经网络-9\"><a href=\"#循环神经网络-9\" class=\"headerlink\" title=\"循环神经网络 [9]\"></a>循环神经网络 [9]</h5><!-- team 3 -->\n<p>这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用&lt;slot>和&lt;value>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_dstc_rnn.png\" width=\"400\" align=\"center/\"><br></div>\n\n<p>通过上图的过程，我们可以得出 “Jamaican food”标记为 “s=food and v=jamaican”，若新的叙述为 “The Girton area” 其替换为&lt;slot>和&lt;value>的概率分布与前者类似，因此可以得出 “s=area and v=girton”。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。</p>\n<h5 id=\"基于规则的模型-10\"><a href=\"#基于规则的模型-10\" class=\"headerlink\" title=\"基于规则的模型 [10]\"></a>基于规则的模型 [10]</h5><!-- team 5 -->\n<p>这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，<strong>马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)</strong>。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 </p>\n<h5 id=\"知识驱动的基于规则的模型-11\"><a href=\"#知识驱动的基于规则的模型-11\" class=\"headerlink\" title=\"知识驱动的基于规则的模型 [11]\"></a>知识驱动的基于规则的模型 [11]</h5><!-- team 4 -->\n<p>这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。</p>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems<br>[2] Learning Dialogue History for Spoken Language Understanding.<br>[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.<br>[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.<br>[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.<br>[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.<br>[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.<br>[8] Markovian discriminative modeling for cross-domain dialog state tracking.<br>[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.<br>[10] A generalized rule based tracker for dialogue state tracking.<br>[11] Knowledge-based dialog state tracking.</p>\n","site":{"data":{}},"excerpt":"<p>自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。</p>","more":"<p>意图分类时一个典型的文本分类的问题，常用的方法如下：</p>\n<ul>\n<li>基于规则的方法<br>用户人工定义一些匹配规则进行分类。</li>\n<li>机器学习的方法<br>SVM, Decision Tree等等。</li>\n<li>深度学习的方法<br>目前更加推崇使用 End-to-End 的网络进行分类。</li>\n</ul>\n<p>最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。</p>\n<h2 id=\"中文数据集\"><a href=\"#中文数据集\" class=\"headerlink\" title=\"中文数据集\"></a>中文数据集</h2><h3 id=\"NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\"><a href=\"#NLPCC-2018-Task4-Spoken-Language-Understanding-in-Task-Oriented-Dialogue-Systems\" class=\"headerlink\" title=\"NLPCC 2018 Task4 - Spoken Language Understanding in Task-Oriented Dialogue Systems\"></a><a href=\"http://tcci.ccf.org.cn/conference/2018/taskdata.php\" target=\"_blank\" rel=\"noopener\">NLPCC 2018 Task4</a> - Spoken Language Understanding in Task-Oriented Dialogue Systems</h3><h4 id=\"数据描述-1\"><a href=\"#数据描述-1\" class=\"headerlink\" title=\"数据描述 [1]\"></a>数据描述 [1]</h4><p>这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 <strong>5.8K</strong> 次会话，总共有 <strong>26K</strong> 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。</p>\n<ul>\n<li>训练集：4705次会话, 21352次叙述。</li>\n<li>验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1）</li>\n</ul>\n<p>数据格式<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">session ID    用户query              意图                       语义槽标注</span><br><span class=\"line\">    1           打电话\t   phone_call.make_a_phone_call\t        打电话</span><br><span class=\"line\">    1\t      我想听美观\t        music.play\t          我想听&lt;song&gt;美观&lt;/song&gt;</span><br><span class=\"line\">    1\t      我想听什话\t        music.play\t          我想听&lt;song&gt;什话||神话&lt;/song&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"评估方法\"><a href=\"#评估方法\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>这个比赛主要有两个评估方法:</p>\n<ul>\n<li><p>意图分类，评估方法为F1值，具体的计算方法如下：</p>\n<div align=\"center\"><br>  <img src=\"/images/intent_f1.png\" width=\"500\"><br></div>\n</li>\n<li><p>意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。</p>\n</li>\n</ul>\n<h4 id=\"主要算法\"><a href=\"#主要算法\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_results.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h5 id=\"HLSTM-SLU-2\"><a href=\"#HLSTM-SLU-2\" class=\"headerlink\" title=\"HLSTM-SLU [2]\"></a>HLSTM-SLU [2]</h5><p>这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_hlstm.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。</p>\n<ul>\n<li>输入Bi-LSTM<br>输入：Character Embedding + POS + Domain<br>其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下：</li>\n</ul>\n<div align=\"center\"><br>    <img src=\"/images/intent_input.png\" width=\"500\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Session LSTM<br>输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。<br>输出：<strong>意图的类别</strong></p>\n</li>\n<li><p>输出Bi-LSTM<br>输入：Session LSTM + 输入Bi-LSTM<br>输出：<strong>槽位标注</strong></p>\n</li>\n</ul>\n<p>注：并没有直接使用LSTM的结果作为最终的结果，而是根据 <strong>CRF</strong> 预测最优的序列。</p>\n<p><strong>Trick</strong>: 使用 <strong>over sampling</strong> 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为94.19%，90.84%。</p>\n<h5 id=\"Sogou-3\"><a href=\"#Sogou-3\" class=\"headerlink\" title=\"Sogou [3]\"></a>Sogou [3]</h5><p>这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用<strong>基于规则</strong>的处理的方法进行标注；剩下的部分采用<strong>基于模型</strong>的方法，具体的模型方法分为5步：</p>\n<ol>\n<li><p>对query进行分词和词性标注（POS）。</p>\n</li>\n<li><p>寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。</p>\n</li>\n<li><p>槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。</p>\n</li>\n<li><p>槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。</p>\n</li>\n<li><p>意图分类：使用<strong>XGBoost</strong>的方法，根据word embedding，query长度，槽类别进行意图分类。</p>\n</li>\n</ol>\n<p>注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。</p>\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为96.11%，94.49%。</p>\n<h2 id=\"英文数据集\"><a href=\"#英文数据集\" class=\"headerlink\" title=\"英文数据集\"></a>英文数据集</h2><h3 id=\"Frame\"><a href=\"#Frame\" class=\"headerlink\" title=\"Frame\"></a><a href=\"https://datasets.maluuba.com/Frames/dl\" target=\"_blank\" rel=\"noopener\">Frame</a></h3><h4 id=\"数据描述-4\"><a href=\"#数据描述-4\" class=\"headerlink\" title=\"数据描述 [4]\"></a>数据描述 [4]</h4><p>这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 <strong>1369</strong> 个对话, 总共有 <strong>19986</strong> 轮。</p>\n<p><strong>数据格式</strong><br>每一次叙述都包含 ‘author’, ‘text’, ‘labels’, ‘timestamp’, ‘frames’(‘frame id’, ‘frame parent id’, ‘requests, binary questions, compare requests’, ‘info’), ‘db’字段。其中 ‘labels’记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， ‘info’字段主要为了标注对于槽位值是否为否定的。</p>\n<p><strong>Act类型</strong>：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye…..</p>\n<h4 id=\"评估方法-1\"><a href=\"#评估方法-1\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h4><p>微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示：</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p>这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。</p>\n<h4 id=\"主要算法-1\"><a href=\"#主要算法-1\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><h5 id=\"Baseline-4\"><a href=\"#Baseline-4\" class=\"headerlink\" title=\"Baseline [4]\"></a>Baseline [4]</h5><p>由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_frame_baseline.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>结果</strong>：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。</p>\n<h5 id=\"Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\"><a href=\"#Frame-Tracking-Model-for-Memory-Enhanced-Dialogue-Systems-5\" class=\"headerlink\" title=\"Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]\"></a>Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]</h5><p>微软的团队随后提出了一个新的模型来处理这个问题。</p>\n<h6 id=\"输入预处理\"><a href=\"#输入预处理\" class=\"headerlink\" title=\"输入预处理\"></a>输入预处理</h6><ul>\n<li><p>Token Encoding：每个词用trigrams的形式表示。如：“hello” -&gt; #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 </p>\n</li>\n<li><p>用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。</p>\n</li>\n<li><p>Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。</p>\n</li>\n<li><p>Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。</p>\n</li>\n</ul>\n<h6 id=\"模型输入\"><a href=\"#模型输入\" class=\"headerlink\" title=\"模型输入\"></a>模型输入</h6><ul>\n<li><p>当前轮之前所有的frames （Slot ID, Trigrams ID）</p>\n</li>\n<li><p>叙述 （Trigrams ID）</p>\n</li>\n<li><p>当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID）</p>\n</li>\n</ul>\n<h6 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h6><div align=\"center\"><br>    <img src=\"/images/intent_frame_model.png\" width=\"400\" align=\"center/\"><br></div>\n\n<ol>\n<li><p>对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\\(m_f\\) （|F| * 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \\(m_{asv}\\) （N * 256, N为act的数量）来表示acts；</p>\n</li>\n<li><p>通过计算 \\(m_f\\) 和 \\(m_{asv}\\) 的点乘的结果 \\(S_m\\) （N * |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \\(S_L\\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。</p>\n</li>\n<li><p>在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\\(p_{asv, f}\\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。</p>\n</li>\n<li><p>另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \\(p_{a, f}\\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。</p>\n</li>\n</ol>\n<p><strong>注</strong>：这里没有详细介绍实验的一些完善trick，如模型图中的\\(g_c\\)， \\(g_n\\)， \\(h_d\\)， \\(h_c\\)，详情请看论文。</p>\n<p><strong>结果</strong>：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。</p>\n<h3 id=\"DSTC-Dialog-State-Tracking-Challenge-6-7\"><a href=\"#DSTC-Dialog-State-Tracking-Challenge-6-7\" class=\"headerlink\" title=\"DSTC (Dialog State Tracking Challenge) [6, 7]\"></a><a href=\"https://www.microsoft.com/en-us/research/event/dialog-state-tracking-challenge/\" target=\"_blank\" rel=\"noopener\">DSTC</a> (Dialog State Tracking Challenge) [6, 7]</h3><h4 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h4><p>DSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。</p>\n<ul>\n<li><p>DSTC 1<br>这个数据集包括城市BUS的预定电话中的对话数据。<strong>12963</strong>轮训练数据，<strong>2485</strong>轮测试数据。</p>\n</li>\n<li><p>DSTC 2&amp;3<br>在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括<strong>2218</strong>轮训练数据，<strong>1117</strong>轮测试数据；DSTC3包括<strong>3235</strong>轮训练数据，<strong>2275</strong>轮测试数据。数据中的<code>semantics</code>字段会对对话中的槽slot和目的act标注。下面是一个数据样例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DSTC2 and DSTC3 (Training Set)</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: The north uh area</span><br><span class=\"line\">SYS: Which part of town?</span><br><span class=\"line\">USR: A cheap place <span class=\"keyword\">in</span> the north</span><br><span class=\"line\">SYS: Clown cafe is a cheap restaurant <span class=\"keyword\">in</span> the north part of town. USR: Do you have any others like that?</span><br><span class=\"line\">SYS: Galleria is another cheap restaurant <span class=\"keyword\">in</span> the north. USR: What is their phone number and address?</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DSTC 4<br>这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为：</p>\n<ul>\n<li>SVM分类模型<br>输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人）</li>\n<li>逻辑回归模型<br>输入：同上。</li>\n<li>随机森林模型<br>输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客）</li>\n</ul>\n</li>\n<li><p>DSTC 5<br>这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。</p>\n</li>\n<li><p>DSTC 6<br>这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。</p>\n</li>\n</ul>\n<h4 id=\"评估方法-（DSTC2-amp-3）\"><a href=\"#评估方法-（DSTC2-amp-3）\" class=\"headerlink\" title=\"评估方法 （DSTC2 &amp; 3）\"></a>评估方法 （DSTC2 &amp; 3）</h4><ul>\n<li>准确度：正确预测的轮数占数据总轮数的百分数。</li>\n<li>L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。</li>\n</ul>\n<h4 id=\"主要算法-2\"><a href=\"#主要算法-2\" class=\"headerlink\" title=\"主要算法\"></a>主要算法</h4><p>这里我们主要关注在DSTC3上的四个模型。</p>\n<h5 id=\"马尔科夫判别模型-8\"><a href=\"#马尔科夫判别模型-8\" class=\"headerlink\" title=\"马尔科夫判别模型 [8]\"></a>马尔科夫判别模型 [8]</h5><!-- team7 -->\n<p>这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。<br>$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\\(H_t^s\\)是在t轮对于槽类型s的假设的集合。</p>\n<p>另外，也是本文中比较新的一点是<strong>马尔科夫判别模型</strong>，也就是将生成模型和判别模型相结合：</p>\n<p>生成模型： \\(P(S_t) = k \\sum_{S_{t-1} \\in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \\)</p>\n<p>判别模型： \\(P(S_t | O_1^t) = f(O_1^t)\\)</p>\n<p>马尔科夫判别模型：\\((P(S_t | O_1^t) = \\sum_{S_{t-1} \\in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\\)</p>\n<p>在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作<strong>标签过耦合</strong>问题。为了解决这个问题，他们设计了一个2步训练法：</p>\n<ul>\n<li><p>第一步：训练一个传统的判别模型。</p>\n</li>\n<li><p>第二部：在第一步的基础上训练状态转移特征。</p>\n</li>\n</ul>\n<p>这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 </p>\n<h5 id=\"循环神经网络-9\"><a href=\"#循环神经网络-9\" class=\"headerlink\" title=\"循环神经网络 [9]\"></a>循环神经网络 [9]</h5><!-- team 3 -->\n<p>这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用&lt;slot>和&lt;value>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。</p>\n<div align=\"center\"><br>    <img src=\"/images/intent_dstc_rnn.png\" width=\"400\" align=\"center/\"><br></div>\n\n<p>通过上图的过程，我们可以得出 “Jamaican food”标记为 “s=food and v=jamaican”，若新的叙述为 “The Girton area” 其替换为&lt;slot>和&lt;value>的概率分布与前者类似，因此可以得出 “s=area and v=girton”。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。</p>\n<h5 id=\"基于规则的模型-10\"><a href=\"#基于规则的模型-10\" class=\"headerlink\" title=\"基于规则的模型 [10]\"></a>基于规则的模型 [10]</h5><!-- team 5 -->\n<p>这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，<strong>马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)</strong>。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 </p>\n<h5 id=\"知识驱动的基于规则的模型-11\"><a href=\"#知识驱动的基于规则的模型-11\" class=\"headerlink\" title=\"知识驱动的基于规则的模型 [11]\"></a>知识驱动的基于规则的模型 [11]</h5><!-- team 4 -->\n<p>这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。</p>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems<br>[2] Learning Dialogue History for Spoken Language Understanding.<br>[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.<br>[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.<br>[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.<br>[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.<br>[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.<br>[8] Markovian discriminative modeling for cross-domain dialog state tracking.<br>[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.<br>[10] A generalized rule based tracker for dialogue state tracking.<br>[11] Knowledge-based dialog state tracking.</p>"},{"title":"LeetCode_3Sum Closest","date":"2018-11-29T04:11:39.000Z","_content":"\n## [3Sum Closest](https://leetcode.com/problems/3sum-closest/)\n\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n（寻找数组中三个数的和为target的一个组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_16.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n排序后三个指针遍历数组。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            l = i + 1\n            r = n - 1\n            while l < r:\n                threesum = nums[l] + nums[r] + nums[i]\n                if threesum == target :\n                    return threesum\n\n                if abs(threesum - target) < abs(result - target):\n                \tresult = threesum\n\n                if threesum > target:\n                \tr -= 1\n                else:\n                \tl += 1\n                \n        return result\n```","source":"_posts/leetcode-3SumClosest.md","raw":"---\ntitle: LeetCode_3Sum Closest\ndate: 2018-11-29 12:11:39\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - two pointers\n---\n\n## [3Sum Closest](https://leetcode.com/problems/3sum-closest/)\n\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n（寻找数组中三个数的和为target的一个组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_16.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n排序后三个指针遍历数组。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            l = i + 1\n            r = n - 1\n            while l < r:\n                threesum = nums[l] + nums[r] + nums[i]\n                if threesum == target :\n                    return threesum\n\n                if abs(threesum - target) < abs(result - target):\n                \tresult = threesum\n\n                if threesum > target:\n                \tr -= 1\n                else:\n                \tl += 1\n                \n        return result\n```","slug":"leetcode-3SumClosest","published":1,"updated":"2018-11-29T05:53:13.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7ys0003kvpxhuo0wkh6","content":"<h2 id=\"3Sum-Closest\"><a href=\"#3Sum-Closest\" class=\"headerlink\" title=\"3Sum Closest\"></a><a href=\"https://leetcode.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">3Sum Closest</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br>（寻找数组中三个数的和为target的一个组合）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_16.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>排序后三个指针遍历数组。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        result = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n - <span class=\"number\">2</span>):</span><br><span class=\"line\">            l = i + <span class=\"number\">1</span></span><br><span class=\"line\">            r = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                threesum = nums[l] + nums[r] + nums[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum == target :</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(threesum - target) &lt; abs(result - target):</span><br><span class=\"line\">                \tresult = threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum &gt; target:</span><br><span class=\"line\">                \tr -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                \tl += <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"3Sum-Closest\"><a href=\"#3Sum-Closest\" class=\"headerlink\" title=\"3Sum Closest\"></a><a href=\"https://leetcode.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">3Sum Closest</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br>（寻找数组中三个数的和为target的一个组合）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_16.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>排序后三个指针遍历数组。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        result = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n - <span class=\"number\">2</span>):</span><br><span class=\"line\">            l = i + <span class=\"number\">1</span></span><br><span class=\"line\">            r = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                threesum = nums[l] + nums[r] + nums[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum == target :</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(threesum - target) &lt; abs(result - target):</span><br><span class=\"line\">                \tresult = threesum</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> threesum &gt; target:</span><br><span class=\"line\">                \tr -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                \tl += <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_3Sum","date":"2018-11-29T03:36:41.000Z","_content":"\n## [3Sum](https://leetcode.com/problems/3sum/)\n\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n（寻找数组中三个数的和为0的所有组合）\n\n<!--more-->\n\nNote:\nThe solution set must not contain duplicate triplets.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_15.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中`l , r = i + 1, len(nums) - 1,`，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\\\(O(n^2)\\\\)。\n  - i 去重： if i > 0 and nums[i] ==  nums[i-1]: continue\n  - l 去重： while l < r and nums[l] == nums[l-1]: l += 1\n  - r 去重： while l < r and nums[r] == nums[r+1]: r -= 1\n\n\n```python\nclass Solution(object):\n    def threeSum(self, nums):\n        result = []\n        nums.sort()\n        if len(nums) < 3:\n            return result\n\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]: continue\n            l, r = i + 1, len(nums) - 1\n            while l < r :\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    result.append([nums[i] ,nums[l] ,nums[r]])\n                    l += 1; r -= 1\n                    while l < r and nums[l] == nums[l - 1]: l += 1\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\n                elif s < 0 :\n                    l += 1\n                else:\n                    r -= 1\n        return result\n```","source":"_posts/leetcode-3Sum.md","raw":"---\ntitle: LeetCode_3Sum\ndate: 2018-11-29 11:36:41\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - two pointers\n---\n\n## [3Sum](https://leetcode.com/problems/3sum/)\n\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n（寻找数组中三个数的和为0的所有组合）\n\n<!--more-->\n\nNote:\nThe solution set must not contain duplicate triplets.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_15.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个指针\n最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中`l , r = i + 1, len(nums) - 1,`，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\\\(O(n^2)\\\\)。\n  - i 去重： if i > 0 and nums[i] ==  nums[i-1]: continue\n  - l 去重： while l < r and nums[l] == nums[l-1]: l += 1\n  - r 去重： while l < r and nums[r] == nums[r+1]: r -= 1\n\n\n```python\nclass Solution(object):\n    def threeSum(self, nums):\n        result = []\n        nums.sort()\n        if len(nums) < 3:\n            return result\n\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]: continue\n            l, r = i + 1, len(nums) - 1\n            while l < r :\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    result.append([nums[i] ,nums[l] ,nums[r]])\n                    l += 1; r -= 1\n                    while l < r and nums[l] == nums[l - 1]: l += 1\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\n                elif s < 0 :\n                    l += 1\n                else:\n                    r -= 1\n        return result\n```","slug":"leetcode-3Sum","published":1,"updated":"2018-11-29T04:12:07.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7z60007kvpxga59w8li","content":"<h2 id=\"3Sum\"><a href=\"#3Sum\" class=\"headerlink\" title=\"3Sum\"></a><a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">3Sum</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>（寻找数组中三个数的和为0的所有组合）</p>\n<a id=\"more\"></a>\n<p>Note:<br>The solution set must not contain duplicate triplets.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_15.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中<code>l , r = i + 1, len(nums) - 1,</code>，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\(O(n^2)\\)。</p>\n<ul>\n<li>i 去重： if i &gt; 0 and nums[i] ==  nums[i-1]: continue</li>\n<li>l 去重： while l &lt; r and nums[l] == nums[l-1]: l += 1</li>\n<li>r 去重： while l &lt; r and nums[r] == nums[r+1]: r -= 1</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums) - <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            l, r = i + <span class=\"number\">1</span>, len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r :</span><br><span class=\"line\">                s = nums[i] + nums[l] + nums[r]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    result.append([nums[i] ,nums[l] ,nums[r]])</span><br><span class=\"line\">                    l += <span class=\"number\">1</span>; r -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l - <span class=\"number\">1</span>]: l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[r] == nums[r + <span class=\"number\">1</span>]: r -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> s &lt; <span class=\"number\">0</span> :</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"3Sum\"><a href=\"#3Sum\" class=\"headerlink\" title=\"3Sum\"></a><a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">3Sum</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>（寻找数组中三个数的和为0的所有组合）</p>","more":"<p>Note:<br>The solution set must not contain duplicate triplets.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_15.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个指针\"><a href=\"#1-三个指针\" class=\"headerlink\" title=\"1. 三个指针\"></a>1. 三个指针</h3><p>最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中<code>l , r = i + 1, len(nums) - 1,</code>，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \\(O(n^2)\\)。</p>\n<ul>\n<li>i 去重： if i &gt; 0 and nums[i] ==  nums[i-1]: continue</li>\n<li>l 去重： while l &lt; r and nums[l] == nums[l-1]: l += 1</li>\n<li>r 去重： while l &lt; r and nums[r] == nums[r+1]: r -= 1</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums) - <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            l, r = i + <span class=\"number\">1</span>, len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l &lt; r :</span><br><span class=\"line\">                s = nums[i] + nums[l] + nums[r]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    result.append([nums[i] ,nums[l] ,nums[r]])</span><br><span class=\"line\">                    l += <span class=\"number\">1</span>; r -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l - <span class=\"number\">1</span>]: l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[r] == nums[r + <span class=\"number\">1</span>]: r -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> s &lt; <span class=\"number\">0</span> :</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_4Sum","date":"2018-12-04T10:56:06.000Z","_content":"\n## [4Sum](hhttps://leetcode.com/problems/4sum/)\n\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n（寻找数组中四个数的和为target的组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_18.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 四个指针\n可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\\\(O(n^3)\\\\)。\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()\n        for i in range(n):\n            for j in range(i-2):\n                k = j + 1\n                l = i - 1\n                while k < l:\n                    sum = nums[i] + nums[k] + nums[l] + nums[j]\n                    if sum == target:\n                        if [nums[j], nums[k], nums[l], nums[i]] not in result:\n                            result.append([nums[j], nums[k], nums[l], nums[i]])\n                        k+=1\n                        l-=1\n                    elif sum > target:\n                        l-=1\n                    else:\n                        k+=1\n        \n        return result\n```\n\n### 2. 两次 2Sum + Dict\n换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\\\(O(n^2)\\\\)。 \n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()   \n     \n        dict = {}\n        for i in range(n):\n            for j in range(i):\n                sum = nums[i] + nums[j]\n                if sum not in dict:\n                    dict[sum] = [[j, i]]\n                else:\n                    dict[sum].append([j, i])\n        \n        for i in range(n):\n            for j in range(i):\n                sum = target - nums[i] - nums[j]\n                if sum in dict:\n                    for list in dict[sum]:\n                        if list[0] > i and [nums[j],nums[i], nums[list[0]], nums[list[1]]] not in result:\n                            result.append([nums[j],nums[i],nums[list[0]],nums[list[1]]])\n\n        return result\n```\n\n### 3. 递归 N-sum\n这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 \n\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def findNsum(l, r, target, N, result, results):\n            if r-l+1<N or N<2 or nums[l]*N > target or nums[r]*N < target:\n                return\n            if N == 2:\n                while l < r:\n                    sum = nums[l] + nums[r]\n                    if sum == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l+=1\n                    elif sum < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else:\n                for i in range(l, r+1):\n                    if i == l or (i > l and nums[i-1] != nums[i]):\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\n            \n        nums.sort()\n        results = []\n        findNsum(0, len(nums)-1, target, 4, [], results)\n        \n        return results \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-4Sum.md","raw":"---\ntitle: LeetCode_4Sum\ndate: 2018-12-04 18:56:06\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - hash table\n  - two pointers\n---\n\n## [4Sum](hhttps://leetcode.com/problems/4sum/)\n\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n（寻找数组中四个数的和为target的组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_18.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 四个指针\n可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\\\(O(n^3)\\\\)。\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()\n        for i in range(n):\n            for j in range(i-2):\n                k = j + 1\n                l = i - 1\n                while k < l:\n                    sum = nums[i] + nums[k] + nums[l] + nums[j]\n                    if sum == target:\n                        if [nums[j], nums[k], nums[l], nums[i]] not in result:\n                            result.append([nums[j], nums[k], nums[l], nums[i]])\n                        k+=1\n                        l-=1\n                    elif sum > target:\n                        l-=1\n                    else:\n                        k+=1\n        \n        return result\n```\n\n### 2. 两次 2Sum + Dict\n换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\\\(O(n^2)\\\\)。 \n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        n = len(nums)\n        if n < 4:\n            return result\n        \n        nums.sort()   \n     \n        dict = {}\n        for i in range(n):\n            for j in range(i):\n                sum = nums[i] + nums[j]\n                if sum not in dict:\n                    dict[sum] = [[j, i]]\n                else:\n                    dict[sum].append([j, i])\n        \n        for i in range(n):\n            for j in range(i):\n                sum = target - nums[i] - nums[j]\n                if sum in dict:\n                    for list in dict[sum]:\n                        if list[0] > i and [nums[j],nums[i], nums[list[0]], nums[list[1]]] not in result:\n                            result.append([nums[j],nums[i],nums[list[0]],nums[list[1]]])\n\n        return result\n```\n\n### 3. 递归 N-sum\n这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 \n\n```python\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def findNsum(l, r, target, N, result, results):\n            if r-l+1<N or N<2 or nums[l]*N > target or nums[r]*N < target:\n                return\n            if N == 2:\n                while l < r:\n                    sum = nums[l] + nums[r]\n                    if sum == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l+=1\n                    elif sum < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else:\n                for i in range(l, r+1):\n                    if i == l or (i > l and nums[i-1] != nums[i]):\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\n            \n        nums.sort()\n        results = []\n        findNsum(0, len(nums)-1, target, 4, [], results)\n        \n        return results \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-4Sum","published":1,"updated":"2018-12-06T04:15:16.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zd0008kvpx8z1kwc3n","content":"<h2 id=\"4Sum\"><a href=\"#4Sum\" class=\"headerlink\" title=\"4Sum\"></a><a href=\"hhttps://leetcode.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">4Sum</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br>（寻找数组中四个数的和为target的组合）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_18.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-四个指针\"><a href=\"#1-四个指针\" class=\"headerlink\" title=\"1. 四个指针\"></a>1. 四个指针</h3><p>可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\(O(n^3)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-2</span>):</span><br><span class=\"line\">                k = j + <span class=\"number\">1</span></span><br><span class=\"line\">                l = i - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> k &lt; l:</span><br><span class=\"line\">                    sum = nums[i] + nums[k] + nums[l] + nums[j]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> [nums[j], nums[k], nums[l], nums[i]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j], nums[k], nums[l], nums[i]])</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &gt; target:</span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-两次-2Sum-Dict\"><a href=\"#2-两次-2Sum-Dict\" class=\"headerlink\" title=\"2. 两次 2Sum + Dict\"></a>2. 两次 2Sum + Dict</h3><p>换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()   </span><br><span class=\"line\">     </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = nums[i] + nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = [[j, i]]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum].append([j, i])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = target - nums[i] - nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> dict[sum]:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> list[<span class=\"number\">0</span>] &gt; i <span class=\"keyword\">and</span> [nums[j],nums[i], nums[list[<span class=\"number\">0</span>]], nums[list[<span class=\"number\">1</span>]]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j],nums[i],nums[list[<span class=\"number\">0</span>]],nums[list[<span class=\"number\">1</span>]]])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-递归-N-sum\"><a href=\"#3-递归-N-sum\" class=\"headerlink\" title=\"3. 递归 N-sum\"></a>3. 递归 N-sum</h3><p>这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNsum</span><span class=\"params\">(l, r, target, N, result, results)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> r-l+<span class=\"number\">1</span>&lt;N <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span> <span class=\"keyword\">or</span> nums[l]*N &gt; target <span class=\"keyword\">or</span> nums[r]*N &lt; target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> N == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                    sum = nums[l] + nums[r]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        results.append(result + [nums[l], nums[r]])</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            l+=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &lt; target:</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        r -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(l, r+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i == l <span class=\"keyword\">or</span> (i &gt; l <span class=\"keyword\">and</span> nums[i<span class=\"number\">-1</span>] != nums[i]):</span><br><span class=\"line\">                        findNsum(i+<span class=\"number\">1</span>, r, target-nums[i], N<span class=\"number\">-1</span>, result+[nums[i]], results)</span><br><span class=\"line\">            </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        findNsum(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>, target, <span class=\"number\">4</span>, [], results)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"4Sum\"><a href=\"#4Sum\" class=\"headerlink\" title=\"4Sum\"></a><a href=\"hhttps://leetcode.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">4Sum</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br>（寻找数组中四个数的和为target的组合）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_18.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-四个指针\"><a href=\"#1-四个指针\" class=\"headerlink\" title=\"1. 四个指针\"></a>1. 四个指针</h3><p>可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \\(O(n^3)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-2</span>):</span><br><span class=\"line\">                k = j + <span class=\"number\">1</span></span><br><span class=\"line\">                l = i - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> k &lt; l:</span><br><span class=\"line\">                    sum = nums[i] + nums[k] + nums[l] + nums[j]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> [nums[j], nums[k], nums[l], nums[i]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j], nums[k], nums[l], nums[i]])</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &gt; target:</span><br><span class=\"line\">                        l-=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        k+=<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-两次-2Sum-Dict\"><a href=\"#2-两次-2Sum-Dict\" class=\"headerlink\" title=\"2. 两次 2Sum + Dict\"></a>2. 两次 2Sum + Dict</h3><p>换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        </span><br><span class=\"line\">        nums.sort()   </span><br><span class=\"line\">     </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = nums[i] + nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = [[j, i]]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum].append([j, i])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                sum = target - nums[i] - nums[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> dict[sum]:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> list[<span class=\"number\">0</span>] &gt; i <span class=\"keyword\">and</span> [nums[j],nums[i], nums[list[<span class=\"number\">0</span>]], nums[list[<span class=\"number\">1</span>]]] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                            result.append([nums[j],nums[i],nums[list[<span class=\"number\">0</span>]],nums[list[<span class=\"number\">1</span>]]])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-递归-N-sum\"><a href=\"#3-递归-N-sum\" class=\"headerlink\" title=\"3. 递归 N-sum\"></a>3. 递归 N-sum</h3><p>这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNsum</span><span class=\"params\">(l, r, target, N, result, results)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> r-l+<span class=\"number\">1</span>&lt;N <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span> <span class=\"keyword\">or</span> nums[l]*N &gt; target <span class=\"keyword\">or</span> nums[r]*N &lt; target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> N == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                    sum = nums[l] + nums[r]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> sum == target:</span><br><span class=\"line\">                        results.append(result + [nums[l], nums[r]])</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] == nums[l<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            l+=<span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> sum &lt; target:</span><br><span class=\"line\">                        l += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        r -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(l, r+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i == l <span class=\"keyword\">or</span> (i &gt; l <span class=\"keyword\">and</span> nums[i<span class=\"number\">-1</span>] != nums[i]):</span><br><span class=\"line\">                        findNsum(i+<span class=\"number\">1</span>, r, target-nums[i], N<span class=\"number\">-1</span>, result+[nums[i]], results)</span><br><span class=\"line\">            </span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        findNsum(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>, target, <span class=\"number\">4</span>, [], results)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_4SumII","date":"2018-12-06T04:12:13.000Z","_content":"\n## [4SumII](https://leetcode.com/problems/4sum-ii/)\n\nGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.\n（寻找4个数组中四个数的和为0的组合个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_454.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 两次双重循环\n将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        \n        dict = {}\n        for i in range(n):\n            for j in range(n):\n                sum =  A[i] + B[j]\n                if sum not in dict:\n                    dict[sum] = 1\n                else:\n                    dict[sum] += 1\n        \n        result = 0\n        for i in range(n):\n            for j in range(n):\n                sum = C[i] + D[j]\n                if -sum in dict:\n                    result += dict[-sum]\n                \n        return result \n```\n\n### 1. 两次双重循环2\n将上述过程中的解法中的通过 index索引改为 python中的 **`in`** 遍历。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n\n        dict = {}\n        for a in A:\n            for b in B:\n                if a + b not in dict:\n                    dict[a + b] = 1\n                else:\n                    dict[a + b] += 1\n        \n        result = 0\n        for c in C:\n            for d in D:\n                if -c-d in dict:\n                    result += dict[-c-d]\n                \n        return result\n```\n","source":"_posts/leetcode-4SumII.md","raw":"---\ntitle: LeetCode_4SumII\ndate: 2018-12-06 12:12:13\ncategories: LeetCode\ntags: \n  - medium\n  - binary search\n  - hash table\n---\n\n## [4SumII](https://leetcode.com/problems/4sum-ii/)\n\nGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.\n（寻找4个数组中四个数的和为0的组合个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_454.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 两次双重循环\n将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\\\(O(n^2)\\\\)。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        \n        dict = {}\n        for i in range(n):\n            for j in range(n):\n                sum =  A[i] + B[j]\n                if sum not in dict:\n                    dict[sum] = 1\n                else:\n                    dict[sum] += 1\n        \n        result = 0\n        for i in range(n):\n            for j in range(n):\n                sum = C[i] + D[j]\n                if -sum in dict:\n                    result += dict[-sum]\n                \n        return result \n```\n\n### 1. 两次双重循环2\n将上述过程中的解法中的通过 index索引改为 python中的 **`in`** 遍历。\n```python\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n\n        dict = {}\n        for a in A:\n            for b in B:\n                if a + b not in dict:\n                    dict[a + b] = 1\n                else:\n                    dict[a + b] += 1\n        \n        result = 0\n        for c in C:\n            for d in D:\n                if -c-d in dict:\n                    result += dict[-c-d]\n                \n        return result\n```\n","slug":"leetcode-4SumII","published":1,"updated":"2018-12-06T06:42:22.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zf0009kvpxah1liqtj","content":"<h2 id=\"4SumII\"><a href=\"#4SumII\" class=\"headerlink\" title=\"4SumII\"></a><a href=\"https://leetcode.com/problems/4sum-ii/\" target=\"_blank\" rel=\"noopener\">4SumII</a></h2><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.<br>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.<br>（寻找4个数组中四个数的和为0的组合个数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_454.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-两次双重循环\"><a href=\"#1-两次双重循环\" class=\"headerlink\" title=\"1. 两次双重循环\"></a>1. 两次双重循环</h3><p>将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(A)</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum =  A[i] + B[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum = C[i] + D[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-sum]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-两次双重循环2\"><a href=\"#1-两次双重循环2\" class=\"headerlink\" title=\"1. 两次双重循环2\"></a>1. 两次双重循环2</h3><p>将上述过程中的解法中的通过 index索引改为 python中的 <strong><code>in</code></strong> 遍历。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> a + b <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[a + b] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[a + b] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> C:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> D:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -c-d <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-c-d]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"4SumII\"><a href=\"#4SumII\" class=\"headerlink\" title=\"4SumII\"></a><a href=\"https://leetcode.com/problems/4sum-ii/\" target=\"_blank\" rel=\"noopener\">4SumII</a></h2><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.<br>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.<br>（寻找4个数组中四个数的和为0的组合个数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_454.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-两次双重循环\"><a href=\"#1-两次双重循环\" class=\"headerlink\" title=\"1. 两次双重循环\"></a>1. 两次双重循环</h3><p>将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \\(O(n^2)\\)。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(A)</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum =  A[i] + B[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[sum] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[sum] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                sum = C[i] + D[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -sum <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-sum]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-两次双重循环2\"><a href=\"#1-两次双重循环2\" class=\"headerlink\" title=\"1. 两次双重循环2\"></a>1. 两次双重循环2</h3><p>将上述过程中的解法中的通过 index索引改为 python中的 <strong><code>in</code></strong> 遍历。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A, B, C, D)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type A: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type B: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type C: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type D: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> a + b <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    dict[a + b] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[a + b] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> C:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> D:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> -c-d <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result += dict[-c-d]</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Binary Tree Inorder Traversal","date":"2019-02-27T04:14:02.000Z","_content":"\n## [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\nGiven a binary tree, return the inorder traversal of its nodes' values.\n（中序遍历二叉树）\n\n<!--more-->\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_94.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def inorder(self, tree):\n        if not tree:\n            return\n        if tree.left:\n            self.inorder(tree.left)\n        self.results.append(tree.val)\n        if tree.right:\n            self.inorder(tree.right)\n    \n    def inorderTraversal(self, root: TreeNode) -> List[int]:   \n        if not root:\n            return []\n        self.results = []\n        self.inorder(root)\n        \n        return self.results\n```\n\n### 2. 迭代 & 栈\n不断将左子树加入到栈中，然后访问依次访问，最后再访问右子树。具体实现方法如下：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:   \n        if not root:\n            return []\n        results = []\n        stack = []\n        \n        p = root\n        while stack or p:\n            while p:\n                stack.append(p)\n                p = p.left\n            p = stack.pop()\n            results.append(p.val)\n            p = p.right\n            \n        return results\n```","source":"_posts/leetcode-BinaryTreeInorderTraversal.md","raw":"---\ntitle: LeetCode_Binary Tree Inorder Traversal\ndate: 2019-02-27 12:14:02\ncategories: LeetCode\ntags: \n  - medium\n  - hashed table\n  - stack\n  - tree\n---\n\n## [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\nGiven a binary tree, return the inorder traversal of its nodes' values.\n（中序遍历二叉树）\n\n<!--more-->\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_94.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def inorder(self, tree):\n        if not tree:\n            return\n        if tree.left:\n            self.inorder(tree.left)\n        self.results.append(tree.val)\n        if tree.right:\n            self.inorder(tree.right)\n    \n    def inorderTraversal(self, root: TreeNode) -> List[int]:   \n        if not root:\n            return []\n        self.results = []\n        self.inorder(root)\n        \n        return self.results\n```\n\n### 2. 迭代 & 栈\n不断将左子树加入到栈中，然后访问依次访问，最后再访问右子树。具体实现方法如下：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:   \n        if not root:\n            return []\n        results = []\n        stack = []\n        \n        p = root\n        while stack or p:\n            while p:\n                stack.append(p)\n                p = p.left\n            p = stack.pop()\n            results.append(p.val)\n            p = p.right\n            \n        return results\n```","slug":"leetcode-BinaryTreeInorderTraversal","published":1,"updated":"2019-02-27T04:55:20.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zi000ckvpxs4ggavy8","content":"<h2 id=\"Binary-Tree-Inorder-Traversal\"><a href=\"#Binary-Tree-Inorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Inorder Traversal\"></a><a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Inorder Traversal</a></h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.<br>（中序遍历二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_94.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(self, tree)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tree:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> tree.left:</span><br><span class=\"line\">            self.inorder(tree.left)</span><br><span class=\"line\">        self.results.append(tree.val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tree.right:</span><br><span class=\"line\">            self.inorder(tree.right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span>   </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        self.results = []</span><br><span class=\"line\">        self.inorder(root)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.results</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-迭代-amp-栈\"><a href=\"#2-迭代-amp-栈\" class=\"headerlink\" title=\"2. 迭代 &amp; 栈\"></a>2. 迭代 &amp; 栈</h3><p>不断将左子树加入到栈中，然后访问依次访问，最后再访问右子树。具体实现方法如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span>   </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = root</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">                stack.append(p)</span><br><span class=\"line\">                p = p.left</span><br><span class=\"line\">            p = stack.pop()</span><br><span class=\"line\">            results.append(p.val)</span><br><span class=\"line\">            p = p.right</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Binary-Tree-Inorder-Traversal\"><a href=\"#Binary-Tree-Inorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Inorder Traversal\"></a><a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Inorder Traversal</a></h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.<br>（中序遍历二叉树）</p>","more":"<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_94.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(self, tree)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tree:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> tree.left:</span><br><span class=\"line\">            self.inorder(tree.left)</span><br><span class=\"line\">        self.results.append(tree.val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tree.right:</span><br><span class=\"line\">            self.inorder(tree.right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span>   </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        self.results = []</span><br><span class=\"line\">        self.inorder(root)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.results</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-迭代-amp-栈\"><a href=\"#2-迭代-amp-栈\" class=\"headerlink\" title=\"2. 迭代 &amp; 栈\"></a>2. 迭代 &amp; 栈</h3><p>不断将左子树加入到栈中，然后访问依次访问，最后再访问右子树。具体实现方法如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span>   </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = root</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">                stack.append(p)</span><br><span class=\"line\">                p = p.left</span><br><span class=\"line\">            p = stack.pop()</span><br><span class=\"line\">            results.append(p.val)</span><br><span class=\"line\">            p = p.right</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Binary Tree Level Order Traversal","date":"2019-03-04T07:00:13.000Z","_content":"\n## [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n\nGiven a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n（按层遍历二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_102.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        results = [[root.val]]\n        \n        queue = []\n        queue.append([root])\n        while len(queue):\n            top = queue.pop()\n            \n            result = []\n            level_node = []\n            for node in top:\n                if node.left:\n                    level_node.append(node.left)\n                    result.append(node.left.val)\n                if node.right:\n                    level_node.append(node.right)\n                    result.append(node.right.val)\n            if result:\n                queue.insert(0, level_node)\n                results.append(result)\n           \n        return results\n```\n\n\n","source":"_posts/leetcode-BinaryTreeLevelOrderTraversal.md","raw":"---\ntitle: LeetCode_Binary Tree Level Order Traversal\ndate: 2019-03-04 15:00:13\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - bfs\n---\n\n## [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n\nGiven a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n（按层遍历二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_102.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        results = [[root.val]]\n        \n        queue = []\n        queue.append([root])\n        while len(queue):\n            top = queue.pop()\n            \n            result = []\n            level_node = []\n            for node in top:\n                if node.left:\n                    level_node.append(node.left)\n                    result.append(node.left.val)\n                if node.right:\n                    level_node.append(node.right)\n                    result.append(node.right.val)\n            if result:\n                queue.insert(0, level_node)\n                results.append(result)\n           \n        return results\n```\n\n\n","slug":"leetcode-BinaryTreeLevelOrderTraversal","published":1,"updated":"2019-03-04T09:08:44.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zk000dkvpxuoez5fmn","content":"<h2 id=\"Binary-Tree-Level-Order-Traversal\"><a href=\"#Binary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal\"></a><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Level Order Traversal</a></h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>（按层遍历二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_102.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        results = [[root.val]]</span><br><span class=\"line\">        </span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        queue.append([root])</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue):</span><br><span class=\"line\">            top = queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            result = []</span><br><span class=\"line\">            level_node = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> top:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    level_node.append(node.left)</span><br><span class=\"line\">                    result.append(node.left.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    level_node.append(node.right)</span><br><span class=\"line\">                    result.append(node.right.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> result:</span><br><span class=\"line\">                queue.insert(<span class=\"number\">0</span>, level_node)</span><br><span class=\"line\">                results.append(result)</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Binary-Tree-Level-Order-Traversal\"><a href=\"#Binary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal\"></a><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Level Order Traversal</a></h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>（按层遍历二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_102.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        results = [[root.val]]</span><br><span class=\"line\">        </span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        queue.append([root])</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue):</span><br><span class=\"line\">            top = queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            result = []</span><br><span class=\"line\">            level_node = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> top:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    level_node.append(node.left)</span><br><span class=\"line\">                    result.append(node.left.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    level_node.append(node.right)</span><br><span class=\"line\">                    result.append(node.right.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> result:</span><br><span class=\"line\">                queue.insert(<span class=\"number\">0</span>, level_node)</span><br><span class=\"line\">                results.append(result)</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Balanced Binary Tree","date":"2019-03-04T13:16:49.000Z","_content":"\n## [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)\n\nGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n（判断是否是平衡二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_110.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def depth(root):\n            if not root:\n                return 0\n            return 1 + max(depth(root.left), depth(root.right))\n        \n        if not root:\n            return True\n        \n        if abs(depth(root.left) - depth(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right) \n```","source":"_posts/leetcode-BalancedBinaryTree.md","raw":"---\ntitle: LeetCode_Balanced Binary Tree\ndate: 2019-03-04 21:16:49\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n---\n\n## [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)\n\nGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n（判断是否是平衡二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_110.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def depth(root):\n            if not root:\n                return 0\n            return 1 + max(depth(root.left), depth(root.right))\n        \n        if not root:\n            return True\n        \n        if abs(depth(root.left) - depth(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right) \n```","slug":"leetcode-BalancedBinaryTree","published":1,"updated":"2019-03-04T13:39:49.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zq000hkvpxdycfnvql","content":"<h2 id=\"Balanced-Binary-Tree\"><a href=\"#Balanced-Binary-Tree\" class=\"headerlink\" title=\"Balanced Binary Tree\"></a><a href=\"https://leetcode.com/problems/balanced-binary-tree/\" target=\"_blank\" rel=\"noopener\">Balanced Binary Tree</a></h2><p>Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>（判断是否是平衡二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_110.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">depth</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> + max(depth(root.left), depth(root.right))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> abs(depth(root.left) - depth(root.right)) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.isBalanced(root.left) <span class=\"keyword\">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Balanced-Binary-Tree\"><a href=\"#Balanced-Binary-Tree\" class=\"headerlink\" title=\"Balanced Binary Tree\"></a><a href=\"https://leetcode.com/problems/balanced-binary-tree/\" target=\"_blank\" rel=\"noopener\">Balanced Binary Tree</a></h2><p>Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>（判断是否是平衡二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_110.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">depth</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> + max(depth(root.left), depth(root.right))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> abs(depth(root.left) - depth(root.right)) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.isBalanced(root.left) <span class=\"keyword\">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_AddBinary","date":"2019-01-24T10:46:29.000Z","_content":"\n## [Add Binary](https://leetcode.com/problems/add-binary/)\n\nGiven two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.\n（二进制字符串加法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_67.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 十进制 & 二进制转换\n```python\nclass Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        a = int(a, 2)\n        b = int(b, 2)\n        return \"{:b}\".format(a + b) \n```","source":"_posts/leetcode-AddBinary.md","raw":"---\ntitle: LeetCode_AddBinary\ndate: 2019-01-24 18:46:29\ncategories: LeetCode\ntags: \n  - easy\n  - string\n  - math\n---\n\n## [Add Binary](https://leetcode.com/problems/add-binary/)\n\nGiven two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.\n（二进制字符串加法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_67.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 十进制 & 二进制转换\n```python\nclass Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        a = int(a, 2)\n        b = int(b, 2)\n        return \"{:b}\".format(a + b) \n```","slug":"leetcode-AddBinary","published":1,"updated":"2019-01-24T14:06:00.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zu000jkvpx76v7poz6","content":"<h2 id=\"Add-Binary\"><a href=\"#Add-Binary\" class=\"headerlink\" title=\"Add Binary\"></a><a href=\"https://leetcode.com/problems/add-binary/\" target=\"_blank\" rel=\"noopener\">Add Binary</a></h2><p>Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.<br>（二进制字符串加法）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_67.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-十进制-amp-二进制转换\"><a href=\"#1-十进制-amp-二进制转换\" class=\"headerlink\" title=\"1. 十进制 &amp; 二进制转换\"></a>1. 十进制 &amp; 二进制转换</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addBinary</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type a: str</span></span><br><span class=\"line\"><span class=\"string\">        :type b: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        a = int(a, <span class=\"number\">2</span>)</span><br><span class=\"line\">        b = int(b, <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;:b&#125;\"</span>.format(a + b)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Add-Binary\"><a href=\"#Add-Binary\" class=\"headerlink\" title=\"Add Binary\"></a><a href=\"https://leetcode.com/problems/add-binary/\" target=\"_blank\" rel=\"noopener\">Add Binary</a></h2><p>Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.<br>（二进制字符串加法）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_67.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-十进制-amp-二进制转换\"><a href=\"#1-十进制-amp-二进制转换\" class=\"headerlink\" title=\"1. 十进制 &amp; 二进制转换\"></a>1. 十进制 &amp; 二进制转换</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addBinary</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type a: str</span></span><br><span class=\"line\"><span class=\"string\">        :type b: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        a = int(a, <span class=\"number\">2</span>)</span><br><span class=\"line\">        b = int(b, <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;:b&#125;\"</span>.format(a + b)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Binary Tree Zigzag Level Order Traversal","date":"2019-03-04T07:53:15.000Z","_content":"\n## [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n\nGiven a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).（按层从左到右->c从右到左遍历二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_103.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n与上一题类似，按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列，并在偶数行翻转（变形之后的BFS）。\n\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        results = [[root.val]]\n        queue = [[root]]\n        \n        reverse_flag = 1\n        while len(queue) > 0:\n            top = queue.pop()\n            \n            result = []\n            level_node = []\n\n            for node in top:\n                if node.left:\n                    level_node.append(node.left)\n                    result.append(node.left.val)\n                if node.right:\n                    level_node.append(node.right)\n                    result.append(node.right.val)\n        \n            if result:\n                if reverse_flag:\n                    result.reverse()\n    \n                reverse_flag = 1 - reverse_flag\n                queue.insert(0, level_node)\n                results.append(result)\n            \n        return results\n```\n\n\n\n","source":"_posts/leetcode-BinaryTreeZigzagLevelOrderTraversal.md","raw":"---\ntitle: LeetCode_Binary Tree Zigzag Level Order Traversal\ndate: 2019-03-04 15:53:15\ncategories: LeetCode\ntags: \n  - medium\n  - stack\n  - tree\n  - bfs\n---\n\n## [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n\nGiven a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).（按层从左到右->c从右到左遍历二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_103.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n与上一题类似，按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列，并在偶数行翻转（变形之后的BFS）。\n\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        results = [[root.val]]\n        queue = [[root]]\n        \n        reverse_flag = 1\n        while len(queue) > 0:\n            top = queue.pop()\n            \n            result = []\n            level_node = []\n\n            for node in top:\n                if node.left:\n                    level_node.append(node.left)\n                    result.append(node.left.val)\n                if node.right:\n                    level_node.append(node.right)\n                    result.append(node.right.val)\n        \n            if result:\n                if reverse_flag:\n                    result.reverse()\n    \n                reverse_flag = 1 - reverse_flag\n                queue.insert(0, level_node)\n                results.append(result)\n            \n        return results\n```\n\n\n\n","slug":"leetcode-BinaryTreeZigzagLevelOrderTraversal","published":1,"updated":"2019-03-04T09:09:02.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht7zx000okvpxbil6d12r","content":"<h2 id=\"Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"#Binary-Tree-Zigzag-Level-Order-Traversal\" class=\"headerlink\" title=\"Binary Tree Zigzag Level Order Traversal\"></a><a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Zigzag Level Order Traversal</a></h2><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).（按层从左到右-&gt;c从右到左遍历二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_103.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>与上一题类似，按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列，并在偶数行翻转（变形之后的BFS）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        results = [[root.val]]</span><br><span class=\"line\">        queue = [[root]]</span><br><span class=\"line\">        </span><br><span class=\"line\">        reverse_flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            top = queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            result = []</span><br><span class=\"line\">            level_node = []</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> top:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    level_node.append(node.left)</span><br><span class=\"line\">                    result.append(node.left.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    level_node.append(node.right)</span><br><span class=\"line\">                    result.append(node.right.val)</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> result:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> reverse_flag:</span><br><span class=\"line\">                    result.reverse()</span><br><span class=\"line\">    </span><br><span class=\"line\">                reverse_flag = <span class=\"number\">1</span> - reverse_flag</span><br><span class=\"line\">                queue.insert(<span class=\"number\">0</span>, level_node)</span><br><span class=\"line\">                results.append(result)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"#Binary-Tree-Zigzag-Level-Order-Traversal\" class=\"headerlink\" title=\"Binary Tree Zigzag Level Order Traversal\"></a><a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Zigzag Level Order Traversal</a></h2><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).（按层从左到右-&gt;c从右到左遍历二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_103.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>与上一题类似，按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列，并在偶数行翻转（变形之后的BFS）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        results = [[root.val]]</span><br><span class=\"line\">        queue = [[root]]</span><br><span class=\"line\">        </span><br><span class=\"line\">        reverse_flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            top = queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            result = []</span><br><span class=\"line\">            level_node = []</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> top:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    level_node.append(node.left)</span><br><span class=\"line\">                    result.append(node.left.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    level_node.append(node.right)</span><br><span class=\"line\">                    result.append(node.right.val)</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> result:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> reverse_flag:</span><br><span class=\"line\">                    result.reverse()</span><br><span class=\"line\">    </span><br><span class=\"line\">                reverse_flag = <span class=\"number\">1</span> - reverse_flag</span><br><span class=\"line\">                queue.insert(<span class=\"number\">0</span>, level_node)</span><br><span class=\"line\">                results.append(result)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Climbing Stairs","date":"2019-02-16T11:14:45.000Z","_content":"\n## [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\n\nYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? (Note: Given n will be a positive integer.)\n（爬楼梯问题）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_70.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n```python\nclass Solution:\n    def climbStairs(self, n: 'int') -> 'int':\n        dp = [1 for _ in range(n+1)]\n\n        for i in range(2, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n\n        return dp[n]\n```\n","source":"_posts/leetcode-ClimbingStairs.md","raw":"---\ntitle: LeetCode_Climbing Stairs\ndate: 2019-02-16 19:14:45\ncategories: LeetCode\ntags: \n  - easy\n  - dynamic programming\n---\n\n## [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\n\nYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? (Note: Given n will be a positive integer.)\n（爬楼梯问题）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_70.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n```python\nclass Solution:\n    def climbStairs(self, n: 'int') -> 'int':\n        dp = [1 for _ in range(n+1)]\n\n        for i in range(2, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n\n        return dp[n]\n```\n","slug":"leetcode-ClimbingStairs","published":1,"updated":"2019-02-16T12:36:56.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht802000qkvpxe6vtf17e","content":"<h2 id=\"Climbing-Stairs\"><a href=\"#Climbing-Stairs\" class=\"headerlink\" title=\"Climbing Stairs\"></a><a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">Climbing Stairs</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? (Note: Given n will be a positive integer.)<br>（爬楼梯问题）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_70.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climbStairs</span><span class=\"params\">(self, n: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        dp = [<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Climbing-Stairs\"><a href=\"#Climbing-Stairs\" class=\"headerlink\" title=\"Climbing Stairs\"></a><a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">Climbing Stairs</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? (Note: Given n will be a positive integer.)<br>（爬楼梯问题）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_70.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climbStairs</span><span class=\"params\">(self, n: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        dp = [<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Binary Tree Level Order Traversal II","date":"2019-03-04T09:44:11.000Z","_content":"\n## [Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)\n\nGiven a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n（从底向上按层遍历二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_107.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。(只需要把Binary Tree Level Order Traversal结果倒叙存储即可) 具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        results = [[root.val]]\n        \n        queue = []\n        queue.append([root])\n        while len(queue):\n            top = queue.pop()\n            \n            result = []\n            level_node = []\n            for node in top:\n                if node.left:\n                    level_node.append(node.left)\n                    result.append(node.left.val)\n                if node.right:\n                    level_node.append(node.right)\n                    result.append(node.right.val)\n            if result:\n                queue.insert(0, level_node)\n                results.insert(0, result)\n           \n        return results\n```","source":"_posts/leetcode-BinaryTreeLevelOrderTraversalII.md","raw":"---\ntitle: LeetCode_Binary Tree Level Order Traversal II\ndate: 2019-03-04 17:44:11\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - bfs\n---\n\n## [Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)\n\nGiven a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n（从底向上按层遍历二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_107.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。(只需要把Binary Tree Level Order Traversal结果倒叙存储即可) 具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        results = [[root.val]]\n        \n        queue = []\n        queue.append([root])\n        while len(queue):\n            top = queue.pop()\n            \n            result = []\n            level_node = []\n            for node in top:\n                if node.left:\n                    level_node.append(node.left)\n                    result.append(node.left.val)\n                if node.right:\n                    level_node.append(node.right)\n                    result.append(node.right.val)\n            if result:\n                queue.insert(0, level_node)\n                results.insert(0, result)\n           \n        return results\n```","slug":"leetcode-BinaryTreeLevelOrderTraversalII","published":1,"updated":"2019-03-04T10:49:53.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht805000ukvpxagmy4m62","content":"<h2 id=\"Binary-Tree-Level-Order-Traversal-II\"><a href=\"#Binary-Tree-Level-Order-Traversal-II\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal II\"></a><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal-ii/\" target=\"_blank\" rel=\"noopener\">Binary Tree Level Order Traversal II</a></h2><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).<br>（从底向上按层遍历二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_107.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。(只需要把Binary Tree Level Order Traversal结果倒叙存储即可) 具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        results = [[root.val]]</span><br><span class=\"line\">        </span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        queue.append([root])</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue):</span><br><span class=\"line\">            top = queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            result = []</span><br><span class=\"line\">            level_node = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> top:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    level_node.append(node.left)</span><br><span class=\"line\">                    result.append(node.left.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    level_node.append(node.right)</span><br><span class=\"line\">                    result.append(node.right.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> result:</span><br><span class=\"line\">                queue.insert(<span class=\"number\">0</span>, level_node)</span><br><span class=\"line\">                results.insert(<span class=\"number\">0</span>, result)</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Binary-Tree-Level-Order-Traversal-II\"><a href=\"#Binary-Tree-Level-Order-Traversal-II\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal II\"></a><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal-ii/\" target=\"_blank\" rel=\"noopener\">Binary Tree Level Order Traversal II</a></h2><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).<br>（从底向上按层遍历二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_107.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。(只需要把Binary Tree Level Order Traversal结果倒叙存储即可) 具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        results = [[root.val]]</span><br><span class=\"line\">        </span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        queue.append([root])</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue):</span><br><span class=\"line\">            top = queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            result = []</span><br><span class=\"line\">            level_node = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> top:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    level_node.append(node.left)</span><br><span class=\"line\">                    result.append(node.left.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    level_node.append(node.right)</span><br><span class=\"line\">                    result.append(node.right.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> result:</span><br><span class=\"line\">                queue.insert(<span class=\"number\">0</span>, level_node)</span><br><span class=\"line\">                results.insert(<span class=\"number\">0</span>, result)</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Combination Sum","date":"2018-12-25T09:15:38.000Z","_content":"\n# [Combination Sum](https://leetcode.com/problems/combination-sum/)\n\nGiven a **set** of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates **unlimited** number of times.\n（从集合中挑选和为特定值的数字组合，同一元素可选多次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_39.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 回溯法\n在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。\n\n```python\nclass Solution:\n    def backtracking(self, re, candidates, target):\n        if target == 0:\n        \tself.result.append(list(re))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tcontinue\n        \t\tre.append(candidates[i])\n        \t\tself.backtracking(re, candidates[i:], target - candidates[i])\n        \t\tre.pop()\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n        self.backtracking([], candidates, target)\n        \n        return self.result\n```\n","source":"_posts/leetcode-CombinationSum.md","raw":"---\ntitle: LeetCode_Combination Sum\ndate: 2018-12-25 17:15:38\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n---\n\n# [Combination Sum](https://leetcode.com/problems/combination-sum/)\n\nGiven a **set** of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates **unlimited** number of times.\n（从集合中挑选和为特定值的数字组合，同一元素可选多次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_39.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 回溯法\n在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。\n\n```python\nclass Solution:\n    def backtracking(self, re, candidates, target):\n        if target == 0:\n        \tself.result.append(list(re))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tcontinue\n        \t\tre.append(candidates[i])\n        \t\tself.backtracking(re, candidates[i:], target - candidates[i])\n        \t\tre.pop()\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n        self.backtracking([], candidates, target)\n        \n        return self.result\n```\n","slug":"leetcode-CombinationSum","published":1,"updated":"2018-12-25T10:20:54.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht80a000wkvpxk4vbooim","content":"<h1 id=\"Combination-Sum\"><a href=\"#Combination-Sum\" class=\"headerlink\" title=\"Combination Sum\"></a><a href=\"https://leetcode.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">Combination Sum</a></h1><p>Given a <strong>set</strong> of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates <strong>unlimited</strong> number of times.<br>（从集合中挑选和为特定值的数字组合，同一元素可选多次）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_39.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span>:</span><br><span class=\"line\">        \tself.result.append(list(re))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">        \t\tre.append(candidates[i])</span><br><span class=\"line\">        \t\tself.backtracking(re, candidates[i:], target - candidates[i])</span><br><span class=\"line\">        \t\tre.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">        self.backtracking([], candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"Combination-Sum\"><a href=\"#Combination-Sum\" class=\"headerlink\" title=\"Combination Sum\"></a><a href=\"https://leetcode.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">Combination Sum</a></h1><p>Given a <strong>set</strong> of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates <strong>unlimited</strong> number of times.<br>（从集合中挑选和为特定值的数字组合，同一元素可选多次）</p>","more":"<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_39.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span>:</span><br><span class=\"line\">        \tself.result.append(list(re))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">        \t\tre.append(candidates[i])</span><br><span class=\"line\">        \t\tself.backtracking(re, candidates[i:], target - candidates[i])</span><br><span class=\"line\">        \t\tre.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">        self.backtracking([], candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Construct Binary Tree from Inorder and Postorder Traversal","date":"2019-03-04T09:38:13.000Z","_content":"\n## [Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\nGiven inorder and postorder traversal of a tree, construct the binary tree.\n（根据中序遍历和后序遍历构建二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_106.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归构建二叉树，首先根据后序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root\n```\n\n","source":"_posts/leetcode-ConstructBinaryTreefromInorderandPostorderTraversal.md","raw":"---\ntitle: LeetCode_Construct Binary Tree from Inorder and Postorder Traversal\ndate: 2019-03-04 17:38:13\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - tree\n  - dfs\n---\n\n## [Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\nGiven inorder and postorder traversal of a tree, construct the binary tree.\n（根据中序遍历和后序遍历构建二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_106.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归构建二叉树，首先根据后序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root\n```\n\n","slug":"leetcode-ConstructBinaryTreefromInorderandPostorderTraversal","published":1,"updated":"2019-03-04T09:40:32.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht80c000ykvpxa6pw69b5","content":"<h2 id=\"Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\"><a href=\"#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\" class=\"headerlink\" title=\"Construct Binary Tree from Inorder and Postorder Traversal\"></a><a href=\"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p>Given inorder and postorder traversal of a tree, construct the binary tree.<br>（根据中序遍历和后序遍历构建二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_106.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归构建二叉树，首先根据后序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> inorder:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        root = TreeNode(postorder[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        index = inorder.index(postorder[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = self.buildTree(inorder[:index], postorder[:index])</span><br><span class=\"line\">        root.right = self.buildTree(inorder[index+<span class=\"number\">1</span>:], postorder[index:<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\"><a href=\"#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\" class=\"headerlink\" title=\"Construct Binary Tree from Inorder and Postorder Traversal\"></a><a href=\"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p>Given inorder and postorder traversal of a tree, construct the binary tree.<br>（根据中序遍历和后序遍历构建二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_106.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归构建二叉树，首先根据后序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> inorder:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        root = TreeNode(postorder[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        index = inorder.index(postorder[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = self.buildTree(inorder[:index], postorder[:index])</span><br><span class=\"line\">        root.right = self.buildTree(inorder[index+<span class=\"number\">1</span>:], postorder[index:<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Combinations","date":"2019-02-23T05:58:02.000Z","_content":"\n## [Combinations](https://leetcode.com/problems/combinations/)\n\nGiven two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n（列举 C_n^k 的所有组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_77.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n具体实现方法如下：\n\n```python\nclass Solution:\n    def dfs(self, i, re_list):\n        if len(re_list) == self.k:\n            self.result.append(re_list)\n        for j in range(i, self.n + 1):   \n            self.dfs(j + 1, re_list + [j])\n\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.n = n\n        self.k = k\n        self.result = []\n        self.dfs(1, [])\n        return self.result\n```","source":"_posts/leetcode-Combinations.md","raw":"---\ntitle: LeetCode_Combinations\ndate: 2019-02-23 13:58:02\ncategories: LeetCode\ntags: \n  - medium\n  - back tracking\n---\n\n## [Combinations](https://leetcode.com/problems/combinations/)\n\nGiven two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n（列举 C_n^k 的所有组合）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_77.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n具体实现方法如下：\n\n```python\nclass Solution:\n    def dfs(self, i, re_list):\n        if len(re_list) == self.k:\n            self.result.append(re_list)\n        for j in range(i, self.n + 1):   \n            self.dfs(j + 1, re_list + [j])\n\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.n = n\n        self.k = k\n        self.result = []\n        self.dfs(1, [])\n        return self.result\n```","slug":"leetcode-Combinations","published":1,"updated":"2019-02-23T06:29:57.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht80f0012kvpxnu78t3q6","content":"<h2 id=\"Combinations\"><a href=\"#Combinations\" class=\"headerlink\" title=\"Combinations\"></a><a href=\"https://leetcode.com/problems/combinations/\" target=\"_blank\" rel=\"noopener\">Combinations</a></h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.<br>（列举 C_n^k 的所有组合）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_77.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, re_list)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(re_list) == self.k:</span><br><span class=\"line\">            self.result.append(re_list)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, self.n + <span class=\"number\">1</span>):   </span><br><span class=\"line\">            self.dfs(j + <span class=\"number\">1</span>, re_list + [j])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        self.n = n</span><br><span class=\"line\">        self.k = k</span><br><span class=\"line\">        self.result = []</span><br><span class=\"line\">        self.dfs(<span class=\"number\">1</span>, [])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Combinations\"><a href=\"#Combinations\" class=\"headerlink\" title=\"Combinations\"></a><a href=\"https://leetcode.com/problems/combinations/\" target=\"_blank\" rel=\"noopener\">Combinations</a></h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.<br>（列举 C_n^k 的所有组合）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_77.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, re_list)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(re_list) == self.k:</span><br><span class=\"line\">            self.result.append(re_list)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, self.n + <span class=\"number\">1</span>):   </span><br><span class=\"line\">            self.dfs(j + <span class=\"number\">1</span>, re_list + [j])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        self.n = n</span><br><span class=\"line\">        self.k = k</span><br><span class=\"line\">        self.result = []</span><br><span class=\"line\">        self.dfs(<span class=\"number\">1</span>, [])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Construct Binary Tree from Preorder and Inorder Traversal","date":"2019-03-04T09:19:19.000Z","_content":"\n## [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\nGiven preorder and inorder traversal of a tree, construct the binary tree.\n（根据先序遍历和中序遍历构建二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_105.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归构建二叉树，首先根据先序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:index+1], inorder[:index])\n        root.right = self.buildTree(preorder[index+1:], inorder[index+1:])\n        \n        return root\n```\n\n","source":"_posts/leetcode-ConstructBinaryTreefromPreorderandInorderTraversal.md","raw":"---\ntitle: LeetCode_Construct Binary Tree from Preorder and Inorder Traversal\ndate: 2019-03-04 17:19:19\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - tree\n  - dfs\n---\n\n## [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\nGiven preorder and inorder traversal of a tree, construct the binary tree.\n（根据先序遍历和中序遍历构建二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_105.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归构建二叉树，首先根据先序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:index+1], inorder[:index])\n        root.right = self.buildTree(preorder[index+1:], inorder[index+1:])\n        \n        return root\n```\n\n","slug":"leetcode-ConstructBinaryTreefromPreorderandInorderTraversal","published":1,"updated":"2019-03-04T09:38:52.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht80i0015kvpxa3ps0hpx","content":"<h2 id=\"Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\" class=\"headerlink\" title=\"Construct Binary Tree from Preorder and Inorder Traversal\"></a><a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">Construct Binary Tree from Preorder and Inorder Traversal</a></h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>（根据先序遍历和中序遍历构建二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_105.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归构建二叉树，首先根据先序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> preorder:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        root = TreeNode(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">        index = inorder.index(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = self.buildTree(preorder[<span class=\"number\">1</span>:index+<span class=\"number\">1</span>], inorder[:index])</span><br><span class=\"line\">        root.right = self.buildTree(preorder[index+<span class=\"number\">1</span>:], inorder[index+<span class=\"number\">1</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\" class=\"headerlink\" title=\"Construct Binary Tree from Preorder and Inorder Traversal\"></a><a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">Construct Binary Tree from Preorder and Inorder Traversal</a></h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>（根据先序遍历和中序遍历构建二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_105.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归构建二叉树，首先根据先序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> preorder:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        root = TreeNode(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">        index = inorder.index(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = self.buildTree(preorder[<span class=\"number\">1</span>:index+<span class=\"number\">1</span>], inorder[:index])</span><br><span class=\"line\">        root.right = self.buildTree(preorder[index+<span class=\"number\">1</span>:], inorder[index+<span class=\"number\">1</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Container With Most Water","date":"2018-11-28T03:20:13.000Z","_content":"\n## [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)\n\nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and n is at least 2.\n（求最大矩形面积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_11.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力轮循\n双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        n = len(height)\n        for j in range(n):\n            for i in range(j):\n                height_min = min(height[i], height[j])\n                area = max(area, height_min*(j-i))\n                \n        return area\n```\n\n### 2. 头尾指针\n在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        p_left = 0\n        p_right = len(height) - 1\n        \n        while p_left < p_right:\n            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))\n            if height[p_left] < height[p_right]:\n                p_left += 1\n            else:\n                p_right -= 1\n                \n        return area\n```","source":"_posts/leetcode-ContainerWithMostWater.md","raw":"---\ntitle: LeetCode_Container With Most Water\ndate: 2018-11-28 11:20:13\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - two pointers\n---\n\n## [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)\n\nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and n is at least 2.\n（求最大矩形面积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_11.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力轮循\n双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        n = len(height)\n        for j in range(n):\n            for i in range(j):\n                height_min = min(height[i], height[j])\n                area = max(area, height_min*(j-i))\n                \n        return area\n```\n\n### 2. 头尾指针\n在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        area = 0\n        p_left = 0\n        p_right = len(height) - 1\n        \n        while p_left < p_right:\n            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))\n            if height[p_left] < height[p_right]:\n                p_left += 1\n            else:\n                p_right -= 1\n                \n        return area\n```","slug":"leetcode-ContainerWithMostWater","published":1,"updated":"2019-01-10T14:26:39.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht80n0019kvpxyc60z9pv","content":"<h2 id=\"Container-With-Most-Water\"><a href=\"#Container-With-Most-Water\" class=\"headerlink\" title=\"Container With Most Water\"></a><a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">Container With Most Water</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and n is at least 2.<br>（求最大矩形面积）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_11.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力轮循\"><a href=\"#1-暴力轮循\" class=\"headerlink\" title=\"1. 暴力轮循\"></a>1. 暴力轮循</h3><p>双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\(O(n^2)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(height)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">                height_min = min(height[i], height[j])</span><br><span class=\"line\">                area = max(area, height_min*(j-i))</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-头尾指针\"><a href=\"#2-头尾指针\" class=\"headerlink\" title=\"2. 头尾指针\"></a>2. 头尾指针</h3><p>在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        p_left = <span class=\"number\">0</span></span><br><span class=\"line\">        p_right = len(height) - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_left &lt; p_right:</span><br><span class=\"line\">            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[p_left] &lt; height[p_right]:</span><br><span class=\"line\">                p_left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Container-With-Most-Water\"><a href=\"#Container-With-Most-Water\" class=\"headerlink\" title=\"Container With Most Water\"></a><a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">Container With Most Water</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and n is at least 2.<br>（求最大矩形面积）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_11.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力轮循\"><a href=\"#1-暴力轮循\" class=\"headerlink\" title=\"1. 暴力轮循\"></a>1. 暴力轮循</h3><p>双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \\(O(n^2)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(height)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">                height_min = min(height[i], height[j])</span><br><span class=\"line\">                area = max(area, height_min*(j-i))</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-头尾指针\"><a href=\"#2-头尾指针\" class=\"headerlink\" title=\"2. 头尾指针\"></a>2. 头尾指针</h3><p>在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        p_left = <span class=\"number\">0</span></span><br><span class=\"line\">        p_right = len(height) - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_left &lt; p_right:</span><br><span class=\"line\">            area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[p_left] &lt; height[p_right]:</span><br><span class=\"line\">                p_left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Convert Sorted Array to Binary Search Tree","date":"2019-03-04T09:52:56.000Z","_content":"\n## [Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\n\nGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n（将有序数组转换为平衡二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_108.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n根据平衡二叉树的定义：height差不大于1。因此从中间开始建立为根节点，左边的有序数组构建左子树，右边的有序数组构建右子树。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        if not nums:\n            return None\n        \n        n = len(nums)\n        root = TreeNode(nums[n//2])\n        root.left = self.sortedArrayToBST(nums[:n//2])\n        root.right = self.sortedArrayToBST(nums[n//2+1:])\n        \n        return root\n```","source":"_posts/leetcode-ConvertSortedArraytoBinarySearchTree.md","raw":"---\ntitle: LeetCode_Convert Sorted Array to Binary Search Tree\ndate: 2019-03-04 17:52:56\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n---\n\n## [Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\n\nGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n（将有序数组转换为平衡二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_108.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n根据平衡二叉树的定义：height差不大于1。因此从中间开始建立为根节点，左边的有序数组构建左子树，右边的有序数组构建右子树。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        if not nums:\n            return None\n        \n        n = len(nums)\n        root = TreeNode(nums[n//2])\n        root.left = self.sortedArrayToBST(nums[:n//2])\n        root.right = self.sortedArrayToBST(nums[n//2+1:])\n        \n        return root\n```","slug":"leetcode-ConvertSortedArraytoBinarySearchTree","published":1,"updated":"2019-03-04T13:23:39.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81b001bkvpxy0ksk1gq","content":"<h2 id=\"Convert-Sorted-Array-to-Binary-Search-Tree\"><a href=\"#Convert-Sorted-Array-to-Binary-Search-Tree\" class=\"headerlink\" title=\"Convert Sorted Array to Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Convert Sorted Array to Binary Search Tree</a></h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>（将有序数组转换为平衡二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_108.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>根据平衡二叉树的定义：height差不大于1。因此从中间开始建立为根节点，左边的有序数组构建左子树，右边的有序数组构建右子树。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        root = TreeNode(nums[n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        root.left = self.sortedArrayToBST(nums[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        root.right = self.sortedArrayToBST(nums[n//<span class=\"number\">2</span>+<span class=\"number\">1</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Convert-Sorted-Array-to-Binary-Search-Tree\"><a href=\"#Convert-Sorted-Array-to-Binary-Search-Tree\" class=\"headerlink\" title=\"Convert Sorted Array to Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Convert Sorted Array to Binary Search Tree</a></h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>（将有序数组转换为平衡二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_108.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>根据平衡二叉树的定义：height差不大于1。因此从中间开始建立为根节点，左边的有序数组构建左子树，右边的有序数组构建右子树。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        root = TreeNode(nums[n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        root.left = self.sortedArrayToBST(nums[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        root.right = self.sortedArrayToBST(nums[n//<span class=\"number\">2</span>+<span class=\"number\">1</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Count and Say","date":"2018-12-24T10:15:52.000Z","_content":"\n## [Count and Say](https://leetcode.com/problems/count-and-say/)\n\n读字符串\n\n<!--more-->\n\n这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：\n1. n = 1时，返回‘1’\n2. n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’\n3. n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’\n3. n时，对n-1的对应的字符串读取的过程进行输出。\n\n这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：\n\n### 1. 递归\n```python\nclass Solution:\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return '1'\n\n        last_string = self.countAndSay(n-1)\n\n        match_char = last_string[0]\n        match_count = 0\n\n        result_string = ''\n\n        for char in last_string:\n            if char == match_char:\n                match_count += 1\n            else:\n                result_string += str(match_count) + match_char\n                match_char = char\n                match_count = 1\n        \n        result_string += str(match_count) + match_char\n        return result_string\n```","source":"_posts/leetcode-CountandSay.md","raw":"---\ntitle: LeetCode_Count and Say\ndate: 2018-12-24 18:15:52\ncategories: LeetCode\ntags: \n  - easy\n  - string\n---\n\n## [Count and Say](https://leetcode.com/problems/count-and-say/)\n\n读字符串\n\n<!--more-->\n\n这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：\n1. n = 1时，返回‘1’\n2. n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’\n3. n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’\n3. n时，对n-1的对应的字符串读取的过程进行输出。\n\n这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：\n\n### 1. 递归\n```python\nclass Solution:\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return '1'\n\n        last_string = self.countAndSay(n-1)\n\n        match_char = last_string[0]\n        match_count = 0\n\n        result_string = ''\n\n        for char in last_string:\n            if char == match_char:\n                match_count += 1\n            else:\n                result_string += str(match_count) + match_char\n                match_char = char\n                match_count = 1\n        \n        result_string += str(match_count) + match_char\n        return result_string\n```","slug":"leetcode-CountandSay","published":1,"updated":"2019-01-25T02:48:30.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81h001fkvpx1w7z6d9i","content":"<h2 id=\"Count-and-Say\"><a href=\"#Count-and-Say\" class=\"headerlink\" title=\"Count and Say\"></a><a href=\"https://leetcode.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">Count and Say</a></h2><p>读字符串</p>\n<a id=\"more\"></a>\n<p>这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：</p>\n<ol>\n<li>n = 1时，返回‘1’</li>\n<li>n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’</li>\n<li>n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’</li>\n<li>n时，对n-1的对应的字符串读取的过程进行输出。</li>\n</ol>\n<p>这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：</p>\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">        last_string = self.countAndSay(n<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        match_char = last_string[<span class=\"number\">0</span>]</span><br><span class=\"line\">        match_count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        result_string = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> last_string:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char == match_char:</span><br><span class=\"line\">                match_count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result_string += str(match_count) + match_char</span><br><span class=\"line\">                match_char = char</span><br><span class=\"line\">                match_count = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result_string += str(match_count) + match_char</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result_string</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Count-and-Say\"><a href=\"#Count-and-Say\" class=\"headerlink\" title=\"Count and Say\"></a><a href=\"https://leetcode.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">Count and Say</a></h2><p>读字符串</p>","more":"<p>这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的：</p>\n<ol>\n<li>n = 1时，返回‘1’</li>\n<li>n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’</li>\n<li>n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’</li>\n<li>n时，对n-1的对应的字符串读取的过程进行输出。</li>\n</ol>\n<p>这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下：</p>\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">        last_string = self.countAndSay(n<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        match_char = last_string[<span class=\"number\">0</span>]</span><br><span class=\"line\">        match_count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        result_string = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> last_string:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char == match_char:</span><br><span class=\"line\">                match_count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result_string += str(match_count) + match_char</span><br><span class=\"line\">                match_char = char</span><br><span class=\"line\">                match_count = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        result_string += str(match_count) + match_char</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result_string</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Convert Sorted List to Binary Search Tree","date":"2019-03-04T12:44:50.000Z","_content":"\n## [Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\nGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n（将有序链表转换为平衡二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_109.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n首先获得链表的长度，然后根据中序遍历的过程不断地建立二叉树，这是一种自底向上的方法。先递归构建左子树，一直到左叶子节点，左叶子节点对应的就是链表的第一个元素，生成左叶子节点之后移动链表当前指针。其时间复杂度为O(n), 具体实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def dfs(self, head, count):\n            if count <= 0:\n                return None\n             \n            left = self.dfs(head, count // 2)\n            root = TreeNode(self.curNode.val)\n            self.curNode = self.curNode.next\n            right = self.dfs(self.curNode, count - count // 2 - 1)\n            \n            root.left = left\n            root.right = right       \n            return root \n        \n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        \n        p = head\n        count = 0\n        while p:\n            count += 1\n            p = p.next\n        \n        self.curNode = head\n        return self.dfs(head, count)\n```\n\n","source":"_posts/leetcode-ConvertSortedListtoBinarySearchTree.md","raw":"---\ntitle: LeetCode_Convert Sorted List to Binary Search Tree\ndate: 2019-03-04 20:44:50\ncategories: LeetCode\ntags: \n  - easy\n  - linked list\n  - dfs\n---\n\n## [Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\nGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n（将有序链表转换为平衡二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_109.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n首先获得链表的长度，然后根据中序遍历的过程不断地建立二叉树，这是一种自底向上的方法。先递归构建左子树，一直到左叶子节点，左叶子节点对应的就是链表的第一个元素，生成左叶子节点之后移动链表当前指针。其时间复杂度为O(n), 具体实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def dfs(self, head, count):\n            if count <= 0:\n                return None\n             \n            left = self.dfs(head, count // 2)\n            root = TreeNode(self.curNode.val)\n            self.curNode = self.curNode.next\n            right = self.dfs(self.curNode, count - count // 2 - 1)\n            \n            root.left = left\n            root.right = right       \n            return root \n        \n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        \n        p = head\n        count = 0\n        while p:\n            count += 1\n            p = p.next\n        \n        self.curNode = head\n        return self.dfs(head, count)\n```\n\n","slug":"leetcode-ConvertSortedListtoBinarySearchTree","published":1,"updated":"2019-03-04T13:15:40.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81i001ikvpxfc35m3zs","content":"<h2 id=\"Convert-Sorted-List-to-Binary-Search-Tree\"><a href=\"#Convert-Sorted-List-to-Binary-Search-Tree\" class=\"headerlink\" title=\"Convert Sorted List to Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Convert Sorted List to Binary Search Tree</a></h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>（将有序链表转换为平衡二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_109.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>首先获得链表的长度，然后根据中序遍历的过程不断地建立二叉树，这是一种自底向上的方法。先递归构建左子树，一直到左叶子节点，左叶子节点对应的就是链表的第一个元素，生成左叶子节点之后移动链表当前指针。其时间复杂度为O(n), 具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, head, count)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">             </span><br><span class=\"line\">            left = self.dfs(head, count // <span class=\"number\">2</span>)</span><br><span class=\"line\">            root = TreeNode(self.curNode.val)</span><br><span class=\"line\">            self.curNode = self.curNode.next</span><br><span class=\"line\">            right = self.dfs(self.curNode, count - count // <span class=\"number\">2</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            root.left = left</span><br><span class=\"line\">            root.right = right       </span><br><span class=\"line\">            <span class=\"keyword\">return</span> root </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedListToBST</span><span class=\"params\">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.curNode = head</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.dfs(head, count)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Convert-Sorted-List-to-Binary-Search-Tree\"><a href=\"#Convert-Sorted-List-to-Binary-Search-Tree\" class=\"headerlink\" title=\"Convert Sorted List to Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Convert Sorted List to Binary Search Tree</a></h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>（将有序链表转换为平衡二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_109.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>首先获得链表的长度，然后根据中序遍历的过程不断地建立二叉树，这是一种自底向上的方法。先递归构建左子树，一直到左叶子节点，左叶子节点对应的就是链表的第一个元素，生成左叶子节点之后移动链表当前指针。其时间复杂度为O(n), 具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, head, count)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">             </span><br><span class=\"line\">            left = self.dfs(head, count // <span class=\"number\">2</span>)</span><br><span class=\"line\">            root = TreeNode(self.curNode.val)</span><br><span class=\"line\">            self.curNode = self.curNode.next</span><br><span class=\"line\">            right = self.dfs(self.curNode, count - count // <span class=\"number\">2</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            root.left = left</span><br><span class=\"line\">            root.right = right       </span><br><span class=\"line\">            <span class=\"keyword\">return</span> root </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedListToBST</span><span class=\"params\">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.curNode = head</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.dfs(head, count)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Distinct Subsequences","date":"2019-03-05T07:26:36.000Z","_content":"\n## [Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)\n\nGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\n（有效子序列个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_115.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n这个题也可以看做一个字符串匹配的问题，一般都可以使用动态规划求解。具体实现过程如下：\n\n```python\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n    \t# t 为空，则删除 s 中的所有元素，只有一种方案。\n        if not t:\n            return 1\n        # t 不为空，s 为空，不可能匹配。\n        if not s:\n            return 0\n        \n        m, n = len(s), len(t)\n        dp = [[0]* (n + 1) for _ in range(m + 1)]\n\n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = 0\n                elif j == 0:\n                    dp[i][j] = 1\n                else:\n                \t# s[i-1] 不参与匹配 \n                    dp[i][j] = dp[i-1][j]\n                    # s[i-1] 和 t[j-1] 匹配 \n                    if s[i-1] == t[j-1]:\n                        dp[i][j] += dp[i-1][j-1]\n                        \n        return dp[m][n]\n```\n","source":"_posts/leetcode-DistinctSubsequences.md","raw":"---\ntitle: LeetCode_Distinct Subsequences\ndate: 2019-03-05 15:26:36\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n---\n\n## [Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)\n\nGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\n（有效子序列个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_115.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n这个题也可以看做一个字符串匹配的问题，一般都可以使用动态规划求解。具体实现过程如下：\n\n```python\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n    \t# t 为空，则删除 s 中的所有元素，只有一种方案。\n        if not t:\n            return 1\n        # t 不为空，s 为空，不可能匹配。\n        if not s:\n            return 0\n        \n        m, n = len(s), len(t)\n        dp = [[0]* (n + 1) for _ in range(m + 1)]\n\n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = 0\n                elif j == 0:\n                    dp[i][j] = 1\n                else:\n                \t# s[i-1] 不参与匹配 \n                    dp[i][j] = dp[i-1][j]\n                    # s[i-1] 和 t[j-1] 匹配 \n                    if s[i-1] == t[j-1]:\n                        dp[i][j] += dp[i-1][j-1]\n                        \n        return dp[m][n]\n```\n","slug":"leetcode-DistinctSubsequences","published":1,"updated":"2019-03-05T09:00:29.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81l001mkvpxjyw2e4ct","content":"<h2 id=\"Distinct-Subsequences\"><a href=\"#Distinct-Subsequences\" class=\"headerlink\" title=\"Distinct Subsequences\"></a><a href=\"https://leetcode.com/problems/distinct-subsequences/\" target=\"_blank\" rel=\"noopener\">Distinct Subsequences</a></h2><p>Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).<br>（有效子序列个数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_115.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这个题也可以看做一个字符串匹配的问题，一般都可以使用动态规划求解。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numDistinct</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class=\"line\">    \t<span class=\"comment\"># t 为空，则删除 s 中的所有元素，只有一种方案。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># t 不为空，s 为空，不可能匹配。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        m, n = len(s), len(t)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>]* (n + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">and</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                \t<span class=\"comment\"># s[i-1] 不参与匹配 </span></span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                    <span class=\"comment\"># s[i-1] 和 t[j-1] 匹配 </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> s[i<span class=\"number\">-1</span>] == t[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                        dp[i][j] += dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Distinct-Subsequences\"><a href=\"#Distinct-Subsequences\" class=\"headerlink\" title=\"Distinct Subsequences\"></a><a href=\"https://leetcode.com/problems/distinct-subsequences/\" target=\"_blank\" rel=\"noopener\">Distinct Subsequences</a></h2><p>Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).<br>（有效子序列个数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_115.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这个题也可以看做一个字符串匹配的问题，一般都可以使用动态规划求解。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numDistinct</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class=\"line\">    \t<span class=\"comment\"># t 为空，则删除 s 中的所有元素，只有一种方案。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># t 不为空，s 为空，不可能匹配。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        m, n = len(s), len(t)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>]* (n + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">and</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                \t<span class=\"comment\"># s[i-1] 不参与匹配 </span></span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                    <span class=\"comment\"># s[i-1] 和 t[j-1] 匹配 </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> s[i<span class=\"number\">-1</span>] == t[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                        dp[i][j] += dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Decode Ways","date":"2019-02-26T12:23:16.000Z","_content":"\n## [Decode Ways](https://leetcode.com/problems/decode-ways/)\n\nA message containing letters from A-Z is mapped to 1-26, Given a non-empty string containing only digits, determine the total number of ways to decode it.\n（解码方法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_91.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n对于扫描的第 i 个数字时，我们考虑其单独 mapping（dp[i] += dp[i-1]），或者 i-1 和 i 一起 mapping（dp[i] += dp[i-2]）。具体实现过程如下：\n\n```python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n    \tif s == '' or s == '0':\n            return 0\n        n = len(s)\n        dp = [1] + [0] * n\n\n        for i in range(1, n+1):\n        \t#  if int(s[i-1:i]) != 0:\n            if int(s[i-1:i]) >=1 and int(s[i-1:i]) <= 9:\n                dp[i] += dp[i-1]\n            if i>=2 and int(s[i-2:i]) >=10 and int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n\n        return dp[-1]\n```","source":"_posts/leetcode-DecodeWays.md","raw":"---\ntitle: LeetCode_Decode Ways\ndate: 2019-02-26 20:23:16\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - dynamic programming\n---\n\n## [Decode Ways](https://leetcode.com/problems/decode-ways/)\n\nA message containing letters from A-Z is mapped to 1-26, Given a non-empty string containing only digits, determine the total number of ways to decode it.\n（解码方法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_91.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n对于扫描的第 i 个数字时，我们考虑其单独 mapping（dp[i] += dp[i-1]），或者 i-1 和 i 一起 mapping（dp[i] += dp[i-2]）。具体实现过程如下：\n\n```python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n    \tif s == '' or s == '0':\n            return 0\n        n = len(s)\n        dp = [1] + [0] * n\n\n        for i in range(1, n+1):\n        \t#  if int(s[i-1:i]) != 0:\n            if int(s[i-1:i]) >=1 and int(s[i-1:i]) <= 9:\n                dp[i] += dp[i-1]\n            if i>=2 and int(s[i-2:i]) >=10 and int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n\n        return dp[-1]\n```","slug":"leetcode-DecodeWays","published":1,"updated":"2019-02-26T13:02:24.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81o001pkvpxuail8flb","content":"<h2 id=\"Decode-Ways\"><a href=\"#Decode-Ways\" class=\"headerlink\" title=\"Decode Ways\"></a><a href=\"https://leetcode.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">Decode Ways</a></h2><p>A message containing letters from A-Z is mapped to 1-26, Given a non-empty string containing only digits, determine the total number of ways to decode it.<br>（解码方法）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_91.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>对于扫描的第 i 个数字时，我们考虑其单独 mapping（dp[i] += dp[i-1]），或者 i-1 和 i 一起 mapping（dp[i] += dp[i-2]）。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numDecodings</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> s == <span class=\"string\">''</span> <span class=\"keyword\">or</span> s == <span class=\"string\">'0'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        dp = [<span class=\"number\">1</span>] + [<span class=\"number\">0</span>] * n</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        \t<span class=\"comment\">#  if int(s[i-1:i]) != 0:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> int(s[i<span class=\"number\">-1</span>:i]) &gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> int(s[i<span class=\"number\">-1</span>:i]) &lt;= <span class=\"number\">9</span>:</span><br><span class=\"line\">                dp[i] += dp[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> int(s[i<span class=\"number\">-2</span>:i]) &gt;=<span class=\"number\">10</span> <span class=\"keyword\">and</span> int(s[i<span class=\"number\">-2</span>:i]) &lt;= <span class=\"number\">26</span>:</span><br><span class=\"line\">                dp[i] += dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Decode-Ways\"><a href=\"#Decode-Ways\" class=\"headerlink\" title=\"Decode Ways\"></a><a href=\"https://leetcode.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">Decode Ways</a></h2><p>A message containing letters from A-Z is mapped to 1-26, Given a non-empty string containing only digits, determine the total number of ways to decode it.<br>（解码方法）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_91.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>对于扫描的第 i 个数字时，我们考虑其单独 mapping（dp[i] += dp[i-1]），或者 i-1 和 i 一起 mapping（dp[i] += dp[i-2]）。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numDecodings</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> s == <span class=\"string\">''</span> <span class=\"keyword\">or</span> s == <span class=\"string\">'0'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        dp = [<span class=\"number\">1</span>] + [<span class=\"number\">0</span>] * n</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        \t<span class=\"comment\">#  if int(s[i-1:i]) != 0:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> int(s[i<span class=\"number\">-1</span>:i]) &gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> int(s[i<span class=\"number\">-1</span>:i]) &lt;= <span class=\"number\">9</span>:</span><br><span class=\"line\">                dp[i] += dp[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> int(s[i<span class=\"number\">-2</span>:i]) &gt;=<span class=\"number\">10</span> <span class=\"keyword\">and</span> int(s[i<span class=\"number\">-2</span>:i]) &lt;= <span class=\"number\">26</span>:</span><br><span class=\"line\">                dp[i] += dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Divide Two Integers","date":"2018-12-18T08:41:42.000Z","_content":"\n## [Divide Two Integers](https://leetcode.com/problems/divide-two-integers/)\n\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.\n（非乘 除 取模 方法实现除法）\n\n<!--more-->\n\nNote:\n- Both dividend and divisor will be 32-bit signed integers.\n- The divisor will never be 0.\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_29.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 减法实现除法\n这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地**加大除数**来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：\n\n```python\nclass Solution:\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if (dividend < 0 and divisor < 0) or (dividend > 0 and divisor > 0):\n            flag = 1\n        else:\n            flag = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        re = 0\n        i = 1\n        new_divisor = divisor\n        while dividend >= new_divisor:\n            re += i\n            dividend -= new_divisor\n            \n            new_divisor += new_divisor\n            i += i\n            if dividend < new_divisor:\n                new_divisor = divisor\n                i = 1\n         \n        if flag < 0:\n            return -re\n        else:\n            MAX = pow(2, 31) - 1\n            return min(re, MAX)\n```","source":"_posts/leetcode-DivideTwoIntegers.md","raw":"---\ntitle: LeetCode_Divide Two Integers\ndate: 2018-12-18 16:41:42\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - binary search\n---\n\n## [Divide Two Integers](https://leetcode.com/problems/divide-two-integers/)\n\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.\n（非乘 除 取模 方法实现除法）\n\n<!--more-->\n\nNote:\n- Both dividend and divisor will be 32-bit signed integers.\n- The divisor will never be 0.\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_29.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 减法实现除法\n这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地**加大除数**来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：\n\n```python\nclass Solution:\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if (dividend < 0 and divisor < 0) or (dividend > 0 and divisor > 0):\n            flag = 1\n        else:\n            flag = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        re = 0\n        i = 1\n        new_divisor = divisor\n        while dividend >= new_divisor:\n            re += i\n            dividend -= new_divisor\n            \n            new_divisor += new_divisor\n            i += i\n            if dividend < new_divisor:\n                new_divisor = divisor\n                i = 1\n         \n        if flag < 0:\n            return -re\n        else:\n            MAX = pow(2, 31) - 1\n            return min(re, MAX)\n```","slug":"leetcode-DivideTwoIntegers","published":1,"updated":"2018-12-18T10:20:29.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81s001tkvpxfjyfj0lg","content":"<h2 id=\"Divide-Two-Integers\"><a href=\"#Divide-Two-Integers\" class=\"headerlink\" title=\"Divide Two Integers\"></a><a href=\"https://leetcode.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">Divide Two Integers</a></h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.<br>（非乘 除 取模 方法实现除法）</p>\n<a id=\"more\"></a>\n<p>Note:</p>\n<ul>\n<li>Both dividend and divisor will be 32-bit signed integers.</li>\n<li>The divisor will never be 0.</li>\n<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_29.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-减法实现除法\"><a href=\"#1-减法实现除法\" class=\"headerlink\" title=\"1. 减法实现除法\"></a>1. 减法实现除法</h3><p>这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地<strong>加大除数</strong>来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, dividend, divisor)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type dividend: int</span></span><br><span class=\"line\"><span class=\"string\">        :type divisor: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &lt; <span class=\"number\">0</span>) <span class=\"keyword\">or</span> (dividend &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &gt; <span class=\"number\">0</span>):</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flag = <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dividend = abs(dividend)</span><br><span class=\"line\">        divisor = abs(divisor)</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        new_divisor = divisor</span><br><span class=\"line\">        <span class=\"keyword\">while</span> dividend &gt;= new_divisor:</span><br><span class=\"line\">            re += i</span><br><span class=\"line\">            dividend -= new_divisor</span><br><span class=\"line\">            </span><br><span class=\"line\">            new_divisor += new_divisor</span><br><span class=\"line\">            i += i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dividend &lt; new_divisor:</span><br><span class=\"line\">                new_divisor = divisor</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -re</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(re, MAX)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Divide-Two-Integers\"><a href=\"#Divide-Two-Integers\" class=\"headerlink\" title=\"Divide Two Integers\"></a><a href=\"https://leetcode.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">Divide Two Integers</a></h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.<br>（非乘 除 取模 方法实现除法）</p>","more":"<p>Note:</p>\n<ul>\n<li>Both dividend and divisor will be 32-bit signed integers.</li>\n<li>The divisor will never be 0.</li>\n<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_29.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-减法实现除法\"><a href=\"#1-减法实现除法\" class=\"headerlink\" title=\"1. 减法实现除法\"></a>1. 减法实现除法</h3><p>这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地<strong>加大除数</strong>来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, dividend, divisor)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type dividend: int</span></span><br><span class=\"line\"><span class=\"string\">        :type divisor: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &lt; <span class=\"number\">0</span>) <span class=\"keyword\">or</span> (dividend &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> divisor &gt; <span class=\"number\">0</span>):</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flag = <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dividend = abs(dividend)</span><br><span class=\"line\">        divisor = abs(divisor)</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        new_divisor = divisor</span><br><span class=\"line\">        <span class=\"keyword\">while</span> dividend &gt;= new_divisor:</span><br><span class=\"line\">            re += i</span><br><span class=\"line\">            dividend -= new_divisor</span><br><span class=\"line\">            </span><br><span class=\"line\">            new_divisor += new_divisor</span><br><span class=\"line\">            i += i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dividend &lt; new_divisor:</span><br><span class=\"line\">                new_divisor = divisor</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -re</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(re, MAX)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Edit Distance","date":"2019-02-19T09:31:37.000Z","_content":"\n## [Edit Distance](https://leetcode.com/problems/edit-distance/)\n\nGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\n（计算编辑距离）\n\n<!--more-->\n\nYou have the following 3 operations permitted on a word:\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_72.png\" width = \"500\" align=center/>\n</div>\n\n\n### 动态规划\n很明显的动态规划的题目，问题就在于需要分类讨论。具体的讨论情况在code的注释部分有详细解释。\n\n```python\nclass Solution:\n    def minDistance(self, word1: 'str', word2: 'str') -> 'int':\n        len1 = len(word1)\n        len2 = len(word2)\n        \n        # Create a table to store results of subproblems \n        dp = [[0 for _ in range(len1 + 1)] for _ in range(len2 + 1)]\n        \n        for i in range(len2 + 1):\n            for j in range(len1 + 1):\n            \t# word1 is empty, insert all chars\n                if i == 0:\n                    dp[i][j] = j\n                # word2 is empty, remove all chars\n                elif j == 0:\n                    dp[i][j] = i\n                # last chars are same\n                elif word2[i-1] == word1[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                # last chars are different, min(insert, remove, replace)\n                else:\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\n                \n        # return dp[len2][len1]\n        return dp[-1][-1]\n```","source":"_posts/leetcode-EditDistance.md","raw":"---\ntitle: LeetCode_Edit Distance\ndate: 2019-02-19 17:31:37\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n---\n\n## [Edit Distance](https://leetcode.com/problems/edit-distance/)\n\nGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\n（计算编辑距离）\n\n<!--more-->\n\nYou have the following 3 operations permitted on a word:\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_72.png\" width = \"500\" align=center/>\n</div>\n\n\n### 动态规划\n很明显的动态规划的题目，问题就在于需要分类讨论。具体的讨论情况在code的注释部分有详细解释。\n\n```python\nclass Solution:\n    def minDistance(self, word1: 'str', word2: 'str') -> 'int':\n        len1 = len(word1)\n        len2 = len(word2)\n        \n        # Create a table to store results of subproblems \n        dp = [[0 for _ in range(len1 + 1)] for _ in range(len2 + 1)]\n        \n        for i in range(len2 + 1):\n            for j in range(len1 + 1):\n            \t# word1 is empty, insert all chars\n                if i == 0:\n                    dp[i][j] = j\n                # word2 is empty, remove all chars\n                elif j == 0:\n                    dp[i][j] = i\n                # last chars are same\n                elif word2[i-1] == word1[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                # last chars are different, min(insert, remove, replace)\n                else:\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\n                \n        # return dp[len2][len1]\n        return dp[-1][-1]\n```","slug":"leetcode-EditDistance","published":1,"updated":"2019-02-19T16:16:18.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81v001wkvpxhapcw10w","content":"<h2 id=\"Edit-Distance\"><a href=\"#Edit-Distance\" class=\"headerlink\" title=\"Edit Distance\"></a><a href=\"https://leetcode.com/problems/edit-distance/\" target=\"_blank\" rel=\"noopener\">Edit Distance</a></h2><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.<br>（计算编辑距离）</p>\n<a id=\"more\"></a>\n<p>You have the following 3 operations permitted on a word:</p>\n<ol>\n<li>Insert a character</li>\n<li>Delete a character</li>\n<li>Replace a character</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_72.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>很明显的动态规划的题目，问题就在于需要分类讨论。具体的讨论情况在code的注释部分有详细解释。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDistance</span><span class=\"params\">(self, word1: <span class=\"string\">'str'</span>, word2: <span class=\"string\">'str'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        len1 = len(word1)</span><br><span class=\"line\">        len2 = len(word2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># Create a table to store results of subproblems </span></span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len1 + <span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len2 + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len2 + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len1 + <span class=\"number\">1</span>):</span><br><span class=\"line\">            \t<span class=\"comment\"># word1 is empty, insert all chars</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = j</span><br><span class=\"line\">                <span class=\"comment\"># word2 is empty, remove all chars</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = i</span><br><span class=\"line\">                <span class=\"comment\"># last chars are same</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> word2[i<span class=\"number\">-1</span>] == word1[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"comment\"># last chars are different, min(insert, remove, replace)</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span> + min(dp[i][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j], dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>])</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"comment\"># return dp[len2][len1]</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Edit-Distance\"><a href=\"#Edit-Distance\" class=\"headerlink\" title=\"Edit Distance\"></a><a href=\"https://leetcode.com/problems/edit-distance/\" target=\"_blank\" rel=\"noopener\">Edit Distance</a></h2><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.<br>（计算编辑距离）</p>","more":"<p>You have the following 3 operations permitted on a word:</p>\n<ol>\n<li>Insert a character</li>\n<li>Delete a character</li>\n<li>Replace a character</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_72.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>很明显的动态规划的题目，问题就在于需要分类讨论。具体的讨论情况在code的注释部分有详细解释。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDistance</span><span class=\"params\">(self, word1: <span class=\"string\">'str'</span>, word2: <span class=\"string\">'str'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        len1 = len(word1)</span><br><span class=\"line\">        len2 = len(word2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># Create a table to store results of subproblems </span></span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len1 + <span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len2 + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len2 + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len1 + <span class=\"number\">1</span>):</span><br><span class=\"line\">            \t<span class=\"comment\"># word1 is empty, insert all chars</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = j</span><br><span class=\"line\">                <span class=\"comment\"># word2 is empty, remove all chars</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = i</span><br><span class=\"line\">                <span class=\"comment\"># last chars are same</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> word2[i<span class=\"number\">-1</span>] == word1[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"comment\"># last chars are different, min(insert, remove, replace)</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span> + min(dp[i][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j], dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>])</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"comment\"># return dp[len2][len1]</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_First Missing Positive","date":"2018-12-25T10:43:04.000Z","_content":"\n# [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)\n\nGiven an unsorted integer array, find the smallest missing positive integer.\n（在未排序数组中找到最小的非正数）\n\n<!--more-->\n\n**Note:**\n- Your algorithm should run in O(n) time and uses constant extra space.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_41.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 哈希法\n\n要在时间复杂度为 \\\\( O(n)\\\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i, n = 0, len(nums)\n\n        while i < n:\n            # nums[i] > 0, nums[i] <= n means positive number in [1, n]\n            # nums[i] != i+1 means index==i but it is not i + 1\n            # nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]\n            if nums[i] > 0 and nums[i] <= n and nums[i] != i+1 and nums[nums[i] - 1] != nums[i]:\n                temp = nums[i]\n                nums[i], nums[temp-1] = nums[temp-1], nums[i]\n            else:\n                i += 1\n\n        for i in range(n):\n            if nums[i] != i+1:\n                return i+1\n         \n        return n+1\n```","source":"_posts/leetcode-FirstMissingPositive.md","raw":"---\ntitle: LeetCode_First Missing Positive\ndate: 2018-12-25 18:43:04\ncategories: LeetCode\ntags: \n  - hard\n  - array\n---\n\n# [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)\n\nGiven an unsorted integer array, find the smallest missing positive integer.\n（在未排序数组中找到最小的非正数）\n\n<!--more-->\n\n**Note:**\n- Your algorithm should run in O(n) time and uses constant extra space.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_41.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 哈希法\n\n要在时间复杂度为 \\\\( O(n)\\\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i, n = 0, len(nums)\n\n        while i < n:\n            # nums[i] > 0, nums[i] <= n means positive number in [1, n]\n            # nums[i] != i+1 means index==i but it is not i + 1\n            # nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]\n            if nums[i] > 0 and nums[i] <= n and nums[i] != i+1 and nums[nums[i] - 1] != nums[i]:\n                temp = nums[i]\n                nums[i], nums[temp-1] = nums[temp-1], nums[i]\n            else:\n                i += 1\n\n        for i in range(n):\n            if nums[i] != i+1:\n                return i+1\n         \n        return n+1\n```","slug":"leetcode-FirstMissingPositive","published":1,"updated":"2018-12-25T12:35:59.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht81z001zkvpxrki8zcam","content":"<h1 id=\"First-Missing-Positive\"><a href=\"#First-Missing-Positive\" class=\"headerlink\" title=\"First Missing Positive\"></a><a href=\"https://leetcode.com/problems/first-missing-positive/\" target=\"_blank\" rel=\"noopener\">First Missing Positive</a></h1><p>Given an unsorted integer array, find the smallest missing positive integer.<br>（在未排序数组中找到最小的非正数）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Your algorithm should run in O(n) time and uses constant extra space.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_41.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-哈希法\"><a href=\"#1-哈希法\" class=\"headerlink\" title=\"1. 哈希法\"></a>1. 哈希法</h3><p>要在时间复杂度为 \\( O(n)\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        i, n = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"comment\"># nums[i] &gt; 0, nums[i] &lt;= n means positive number in [1, n]</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[i] != i+1 means index==i but it is not i + 1</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] &lt;= n <span class=\"keyword\">and</span> nums[i] != i+<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[nums[i] - <span class=\"number\">1</span>] != nums[i]:</span><br><span class=\"line\">                temp = nums[i]</span><br><span class=\"line\">                nums[i], nums[temp<span class=\"number\">-1</span>] = nums[temp<span class=\"number\">-1</span>], nums[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] != i+<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"First-Missing-Positive\"><a href=\"#First-Missing-Positive\" class=\"headerlink\" title=\"First Missing Positive\"></a><a href=\"https://leetcode.com/problems/first-missing-positive/\" target=\"_blank\" rel=\"noopener\">First Missing Positive</a></h1><p>Given an unsorted integer array, find the smallest missing positive integer.<br>（在未排序数组中找到最小的非正数）</p>","more":"<p><strong>Note:</strong></p>\n<ul>\n<li>Your algorithm should run in O(n) time and uses constant extra space.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_41.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-哈希法\"><a href=\"#1-哈希法\" class=\"headerlink\" title=\"1. 哈希法\"></a>1. 哈希法</h3><p>要在时间复杂度为 \\( O(n)\\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        i, n = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"comment\"># nums[i] &gt; 0, nums[i] &lt;= n means positive number in [1, n]</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[i] != i+1 means index==i but it is not i + 1</span></span><br><span class=\"line\">            <span class=\"comment\"># nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] &lt;= n <span class=\"keyword\">and</span> nums[i] != i+<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[nums[i] - <span class=\"number\">1</span>] != nums[i]:</span><br><span class=\"line\">                temp = nums[i]</span><br><span class=\"line\">                nums[i], nums[temp<span class=\"number\">-1</span>] = nums[temp<span class=\"number\">-1</span>], nums[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] != i+<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Find First and Last Position of Element in Sorted Array","date":"2018-12-21T06:01:10.000Z","_content":"\n## [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].\n\n（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_34.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return [-1, -1]\n        \n        re_left, re_right = -1, -1\n\n        # find the first index\n        left, right = 0, n-1\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_left = middle\n                right = middle - 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n        \n        if nums[left] != target:\n        \treturn [-1, -1]\n           \n        # find the last index     \n        left, right = 0, n-1 \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_right = middle\n                left = middle + 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n                \n        return [re_left, re_right]\n```\n","source":"_posts/leetcode-FindFirstandLastPositionofElementinSortedArray.md","raw":"---\ntitle: LeetCode_Find First and Last Position of Element in Sorted Array\ndate: 2018-12-21 14:01:10\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - binary search\n---\n\n## [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].\n\n（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_34.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return [-1, -1]\n        \n        re_left, re_right = -1, -1\n\n        # find the first index\n        left, right = 0, n-1\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_left = middle\n                right = middle - 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n        \n        if nums[left] != target:\n        \treturn [-1, -1]\n           \n        # find the last index     \n        left, right = 0, n-1 \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                re_right = middle\n                left = middle + 1\n            elif target > nums[middle]:\n                left = middle + 1\n            else:\n                right = middle - 1\n                \n        return [re_left, re_right]\n```\n","slug":"leetcode-FindFirstandLastPositionofElementinSortedArray","published":1,"updated":"2018-12-21T06:25:23.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8210021kvpxe027myx9","content":"<h2 id=\"Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"Find First and Last Position of Element in Sorted Array\"></a><a href=\"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">Find First and Last Position of Element in Sorted Array</a></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].</p>\n<p>（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_34.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re_left, re_right = <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># find the first index</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_left = middle</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] != target:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"comment\"># find the last index     </span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span> </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_right = middle</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [re_left, re_right]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"Find First and Last Position of Element in Sorted Array\"></a><a href=\"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">Find First and Last Position of Element in Sorted Array</a></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1].</p>\n<p>（在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_34.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re_left, re_right = <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># find the first index</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_left = middle</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] != target:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"comment\"># find the last index     </span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span> </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                re_right = middle</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; nums[middle]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [re_left, re_right]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Flatten Binary Tree to Linked List","date":"2019-03-05T07:11:06.000Z","_content":"\n## [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)\n\nGiven a binary tree, flatten it to a linked list in-place.\n（压平二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_114.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归压平子树，然后将左子树放在右子树上，**并将左子树置为None**。然后找到叶子节点将原来的右子树连接在后面。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def flatten(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        \n        if root.left:\n            self.flatten(root.left)\n        if root.right:\n            self.flatten(root.right)\n        \n        # move the left tree to the right, set left to None \n        p_temp = root.right\n        root.right = root.left\n        root.left = None\n        \n        # find the leaf and link the right tree\n        p_tail = root\n        while p_tail.right:\n            p_tail = p_tail.right\n        p_tail.right = p_temp\n        \n        return\n```","source":"_posts/leetcode-FlattenBinaryTreetoLinkedList.md","raw":"---\ntitle: LeetCode_Flatten Binary Tree to Linked List\ndate: 2019-03-05 15:11:06\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - dfs\n---\n\n## [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)\n\nGiven a binary tree, flatten it to a linked list in-place.\n（压平二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_114.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归压平子树，然后将左子树放在右子树上，**并将左子树置为None**。然后找到叶子节点将原来的右子树连接在后面。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def flatten(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        \n        if root.left:\n            self.flatten(root.left)\n        if root.right:\n            self.flatten(root.right)\n        \n        # move the left tree to the right, set left to None \n        p_temp = root.right\n        root.right = root.left\n        root.left = None\n        \n        # find the leaf and link the right tree\n        p_tail = root\n        while p_tail.right:\n            p_tail = p_tail.right\n        p_tail.right = p_temp\n        \n        return\n```","slug":"leetcode-FlattenBinaryTreetoLinkedList","published":1,"updated":"2019-03-05T07:32:08.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8230024kvpxyektq6um","content":"<h2 id=\"Flatten-Binary-Tree-to-Linked-List\"><a href=\"#Flatten-Binary-Tree-to-Linked-List\" class=\"headerlink\" title=\"Flatten Binary Tree to Linked List\"></a><a href=\"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">Flatten Binary Tree to Linked List</a></h2><p>Given a binary tree, flatten it to a linked list in-place.<br>（压平二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_114.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归压平子树，然后将左子树放在右子树上，<strong>并将左子树置为None</strong>。然后找到叶子节点将原来的右子树连接在后面。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify root in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left:</span><br><span class=\"line\">            self.flatten(root.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.right:</span><br><span class=\"line\">            self.flatten(root.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># move the left tree to the right, set left to None </span></span><br><span class=\"line\">        p_temp = root.right</span><br><span class=\"line\">        root.right = root.left</span><br><span class=\"line\">        root.left = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># find the leaf and link the right tree</span></span><br><span class=\"line\">        p_tail = root</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_tail.right:</span><br><span class=\"line\">            p_tail = p_tail.right</span><br><span class=\"line\">        p_tail.right = p_temp</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Flatten-Binary-Tree-to-Linked-List\"><a href=\"#Flatten-Binary-Tree-to-Linked-List\" class=\"headerlink\" title=\"Flatten Binary Tree to Linked List\"></a><a href=\"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">Flatten Binary Tree to Linked List</a></h2><p>Given a binary tree, flatten it to a linked list in-place.<br>（压平二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_114.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归压平子树，然后将左子树放在右子树上，<strong>并将左子树置为None</strong>。然后找到叶子节点将原来的右子树连接在后面。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify root in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left:</span><br><span class=\"line\">            self.flatten(root.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.right:</span><br><span class=\"line\">            self.flatten(root.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># move the left tree to the right, set left to None </span></span><br><span class=\"line\">        p_temp = root.right</span><br><span class=\"line\">        root.right = root.left</span><br><span class=\"line\">        root.left = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># find the leaf and link the right tree</span></span><br><span class=\"line\">        p_tail = root</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_tail.right:</span><br><span class=\"line\">            p_tail = p_tail.right</span><br><span class=\"line\">        p_tail.right = p_temp</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>"},{"title":"leetcode_Gray Code","date":"2019-02-25T14:49:34.000Z","_content":"\n## [Gray Code](https://leetcode.com/problems/gray-code/)\n\nThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\n(n位格雷码)\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_89.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二进制码转换为格雷码\n二进制转换为 Gray码：右移一位并与自身异或。\n如 n=2 时，binary=[00, 01, 10, 11], \n\t        gray=[00^00, 00^01, 01^10, 01^11]=[11, 01, 11, 10]，即[0, 1, 3, 2]。\n\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        results = []\n        for i in range(pow(2, n)):\n            results.append((i >> 1) ^ i)\n        \n        return results\n```\n\n### 2. 格雷码的镜面排列\n1. n=0时，gray=[0]\n2. n=1时，add_gray=[0] + 2^0, gray=[0, 1]\n3. n=2时，add_gray=[1, 0] + 2^1, gray=[0, 1, 3, 2]\n...\n\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        results = [0]\n        for i in range(n):\n            results += [x+2**i for x in reversed(results)]\n        \n        return results\n```\n\n\n","source":"_posts/leetcode-GrayCode.md","raw":"---\ntitle: leetcode_Gray Code\ndate: 2019-02-25 22:49:34\ncategories: LeetCode\ntags: \n  - medium\n  - binary\n  - back tracking\n---\n\n## [Gray Code](https://leetcode.com/problems/gray-code/)\n\nThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\n(n位格雷码)\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_89.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二进制码转换为格雷码\n二进制转换为 Gray码：右移一位并与自身异或。\n如 n=2 时，binary=[00, 01, 10, 11], \n\t        gray=[00^00, 00^01, 01^10, 01^11]=[11, 01, 11, 10]，即[0, 1, 3, 2]。\n\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        results = []\n        for i in range(pow(2, n)):\n            results.append((i >> 1) ^ i)\n        \n        return results\n```\n\n### 2. 格雷码的镜面排列\n1. n=0时，gray=[0]\n2. n=1时，add_gray=[0] + 2^0, gray=[0, 1]\n3. n=2时，add_gray=[1, 0] + 2^1, gray=[0, 1, 3, 2]\n...\n\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        results = [0]\n        for i in range(n):\n            results += [x+2**i for x in reversed(results)]\n        \n        return results\n```\n\n\n","slug":"leetcode-GrayCode","published":1,"updated":"2019-02-26T02:34:49.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8250026kvpxk5lq2woi","content":"<h2 id=\"Gray-Code\"><a href=\"#Gray-Code\" class=\"headerlink\" title=\"Gray Code\"></a><a href=\"https://leetcode.com/problems/gray-code/\" target=\"_blank\" rel=\"noopener\">Gray Code</a></h2><p>The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.<br>(n位格雷码)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_89.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二进制码转换为格雷码\"><a href=\"#1-二进制码转换为格雷码\" class=\"headerlink\" title=\"1. 二进制码转换为格雷码\"></a>1. 二进制码转换为格雷码</h3><p>二进制转换为 Gray码：右移一位并与自身异或。<br>如 n=2 时，binary=[00, 01, 10, 11],<br>            gray=[00^00, 00^01, 01^10, 01^11]=[11, 01, 11, 10]，即[0, 1, 3, 2]。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">grayCode</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(pow(<span class=\"number\">2</span>, n)):</span><br><span class=\"line\">            results.append((i &gt;&gt; <span class=\"number\">1</span>) ^ i)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-格雷码的镜面排列\"><a href=\"#2-格雷码的镜面排列\" class=\"headerlink\" title=\"2. 格雷码的镜面排列\"></a>2. 格雷码的镜面排列</h3><ol>\n<li>n=0时，gray=[0]</li>\n<li>n=1时，add_gray=[0] + 2^0, gray=[0, 1]</li>\n<li>n=2时，add_gray=[1, 0] + 2^1, gray=[0, 1, 3, 2]<br>…</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">grayCode</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        results = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            results += [x+<span class=\"number\">2</span>**i <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> reversed(results)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Gray-Code\"><a href=\"#Gray-Code\" class=\"headerlink\" title=\"Gray Code\"></a><a href=\"https://leetcode.com/problems/gray-code/\" target=\"_blank\" rel=\"noopener\">Gray Code</a></h2><p>The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.<br>(n位格雷码)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_89.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二进制码转换为格雷码\"><a href=\"#1-二进制码转换为格雷码\" class=\"headerlink\" title=\"1. 二进制码转换为格雷码\"></a>1. 二进制码转换为格雷码</h3><p>二进制转换为 Gray码：右移一位并与自身异或。<br>如 n=2 时，binary=[00, 01, 10, 11],<br>            gray=[00^00, 00^01, 01^10, 01^11]=[11, 01, 11, 10]，即[0, 1, 3, 2]。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">grayCode</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(pow(<span class=\"number\">2</span>, n)):</span><br><span class=\"line\">            results.append((i &gt;&gt; <span class=\"number\">1</span>) ^ i)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-格雷码的镜面排列\"><a href=\"#2-格雷码的镜面排列\" class=\"headerlink\" title=\"2. 格雷码的镜面排列\"></a>2. 格雷码的镜面排列</h3><ol>\n<li>n=0时，gray=[0]</li>\n<li>n=1时，add_gray=[0] + 2^0, gray=[0, 1]</li>\n<li>n=2时，add_gray=[1, 0] + 2^1, gray=[0, 1, 3, 2]<br>…</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">grayCode</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        results = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            results += [x+<span class=\"number\">2</span>**i <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> reversed(results)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Combination Sum II","date":"2018-12-25T10:22:35.000Z","_content":"\n# [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used **once** in the combination.\n（从集合中挑选和为特定值的数字组合，同一元素只可选一次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_40.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法\n\n这道题与上一题的区别在于：\n1. 这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。\n2. candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。\n\n```python\nclass Solution:\n    def backtracking(self, re_set, candidates, target):\n        if target == 0 and list(re_set) not in self.result: \n        \tself.result.append(list(re_set))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tbreak\n        \t\telse:\n        \t\t\tre_set.append(candidates[i])\n        \t\t\tself.backtracking(re_set, candidates[i+1:], target - candidates[i])\n        \t\t\tre_set.pop()\n\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n       \tre_set = []\n       \tcandidates.sort()\n\n        self.backtracking(re_set, candidates, target)\n        \n        return self.result\n```","source":"_posts/leetcode-CombinationSumII.md","raw":"---\ntitle: LeetCode_Combination Sum II\ndate: 2018-12-25 18:22:35\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n---\n\n# [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used **once** in the combination.\n（从集合中挑选和为特定值的数字组合，同一元素只可选一次）\n\n<!--more-->\n\n**Note:**\n- All numbers (including target) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_40.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法\n\n这道题与上一题的区别在于：\n1. 这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。\n2. candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。\n\n```python\nclass Solution:\n    def backtracking(self, re_set, candidates, target):\n        if target == 0 and list(re_set) not in self.result: \n        \tself.result.append(list(re_set))\n        \t\n        else:\n        \tfor i in range(len(candidates)):\n        \t\tif target < candidates[i]:\n        \t\t\tbreak\n        \t\telse:\n        \t\t\tre_set.append(candidates[i])\n        \t\t\tself.backtracking(re_set, candidates[i+1:], target - candidates[i])\n        \t\t\tre_set.pop()\n\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n       \tself.result = []\n       \tre_set = []\n       \tcandidates.sort()\n\n        self.backtracking(re_set, candidates, target)\n        \n        return self.result\n```","slug":"leetcode-CombinationSumII","published":1,"updated":"2018-12-25T10:43:17.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8280029kvpx1jnsdars","content":"<h1 id=\"Combination-Sum-II\"><a href=\"#Combination-Sum-II\" class=\"headerlink\" title=\"Combination Sum II\"></a><a href=\"https://leetcode.com/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener\">Combination Sum II</a></h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used <strong>once</strong> in the combination.<br>（从集合中挑选和为特定值的数字组合，同一元素只可选一次）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_40.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>这道题与上一题的区别在于：</p>\n<ol>\n<li>这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。</li>\n<li>candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re_set, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span> <span class=\"keyword\">and</span> list(re_set) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.result: </span><br><span class=\"line\">        \tself.result.append(list(re_set))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">        \t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t\t\tre_set.append(candidates[i])</span><br><span class=\"line\">        \t\t\tself.backtracking(re_set, candidates[i+<span class=\"number\">1</span>:], target - candidates[i])</span><br><span class=\"line\">        \t\t\tre_set.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum2</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">       \tre_set = []</span><br><span class=\"line\">       \tcandidates.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        self.backtracking(re_set, candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Combination-Sum-II\"><a href=\"#Combination-Sum-II\" class=\"headerlink\" title=\"Combination Sum II\"></a><a href=\"https://leetcode.com/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener\">Combination Sum II</a></h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used <strong>once</strong> in the combination.<br>（从集合中挑选和为特定值的数字组合，同一元素只可选一次）</p>","more":"<p><strong>Note:</strong></p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_40.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>这道题与上一题的区别在于：</p>\n<ol>\n<li>这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。</li>\n<li>candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtracking</span><span class=\"params\">(self, re_set, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span> <span class=\"keyword\">and</span> list(re_set) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.result: </span><br><span class=\"line\">        \tself.result.append(list(re_set))</span><br><span class=\"line\">        \t</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(candidates)):</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> target &lt; candidates[i]:</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">        \t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">        \t\t\tre_set.append(candidates[i])</span><br><span class=\"line\">        \t\t\tself.backtracking(re_set, candidates[i+<span class=\"number\">1</span>:], target - candidates[i])</span><br><span class=\"line\">        \t\t\tre_set.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum2</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type candidates: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       \tself.result = []</span><br><span class=\"line\">       \tre_set = []</span><br><span class=\"line\">       \tcandidates.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        self.backtracking(re_set, candidates, target)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Group Anagrams","date":"2019-01-09T06:48:18.000Z","_content":"\n## [Group Anagrams](https://leetcode.com/problems/group-anagrams/)\n\nGiven an array of strings, group anagrams together.\n(将使用相同字符构成的不同排列的单词合并)\n\n<!--more-->\n\n**Note:** \n1. All inputs will be in lowercase.\n2. The order of your output does not matter.\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_49.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 哈希表 / Dict \n遍历数组中的每一个单词，将每个单词根据所组成的字符排序从而得到哈希表的key。具体实现过程如下：\n\n```python\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        word_map = {}\n        for word in strs:\n            items = list(word)\n            items.sort()\n            items = ''.join(items)\n            if items not in word_map:\n                word_map[items] = [word]\n            else:\n                word_map[items].append(word)\n\n        result = []\n        for key in word_map:\n            result.append(word_map[key])\n\n        return result\n```\n","source":"_posts/leetcode-GroupAnagrams.md","raw":"---\ntitle: LeetCode_Group Anagrams\ndate: 2019-01-09 14:48:18\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - hash table\n---\n\n## [Group Anagrams](https://leetcode.com/problems/group-anagrams/)\n\nGiven an array of strings, group anagrams together.\n(将使用相同字符构成的不同排列的单词合并)\n\n<!--more-->\n\n**Note:** \n1. All inputs will be in lowercase.\n2. The order of your output does not matter.\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_49.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 哈希表 / Dict \n遍历数组中的每一个单词，将每个单词根据所组成的字符排序从而得到哈希表的key。具体实现过程如下：\n\n```python\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        word_map = {}\n        for word in strs:\n            items = list(word)\n            items.sort()\n            items = ''.join(items)\n            if items not in word_map:\n                word_map[items] = [word]\n            else:\n                word_map[items].append(word)\n\n        result = []\n        for key in word_map:\n            result.append(word_map[key])\n\n        return result\n```\n","slug":"leetcode-GroupAnagrams","published":1,"updated":"2019-01-09T07:00:46.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82b002ckvpxxjwo0611","content":"<h2 id=\"Group-Anagrams\"><a href=\"#Group-Anagrams\" class=\"headerlink\" title=\"Group Anagrams\"></a><a href=\"https://leetcode.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">Group Anagrams</a></h2><p>Given an array of strings, group anagrams together.<br>(将使用相同字符构成的不同排列的单词合并)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> </p>\n<ol>\n<li>All inputs will be in lowercase.</li>\n<li>The order of your output does not matter.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_49.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-哈希表-Dict\"><a href=\"#1-哈希表-Dict\" class=\"headerlink\" title=\"1. 哈希表 / Dict\"></a>1. 哈希表 / Dict</h3><p>遍历数组中的每一个单词，将每个单词根据所组成的字符排序从而得到哈希表的key。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupAnagrams</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        word_map = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> strs:</span><br><span class=\"line\">            items = list(word)</span><br><span class=\"line\">            items.sort()</span><br><span class=\"line\">            items = <span class=\"string\">''</span>.join(items)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> items <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> word_map:</span><br><span class=\"line\">                word_map[items] = [word]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                word_map[items].append(word)</span><br><span class=\"line\"></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> word_map:</span><br><span class=\"line\">            result.append(word_map[key])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Group-Anagrams\"><a href=\"#Group-Anagrams\" class=\"headerlink\" title=\"Group Anagrams\"></a><a href=\"https://leetcode.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">Group Anagrams</a></h2><p>Given an array of strings, group anagrams together.<br>(将使用相同字符构成的不同排列的单词合并)</p>","more":"<p><strong>Note:</strong> </p>\n<ol>\n<li>All inputs will be in lowercase.</li>\n<li>The order of your output does not matter.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_49.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-哈希表-Dict\"><a href=\"#1-哈希表-Dict\" class=\"headerlink\" title=\"1. 哈希表 / Dict\"></a>1. 哈希表 / Dict</h3><p>遍历数组中的每一个单词，将每个单词根据所组成的字符排序从而得到哈希表的key。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupAnagrams</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        word_map = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> strs:</span><br><span class=\"line\">            items = list(word)</span><br><span class=\"line\">            items.sort()</span><br><span class=\"line\">            items = <span class=\"string\">''</span>.join(items)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> items <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> word_map:</span><br><span class=\"line\">                word_map[items] = [word]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                word_map[items].append(word)</span><br><span class=\"line\"></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> word_map:</span><br><span class=\"line\">            result.append(word_map[key])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Insert Interval","date":"2019-01-12T06:05:50.000Z","_content":"\n## [Insert Interval](https://leetcode.com/problems/insert-interval/)\n\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.\n（插入间隔区间）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_57.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 遍历间隔区间\n直接遍历间隔区间数组，并在遇到交叉的情况下时不断更新新插入的间隔区间的起止位置。具体实现过程如下：\n\n```python\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type newInterval: Interval\n        :rtype: List[Interval]\n        \"\"\"\n        \n        if len(intervals) == 0:\n            return [newInterval]\n        \n        result = []\n        \n        insert_new = False\n        for interval in intervals:\n            if interval.end < newInterval.start:\n                result.append(interval)\n            elif interval.start > newInterval.end:\n                if not insert_new:\n                    result.append(newInterval)\n                    insert_new = True\n                result.append(interval)\n            else:\n                 newInterval = Interval(min(interval.start, newInterval.start), max(interval.end, newInterval.end))\n        \n        if not insert_new:\n            result.append(newInterval)\n        \n        return result\n```\n\n### 2. 合并间隔区间\n借用前一道题目的方法，把待插入的间隔区间和数组合并，然后合并交叉的区间。具体实现方法如下：\n\n```python\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type newInterval: Interval\n        :rtype: List[Interval]\n        \"\"\"\n        \n        if len(intervals) == 0:\n            return [newInterval]\n        \n        intervals.append(newInterval)\n        intervals.sort(key = lambda x: x.start)\n        \n        result = []\n        for interval in intervals:\n            if not result or interval.start > result[-1].end:\n                result.append(interval)\n            else:\n                result[-1].start = min(result[-1].start, interval.start)\n                result[-1].end = max(result[-1].end, interval.end)\n                \n        return result \n```\n\n","source":"_posts/leetcode-InsertInterval.md","raw":"---\ntitle: LeetCode_Insert Interval\ndate: 2019-01-12 14:05:50\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - sort\n---\n\n## [Insert Interval](https://leetcode.com/problems/insert-interval/)\n\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.\n（插入间隔区间）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_57.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 遍历间隔区间\n直接遍历间隔区间数组，并在遇到交叉的情况下时不断更新新插入的间隔区间的起止位置。具体实现过程如下：\n\n```python\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type newInterval: Interval\n        :rtype: List[Interval]\n        \"\"\"\n        \n        if len(intervals) == 0:\n            return [newInterval]\n        \n        result = []\n        \n        insert_new = False\n        for interval in intervals:\n            if interval.end < newInterval.start:\n                result.append(interval)\n            elif interval.start > newInterval.end:\n                if not insert_new:\n                    result.append(newInterval)\n                    insert_new = True\n                result.append(interval)\n            else:\n                 newInterval = Interval(min(interval.start, newInterval.start), max(interval.end, newInterval.end))\n        \n        if not insert_new:\n            result.append(newInterval)\n        \n        return result\n```\n\n### 2. 合并间隔区间\n借用前一道题目的方法，把待插入的间隔区间和数组合并，然后合并交叉的区间。具体实现方法如下：\n\n```python\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type newInterval: Interval\n        :rtype: List[Interval]\n        \"\"\"\n        \n        if len(intervals) == 0:\n            return [newInterval]\n        \n        intervals.append(newInterval)\n        intervals.sort(key = lambda x: x.start)\n        \n        result = []\n        for interval in intervals:\n            if not result or interval.start > result[-1].end:\n                result.append(interval)\n            else:\n                result[-1].start = min(result[-1].start, interval.start)\n                result[-1].end = max(result[-1].end, interval.end)\n                \n        return result \n```\n\n","slug":"leetcode-InsertInterval","published":1,"updated":"2019-01-12T06:55:35.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82c002gkvpxwiio3s92","content":"<h2 id=\"Insert-Interval\"><a href=\"#Insert-Interval\" class=\"headerlink\" title=\"Insert Interval\"></a><a href=\"https://leetcode.com/problems/insert-interval/\" target=\"_blank\" rel=\"noopener\">Insert Interval</a></h2><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.<br>（插入间隔区间）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_57.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-遍历间隔区间\"><a href=\"#1-遍历间隔区间\" class=\"headerlink\" title=\"1. 遍历间隔区间\"></a>1. 遍历间隔区间</h3><p>直接遍历间隔区间数组，并在遇到交叉的情况下时不断更新新插入的间隔区间的起止位置。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for an interval.</span></span><br><span class=\"line\"><span class=\"comment\"># class Interval:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, s=0, e=0):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.start = s</span></span><br><span class=\"line\"><span class=\"comment\">#         self.end = e</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, intervals, newInterval)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type intervals: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        :type newInterval: Interval</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(intervals) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [newInterval]</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        insert_new = <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> interval.end &lt; newInterval.start:</span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> interval.start &gt; newInterval.end:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> insert_new:</span><br><span class=\"line\">                    result.append(newInterval)</span><br><span class=\"line\">                    insert_new = <span class=\"keyword\">True</span></span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                 newInterval = Interval(min(interval.start, newInterval.start), max(interval.end, newInterval.end))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> insert_new:</span><br><span class=\"line\">            result.append(newInterval)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-合并间隔区间\"><a href=\"#2-合并间隔区间\" class=\"headerlink\" title=\"2. 合并间隔区间\"></a>2. 合并间隔区间</h3><p>借用前一道题目的方法，把待插入的间隔区间和数组合并，然后合并交叉的区间。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for an interval.</span></span><br><span class=\"line\"><span class=\"comment\"># class Interval:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, s=0, e=0):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.start = s</span></span><br><span class=\"line\"><span class=\"comment\">#         self.end = e</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, intervals, newInterval)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type intervals: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        :type newInterval: Interval</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(intervals) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [newInterval]</span><br><span class=\"line\">        </span><br><span class=\"line\">        intervals.append(newInterval)</span><br><span class=\"line\">        intervals.sort(key = <span class=\"keyword\">lambda</span> x: x.start)</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> result <span class=\"keyword\">or</span> interval.start &gt; result[<span class=\"number\">-1</span>].end:</span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result[<span class=\"number\">-1</span>].start = min(result[<span class=\"number\">-1</span>].start, interval.start)</span><br><span class=\"line\">                result[<span class=\"number\">-1</span>].end = max(result[<span class=\"number\">-1</span>].end, interval.end)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Insert-Interval\"><a href=\"#Insert-Interval\" class=\"headerlink\" title=\"Insert Interval\"></a><a href=\"https://leetcode.com/problems/insert-interval/\" target=\"_blank\" rel=\"noopener\">Insert Interval</a></h2><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.<br>（插入间隔区间）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_57.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-遍历间隔区间\"><a href=\"#1-遍历间隔区间\" class=\"headerlink\" title=\"1. 遍历间隔区间\"></a>1. 遍历间隔区间</h3><p>直接遍历间隔区间数组，并在遇到交叉的情况下时不断更新新插入的间隔区间的起止位置。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for an interval.</span></span><br><span class=\"line\"><span class=\"comment\"># class Interval:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, s=0, e=0):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.start = s</span></span><br><span class=\"line\"><span class=\"comment\">#         self.end = e</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, intervals, newInterval)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type intervals: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        :type newInterval: Interval</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(intervals) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [newInterval]</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        insert_new = <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> interval.end &lt; newInterval.start:</span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> interval.start &gt; newInterval.end:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> insert_new:</span><br><span class=\"line\">                    result.append(newInterval)</span><br><span class=\"line\">                    insert_new = <span class=\"keyword\">True</span></span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                 newInterval = Interval(min(interval.start, newInterval.start), max(interval.end, newInterval.end))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> insert_new:</span><br><span class=\"line\">            result.append(newInterval)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-合并间隔区间\"><a href=\"#2-合并间隔区间\" class=\"headerlink\" title=\"2. 合并间隔区间\"></a>2. 合并间隔区间</h3><p>借用前一道题目的方法，把待插入的间隔区间和数组合并，然后合并交叉的区间。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for an interval.</span></span><br><span class=\"line\"><span class=\"comment\"># class Interval:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, s=0, e=0):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.start = s</span></span><br><span class=\"line\"><span class=\"comment\">#         self.end = e</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, intervals, newInterval)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type intervals: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        :type newInterval: Interval</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(intervals) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [newInterval]</span><br><span class=\"line\">        </span><br><span class=\"line\">        intervals.append(newInterval)</span><br><span class=\"line\">        intervals.sort(key = <span class=\"keyword\">lambda</span> x: x.start)</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> result <span class=\"keyword\">or</span> interval.start &gt; result[<span class=\"number\">-1</span>].end:</span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result[<span class=\"number\">-1</span>].start = min(result[<span class=\"number\">-1</span>].start, interval.start)</span><br><span class=\"line\">                result[<span class=\"number\">-1</span>].end = max(result[<span class=\"number\">-1</span>].end, interval.end)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Integer to Roman","date":"2018-11-28T07:40:20.000Z","_content":"\n## [Integer to Roman](https://leetcode.com/problems/integer-to-roman/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（整数转罗马字符）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_12.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 基数扩展\n由于 \"4\" 和 \"9\" 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        base = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        base_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        \n        result = \"\"\n        for i in range(len(base_list)):\n            if num // base_list[i] != 0:\n                for j in range(num // base_list[i]):\n                    result += base[base_list[i]]\n                num = num % base_list[i]\n            \n        return result \n```\n\n\n### 2. 列表索引\n列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    \n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\n```","source":"_posts/leetcode-IntegertoRoman.md","raw":"---\ntitle: LeetCode_Integer to Roman\ndate: 2018-11-28 15:40:20\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - string\n---\n\n## [Integer to Roman](https://leetcode.com/problems/integer-to-roman/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（整数转罗马字符）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_12.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 基数扩展\n由于 \"4\" 和 \"9\" 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        base = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        base_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        \n        result = \"\"\n        for i in range(len(base_list)):\n            if num // base_list[i] != 0:\n                for j in range(num // base_list[i]):\n                    result += base[base_list[i]]\n                num = num % base_list[i]\n            \n        return result \n```\n\n\n### 2. 列表索引\n列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：\n```python\nclass Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    \n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\n```","slug":"leetcode-IntegertoRoman","published":1,"updated":"2018-11-29T02:41:29.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82e002jkvpx3zywtw5y","content":"<h2 id=\"Integer-to-Roman\"><a href=\"#Integer-to-Roman\" class=\"headerlink\" title=\"Integer to Roman\"></a><a href=\"https://leetcode.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">Integer to Roman</a></h2><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（整数转罗马字符）</p>\n<a id=\"more\"></a>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_12.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-基数扩展\"><a href=\"#1-基数扩展\" class=\"headerlink\" title=\"1. 基数扩展\"></a>1. 基数扩展</h3><p>由于 “4” 和 “9” 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"number\">1000</span>: <span class=\"string\">'M'</span>,</span><br><span class=\"line\">            <span class=\"number\">900</span>: <span class=\"string\">'CM'</span>,</span><br><span class=\"line\">            <span class=\"number\">500</span>: <span class=\"string\">'D'</span>,</span><br><span class=\"line\">            <span class=\"number\">400</span>: <span class=\"string\">'CD'</span>,</span><br><span class=\"line\">            <span class=\"number\">100</span>: <span class=\"string\">'C'</span>,</span><br><span class=\"line\">            <span class=\"number\">90</span>: <span class=\"string\">'XC'</span>,</span><br><span class=\"line\">            <span class=\"number\">50</span>: <span class=\"string\">'L'</span>,</span><br><span class=\"line\">            <span class=\"number\">40</span>: <span class=\"string\">'XL'</span>,</span><br><span class=\"line\">            <span class=\"number\">10</span>: <span class=\"string\">'X'</span>,</span><br><span class=\"line\">            <span class=\"number\">9</span>: <span class=\"string\">'IX'</span>,</span><br><span class=\"line\">            <span class=\"number\">5</span>: <span class=\"string\">'V'</span>,</span><br><span class=\"line\">            <span class=\"number\">4</span>: <span class=\"string\">'IV'</span>,</span><br><span class=\"line\">            <span class=\"number\">1</span>: <span class=\"string\">'I'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        base_list = [<span class=\"number\">1000</span>, <span class=\"number\">900</span>, <span class=\"number\">500</span>, <span class=\"number\">400</span>, <span class=\"number\">100</span>, <span class=\"number\">90</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(base_list)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num // base_list[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(num // base_list[i]):</span><br><span class=\"line\">                    result += base[base_list[i]]</span><br><span class=\"line\">                num = num % base_list[i]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-列表索引\"><a href=\"#2-列表索引\" class=\"headerlink\" title=\"2. 列表索引\"></a>2. 列表索引</h3><p>列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        M = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"MM\"</span>, <span class=\"string\">\"MMM\"</span>]</span><br><span class=\"line\">        C = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span>]</span><br><span class=\"line\">        X = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span>]</span><br><span class=\"line\">        I = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> M[num//<span class=\"number\">1000</span>] + C[(num%<span class=\"number\">1000</span>)//<span class=\"number\">100</span>] + X[(num%<span class=\"number\">100</span>)//<span class=\"number\">10</span>] + I[num%<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Integer-to-Roman\"><a href=\"#Integer-to-Roman\" class=\"headerlink\" title=\"Integer to Roman\"></a><a href=\"https://leetcode.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">Integer to Roman</a></h2><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（整数转罗马字符）</p>","more":"<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_12.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-基数扩展\"><a href=\"#1-基数扩展\" class=\"headerlink\" title=\"1. 基数扩展\"></a>1. 基数扩展</h3><p>由于 “4” 和 “9” 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"number\">1000</span>: <span class=\"string\">'M'</span>,</span><br><span class=\"line\">            <span class=\"number\">900</span>: <span class=\"string\">'CM'</span>,</span><br><span class=\"line\">            <span class=\"number\">500</span>: <span class=\"string\">'D'</span>,</span><br><span class=\"line\">            <span class=\"number\">400</span>: <span class=\"string\">'CD'</span>,</span><br><span class=\"line\">            <span class=\"number\">100</span>: <span class=\"string\">'C'</span>,</span><br><span class=\"line\">            <span class=\"number\">90</span>: <span class=\"string\">'XC'</span>,</span><br><span class=\"line\">            <span class=\"number\">50</span>: <span class=\"string\">'L'</span>,</span><br><span class=\"line\">            <span class=\"number\">40</span>: <span class=\"string\">'XL'</span>,</span><br><span class=\"line\">            <span class=\"number\">10</span>: <span class=\"string\">'X'</span>,</span><br><span class=\"line\">            <span class=\"number\">9</span>: <span class=\"string\">'IX'</span>,</span><br><span class=\"line\">            <span class=\"number\">5</span>: <span class=\"string\">'V'</span>,</span><br><span class=\"line\">            <span class=\"number\">4</span>: <span class=\"string\">'IV'</span>,</span><br><span class=\"line\">            <span class=\"number\">1</span>: <span class=\"string\">'I'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        base_list = [<span class=\"number\">1000</span>, <span class=\"number\">900</span>, <span class=\"number\">500</span>, <span class=\"number\">400</span>, <span class=\"number\">100</span>, <span class=\"number\">90</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(base_list)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num // base_list[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(num // base_list[i]):</span><br><span class=\"line\">                    result += base[base_list[i]]</span><br><span class=\"line\">                num = num % base_list[i]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-列表索引\"><a href=\"#2-列表索引\" class=\"headerlink\" title=\"2. 列表索引\"></a>2. 列表索引</h3><p>列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        M = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"MM\"</span>, <span class=\"string\">\"MMM\"</span>]</span><br><span class=\"line\">        C = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span>]</span><br><span class=\"line\">        X = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span>]</span><br><span class=\"line\">        I = [<span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> M[num//<span class=\"number\">1000</span>] + C[(num%<span class=\"number\">1000</span>)//<span class=\"number\">100</span>] + X[(num%<span class=\"number\">100</span>)//<span class=\"number\">10</span>] + I[num%<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Implement strStr()","date":"2018-12-18T08:21:01.000Z","_content":"\n## [Implement strStr()](https://leetcode.com/problems/implement-strstr/)\n\nImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n（实现寻找字符串子串函数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_28.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历 -- easy\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        n = len(needle)\n        m = len(haystack)\n        \n        if n == 0:\n            return 0\n        \n        if n > m:\n            return -1\n        \n        for i in range(m-n+1):\n            if haystack[i:i+n] == needle:\n                return i\n        \n        return -1\n```\n\n### 2. 调用 python 库函数 in, index\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)\n```","source":"_posts/leetcode-ImplementstrStr.md","raw":"---\ntitle: LeetCode_Implement strStr()\ndate: 2018-12-18 16:21:01\ncategories: LeetCode\ntags: \n  - easy\n  - string\n  - two pointers\n---\n\n## [Implement strStr()](https://leetcode.com/problems/implement-strstr/)\n\nImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n（实现寻找字符串子串函数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_28.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历 -- easy\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        n = len(needle)\n        m = len(haystack)\n        \n        if n == 0:\n            return 0\n        \n        if n > m:\n            return -1\n        \n        for i in range(m-n+1):\n            if haystack[i:i+n] == needle:\n                return i\n        \n        return -1\n```\n\n### 2. 调用 python 库函数 in, index\n```python\nclass Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)\n```","slug":"leetcode-ImplementstrStr","published":1,"updated":"2018-12-18T08:41:00.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82h002nkvpx28220drm","content":"<h2 id=\"Implement-strStr\"><a href=\"#Implement-strStr\" class=\"headerlink\" title=\"Implement strStr()\"></a><a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">Implement strStr()</a></h2><p>Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.<br>（实现寻找字符串子串函数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_28.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历-–-easy\"><a href=\"#1-遍历-–-easy\" class=\"headerlink\" title=\"1. 遍历 – easy\"></a>1. 遍历 – easy</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(needle)</span><br><span class=\"line\">        m = len(haystack)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m-n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> haystack[i:i+n] == needle:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-调用-python-库函数-in-index\"><a href=\"#2-调用-python-库函数-in-index\" class=\"headerlink\" title=\"2. 调用 python 库函数 in, index\"></a>2. 调用 python 库函数 in, index</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> needle <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> haystack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> haystack.index(needle)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Implement-strStr\"><a href=\"#Implement-strStr\" class=\"headerlink\" title=\"Implement strStr()\"></a><a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">Implement strStr()</a></h2><p>Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.<br>（实现寻找字符串子串函数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_28.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历-–-easy\"><a href=\"#1-遍历-–-easy\" class=\"headerlink\" title=\"1. 遍历 – easy\"></a>1. 遍历 – easy</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(needle)</span><br><span class=\"line\">        m = len(haystack)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m-n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> haystack[i:i+n] == needle:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-调用-python-库函数-in-index\"><a href=\"#2-调用-python-库函数-in-index\" class=\"headerlink\" title=\"2. 调用 python 库函数 in, index\"></a>2. 调用 python 库函数 in, index</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, haystack, needle)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type haystack: str</span></span><br><span class=\"line\"><span class=\"string\">        :type needle: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> needle <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> haystack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> haystack.index(needle)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Generate Parentheses","date":"2018-12-07T08:33:33.000Z","_content":"\n## [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n（n 对括号所有组合形式）\n\n<!--more-->\n\n**Example:** \nFor example, given n = 3, a solution set is:\n\n<div align=center>\n\t<img src=\"/images/leetcode_22.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归 & 深度优先搜索\n这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： **任何位置的之前的 NUM_( >= NUM_)**。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        \n        def generateParenthesis(left_remain, right_remain, s):\n            if left_remain == 0 and right_remain == 0:\n                result.append(s)\n            if left_remain > 0:\n                generateParenthesis(left_remain-1, right_remain, s + '(')\n            if right_remain > 0 and left_remain < right_remain:\n                generateParenthesis(left_remain, right_remain-1, s + ')')\n            \n        generateParenthesis(n, n, '')\n        \n        return result\n```\n\n### 2. 动态规划\n经过观察发现如下：\n  - n==0, result = ['']\n  - n==1, result = [\n  \t() = ( + result_0 + ) + result_0\n  ]\n  - n==2, result = [\n  ()() = ( + result_0 + ) + result_1()\n  (()) = ( + result_1() + ) + result_0\n  ]\n  - n==3, result = [\n  ()()() = ( + result_0 + ) + result_2_1()()\n  ()(()) = ( + result_0 + ) + result_2_2(())\n  (())() = ( + result_1() + ) + result_1()\n  (()()) = ( + result_2_1()() + ) + result_0\n  ((())) = ( + result_2_2(()) + ) + result_0\n  ]\n因此我们可以得出如下结论：\n  - dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        dp = [[] for i in range(n+1)]\n\n        dp[0].append('')\n        for i in range(n + 1):\n        \tfor j in range(i):\n        \t\t dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\n            \n        return dp[n]    \n        \n```","source":"_posts/leetcode-GenerateParentheses.md","raw":"---\ntitle: LeetCode_Generate Parentheses\ndate: 2018-12-07 16:33:33\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - back tracking\n---\n\n## [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n（n 对括号所有组合形式）\n\n<!--more-->\n\n**Example:** \nFor example, given n = 3, a solution set is:\n\n<div align=center>\n\t<img src=\"/images/leetcode_22.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归 & 深度优先搜索\n这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： **任何位置的之前的 NUM_( >= NUM_)**。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        \n        def generateParenthesis(left_remain, right_remain, s):\n            if left_remain == 0 and right_remain == 0:\n                result.append(s)\n            if left_remain > 0:\n                generateParenthesis(left_remain-1, right_remain, s + '(')\n            if right_remain > 0 and left_remain < right_remain:\n                generateParenthesis(left_remain, right_remain-1, s + ')')\n            \n        generateParenthesis(n, n, '')\n        \n        return result\n```\n\n### 2. 动态规划\n经过观察发现如下：\n  - n==0, result = ['']\n  - n==1, result = [\n  \t() = ( + result_0 + ) + result_0\n  ]\n  - n==2, result = [\n  ()() = ( + result_0 + ) + result_1()\n  (()) = ( + result_1() + ) + result_0\n  ]\n  - n==3, result = [\n  ()()() = ( + result_0 + ) + result_2_1()()\n  ()(()) = ( + result_0 + ) + result_2_2(())\n  (())() = ( + result_1() + ) + result_1()\n  (()()) = ( + result_2_1()() + ) + result_0\n  ((())) = ( + result_2_2(()) + ) + result_0\n  ]\n因此我们可以得出如下结论：\n  - dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。\n\n```python\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        dp = [[] for i in range(n+1)]\n\n        dp[0].append('')\n        for i in range(n + 1):\n        \tfor j in range(i):\n        \t\t dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\n            \n        return dp[n]    \n        \n```","slug":"leetcode-GenerateParentheses","published":1,"updated":"2019-01-09T09:51:32.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82i002pkvpxztu9579r","content":"<h2 id=\"Generate-Parentheses\"><a href=\"#Generate-Parentheses\" class=\"headerlink\" title=\"Generate Parentheses\"></a><a href=\"https://leetcode.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">Generate Parentheses</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>（n 对括号所有组合形式）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong><br>For example, given n = 3, a solution set is:</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_22.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归-amp-深度优先搜索\"><a href=\"#1-递归-amp-深度优先搜索\" class=\"headerlink\" title=\"1. 递归 &amp; 深度优先搜索\"></a>1. 递归 &amp; 深度优先搜索</h3><p>这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： <strong>任何位置的之前的 NUM_( &gt;= NUM_)</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(left_remain, right_remain, s)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain == <span class=\"number\">0</span> <span class=\"keyword\">and</span> right_remain == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                generateParenthesis(left_remain<span class=\"number\">-1</span>, right_remain, s + <span class=\"string\">'('</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> right_remain &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> left_remain &lt; right_remain:</span><br><span class=\"line\">                generateParenthesis(left_remain, right_remain<span class=\"number\">-1</span>, s + <span class=\"string\">')'</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        generateParenthesis(n, n, <span class=\"string\">''</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>经过观察发现如下：</p>\n<ul>\n<li>n==0, result = [‘’]</li>\n<li>n==1, result = [<br>  () = ( + result_0 + ) + result_0<br>]</li>\n<li>n==2, result = [<br>()() = ( + result_0 + ) + result_1()<br>(()) = ( + result_1() + ) + result_0<br>]</li>\n<li>n==3, result = [<br>()()() = ( + result_0 + ) + result_2_1()()<br>()(()) = ( + result_0 + ) + result_2_2(())<br>(())() = ( + result_1() + ) + result_1()<br>(()()) = ( + result_2_1()() + ) + result_0<br>((())) = ( + result_2_2(()) + ) + result_0<br>]<br>因此我们可以得出如下结论：</li>\n<li>dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        dp = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>].append(<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">        \t\t dp[i] += [<span class=\"string\">'('</span> + x + <span class=\"string\">')'</span> + y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> dp[j] <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> dp[i - j - <span class=\"number\">1</span>]]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Generate-Parentheses\"><a href=\"#Generate-Parentheses\" class=\"headerlink\" title=\"Generate Parentheses\"></a><a href=\"https://leetcode.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">Generate Parentheses</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>（n 对括号所有组合形式）</p>","more":"<p><strong>Example:</strong><br>For example, given n = 3, a solution set is:</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_22.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归-amp-深度优先搜索\"><a href=\"#1-递归-amp-深度优先搜索\" class=\"headerlink\" title=\"1. 递归 &amp; 深度优先搜索\"></a>1. 递归 &amp; 深度优先搜索</h3><p>这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： <strong>任何位置的之前的 NUM_( &gt;= NUM_)</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(left_remain, right_remain, s)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain == <span class=\"number\">0</span> <span class=\"keyword\">and</span> right_remain == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_remain &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                generateParenthesis(left_remain<span class=\"number\">-1</span>, right_remain, s + <span class=\"string\">'('</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> right_remain &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> left_remain &lt; right_remain:</span><br><span class=\"line\">                generateParenthesis(left_remain, right_remain<span class=\"number\">-1</span>, s + <span class=\"string\">')'</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        generateParenthesis(n, n, <span class=\"string\">''</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>经过观察发现如下：</p>\n<ul>\n<li>n==0, result = [‘’]</li>\n<li>n==1, result = [<br>  () = ( + result_0 + ) + result_0<br>]</li>\n<li>n==2, result = [<br>()() = ( + result_0 + ) + result_1()<br>(()) = ( + result_1() + ) + result_0<br>]</li>\n<li>n==3, result = [<br>()()() = ( + result_0 + ) + result_2_1()()<br>()(()) = ( + result_0 + ) + result_2_2(())<br>(())() = ( + result_1() + ) + result_1()<br>(()()) = ( + result_2_1()() + ) + result_0<br>((())) = ( + result_2_2(()) + ) + result_0<br>]<br>因此我们可以得出如下结论：</li>\n<li>dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        dp = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>].append(<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">        \t\t dp[i] += [<span class=\"string\">'('</span> + x + <span class=\"string\">')'</span> + y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> dp[j] <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> dp[i - j - <span class=\"number\">1</span>]]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Jump Game","date":"2019-01-10T13:15:56.000Z","_content":"\n## [Jump Game](https://leetcode.com/problems/jump-game/)\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n(跳棋游戏，确定能否到达队尾)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_55.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 贪心算法\n遍历数组，求得可到达的最远 index。若index > n-1，则可以到达最后。具体实现方法如下：\n\n```python\nclass Solution:\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_index = 0\n        n = len(nums)\n        if n <= 1:\n            return True\n        \n        for i in range(n-1):\n            if max_index >= i:\n                max_index = max(max_index, i + nums[i])\n            if max_index >= n-1:\n                return True \n        return False\n```","source":"_posts/leetcode-JumpGame.md","raw":"---\ntitle: LeetCode_Jump Game\ndate: 2019-01-10 21:15:56\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - greedy\n---\n\n## [Jump Game](https://leetcode.com/problems/jump-game/)\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n(跳棋游戏，确定能否到达队尾)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_55.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 贪心算法\n遍历数组，求得可到达的最远 index。若index > n-1，则可以到达最后。具体实现方法如下：\n\n```python\nclass Solution:\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_index = 0\n        n = len(nums)\n        if n <= 1:\n            return True\n        \n        for i in range(n-1):\n            if max_index >= i:\n                max_index = max(max_index, i + nums[i])\n            if max_index >= n-1:\n                return True \n        return False\n```","slug":"leetcode-JumpGame","published":1,"updated":"2019-01-10T13:35:54.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82j002skvpx9rs7qs8j","content":"<h2 id=\"Jump-Game\"><a href=\"#Jump-Game\" class=\"headerlink\" title=\"Jump Game\"></a><a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">Jump Game</a></h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.<br>(跳棋游戏，确定能否到达队尾)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_55.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-贪心算法\"><a href=\"#1-贪心算法\" class=\"headerlink\" title=\"1. 贪心算法\"></a>1. 贪心算法</h3><p>遍历数组，求得可到达的最远 index。若index &gt; n-1，则可以到达最后。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canJump</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        max_index = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_index &gt;= i:</span><br><span class=\"line\">                max_index = max(max_index, i + nums[i])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_index &gt;= n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Jump-Game\"><a href=\"#Jump-Game\" class=\"headerlink\" title=\"Jump Game\"></a><a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">Jump Game</a></h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.<br>(跳棋游戏，确定能否到达队尾)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_55.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-贪心算法\"><a href=\"#1-贪心算法\" class=\"headerlink\" title=\"1. 贪心算法\"></a>1. 贪心算法</h3><p>遍历数组，求得可到达的最远 index。若index &gt; n-1，则可以到达最后。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canJump</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        max_index = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_index &gt;= i:</span><br><span class=\"line\">                max_index = max(max_index, i + nums[i])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_index &gt;= n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Jump Game II","date":"2019-01-09T03:14:52.000Z","_content":"\n## [Jump Game II](https://leetcode.com/problems/jump-game-ii/)\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.\n(跳棋游戏II，最小步到队尾)\n\n<!--more-->\n\n**Note:**\n You can assume that you can always reach the last index.\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_45.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 动态规划\n从后向前遍历数组，根据 i+1 ~ nums[i]+i 需要跳的步数来得到当前需要跳的最小步数。具体实现如下：\n**Note:** 特别需要注意的是在 nums 数组中为 0 的情况，需要单独考虑，否则上述的数组子集为空。\n\n```python\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        jumps = [0 for _ in range(n)]\n\n        for i in range(n-2, -1, -1):\n            if nums[i] == 0:\n                jumps[i] = n + 1 \n            elif nums[i] + i >= n-1:\n                jumps[i] = jumps[n-1] + 1 \n            else:\n                jumps[i] = min(jumps[i+1: i + nums[i] + 1]) + 1\n       \n        return jumps[0]\n```\n\n### 2. 贪心算法\n题目中说明了所有测试数据都有解，而且不需要知道具体的是如何到达最后一格的。可以通过贪心的思想从左向右遍历，每次都可获得到目前为止可以到达的最远的位置 curr_max_index；在遍历过程中，若当前的位置 i 超过了上一次跳动得到的最远的的位置 last_max_index ，则增加跳动的步数。具体实现过程如下：\n\n```python\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        step = 0\n        last_max_index = 0\n        curr_max_index = 0\n\n        for i in range(len(nums)):\n            if (i > last_max_index):\n                step += 1\n                last_max_index = curr_max_index\n            curr_max_index = max(curr_max_index, nums[i] + i)\n\n        return step\n```","source":"_posts/leetcode-JumpGameII.md","raw":"---\ntitle: LeetCode_Jump Game II\ndate: 2019-01-09 11:14:52\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - dynamic programming\n  - greedy\n---\n\n## [Jump Game II](https://leetcode.com/problems/jump-game-ii/)\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.\n(跳棋游戏II，最小步到队尾)\n\n<!--more-->\n\n**Note:**\n You can assume that you can always reach the last index.\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_45.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 动态规划\n从后向前遍历数组，根据 i+1 ~ nums[i]+i 需要跳的步数来得到当前需要跳的最小步数。具体实现如下：\n**Note:** 特别需要注意的是在 nums 数组中为 0 的情况，需要单独考虑，否则上述的数组子集为空。\n\n```python\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        jumps = [0 for _ in range(n)]\n\n        for i in range(n-2, -1, -1):\n            if nums[i] == 0:\n                jumps[i] = n + 1 \n            elif nums[i] + i >= n-1:\n                jumps[i] = jumps[n-1] + 1 \n            else:\n                jumps[i] = min(jumps[i+1: i + nums[i] + 1]) + 1\n       \n        return jumps[0]\n```\n\n### 2. 贪心算法\n题目中说明了所有测试数据都有解，而且不需要知道具体的是如何到达最后一格的。可以通过贪心的思想从左向右遍历，每次都可获得到目前为止可以到达的最远的位置 curr_max_index；在遍历过程中，若当前的位置 i 超过了上一次跳动得到的最远的的位置 last_max_index ，则增加跳动的步数。具体实现过程如下：\n\n```python\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        step = 0\n        last_max_index = 0\n        curr_max_index = 0\n\n        for i in range(len(nums)):\n            if (i > last_max_index):\n                step += 1\n                last_max_index = curr_max_index\n            curr_max_index = max(curr_max_index, nums[i] + i)\n\n        return step\n```","slug":"leetcode-JumpGameII","published":1,"updated":"2019-01-10T13:17:34.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82l002vkvpxy5ncz05s","content":"<h2 id=\"Jump-Game-II\"><a href=\"#Jump-Game-II\" class=\"headerlink\" title=\"Jump Game II\"></a><a href=\"https://leetcode.com/problems/jump-game-ii/\" target=\"_blank\" rel=\"noopener\">Jump Game II</a></h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.<br>(跳棋游戏II，最小步到队尾)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong><br> You can assume that you can always reach the last index.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_45.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>从后向前遍历数组，根据 i+1 ~ nums[i]+i 需要跳的步数来得到当前需要跳的最小步数。具体实现如下：<br><strong>Note:</strong> 特别需要注意的是在 nums 数组中为 0 的情况，需要单独考虑，否则上述的数组子集为空。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        jumps = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                jumps[i] = n + <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[i] + i &gt;= n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                jumps[i] = jumps[n<span class=\"number\">-1</span>] + <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                jumps[i] = min(jumps[i+<span class=\"number\">1</span>: i + nums[i] + <span class=\"number\">1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> jumps[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-贪心算法\"><a href=\"#2-贪心算法\" class=\"headerlink\" title=\"2. 贪心算法\"></a>2. 贪心算法</h3><p>题目中说明了所有测试数据都有解，而且不需要知道具体的是如何到达最后一格的。可以通过贪心的思想从左向右遍历，每次都可获得到目前为止可以到达的最远的位置 curr_max_index；在遍历过程中，若当前的位置 i 超过了上一次跳动得到的最远的的位置 last_max_index ，则增加跳动的步数。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        step = <span class=\"number\">0</span></span><br><span class=\"line\">        last_max_index = <span class=\"number\">0</span></span><br><span class=\"line\">        curr_max_index = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; last_max_index):</span><br><span class=\"line\">                step += <span class=\"number\">1</span></span><br><span class=\"line\">                last_max_index = curr_max_index</span><br><span class=\"line\">            curr_max_index = max(curr_max_index, nums[i] + i)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> step</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Jump-Game-II\"><a href=\"#Jump-Game-II\" class=\"headerlink\" title=\"Jump Game II\"></a><a href=\"https://leetcode.com/problems/jump-game-ii/\" target=\"_blank\" rel=\"noopener\">Jump Game II</a></h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.<br>(跳棋游戏II，最小步到队尾)</p>","more":"<p><strong>Note:</strong><br> You can assume that you can always reach the last index.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_45.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>从后向前遍历数组，根据 i+1 ~ nums[i]+i 需要跳的步数来得到当前需要跳的最小步数。具体实现如下：<br><strong>Note:</strong> 特别需要注意的是在 nums 数组中为 0 的情况，需要单独考虑，否则上述的数组子集为空。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        jumps = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                jumps[i] = n + <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[i] + i &gt;= n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                jumps[i] = jumps[n<span class=\"number\">-1</span>] + <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                jumps[i] = min(jumps[i+<span class=\"number\">1</span>: i + nums[i] + <span class=\"number\">1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> jumps[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-贪心算法\"><a href=\"#2-贪心算法\" class=\"headerlink\" title=\"2. 贪心算法\"></a>2. 贪心算法</h3><p>题目中说明了所有测试数据都有解，而且不需要知道具体的是如何到达最后一格的。可以通过贪心的思想从左向右遍历，每次都可获得到目前为止可以到达的最远的位置 curr_max_index；在遍历过程中，若当前的位置 i 超过了上一次跳动得到的最远的的位置 last_max_index ，则增加跳动的步数。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        step = <span class=\"number\">0</span></span><br><span class=\"line\">        last_max_index = <span class=\"number\">0</span></span><br><span class=\"line\">        curr_max_index = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; last_max_index):</span><br><span class=\"line\">                step += <span class=\"number\">1</span></span><br><span class=\"line\">                last_max_index = curr_max_index</span><br><span class=\"line\">            curr_max_index = max(curr_max_index, nums[i] + i)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> step</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Largest Rectangle in Histogram","date":"2019-02-23T08:51:00.000Z","_content":"\n## [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\n\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n（在条形图中取最大矩形面积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_84.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 堆栈\n维护一个栈来存储升序序列，当遇到当前 height 小于栈顶 height 时，考虑计算。以栈顶的高度为高，栈顶 index 到 i-1 为宽的矩形。其中在pop过程中栈顶为空时，则需要将其维护为 “-1”，因为当 stack 为空时，说明数组中的最小值（所有高度中的最小值已经pop出来了，因此前面的所有都可以算作面积）。其时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下：\n\n**Note:**\n1. 在 heights 尾部增加一个 “0” 是为了防止在数组尾部的最后一个升序序列没有计算，如[3, 4, 1, 3, 5, 7]。\n2. stack 存储的是 index 是为了方便计算矩形的 width。\n3. 可以事先维护 stack 为 [-1]，这样就不用考虑单独 stack 为空的情况了。\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        result = 0\n        heights.append(0)\n        for i, height in enumerate(heights):\n            while len(stack) > 0 and height < heights[stack[-1]]:\n                top = stack.pop()\n                if len(stack) == 0:\n                    start = -1\n                else:\n                    start = stack[-1]\n                result = max(result, heights[top] * (i-1-start))\n            stack.append(i)\n        \n        return result\n```","source":"_posts/leetcode-LargestRectangleinHistogram.md","raw":"---\ntitle: LeetCode_Largest Rectangle in Histogram\ndate: 2019-02-23 16:51:00\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - stack\n---\n\n## [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\n\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n（在条形图中取最大矩形面积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_84.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 堆栈\n维护一个栈来存储升序序列，当遇到当前 height 小于栈顶 height 时，考虑计算。以栈顶的高度为高，栈顶 index 到 i-1 为宽的矩形。其中在pop过程中栈顶为空时，则需要将其维护为 “-1”，因为当 stack 为空时，说明数组中的最小值（所有高度中的最小值已经pop出来了，因此前面的所有都可以算作面积）。其时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下：\n\n**Note:**\n1. 在 heights 尾部增加一个 “0” 是为了防止在数组尾部的最后一个升序序列没有计算，如[3, 4, 1, 3, 5, 7]。\n2. stack 存储的是 index 是为了方便计算矩形的 width。\n3. 可以事先维护 stack 为 [-1]，这样就不用考虑单独 stack 为空的情况了。\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        result = 0\n        heights.append(0)\n        for i, height in enumerate(heights):\n            while len(stack) > 0 and height < heights[stack[-1]]:\n                top = stack.pop()\n                if len(stack) == 0:\n                    start = -1\n                else:\n                    start = stack[-1]\n                result = max(result, heights[top] * (i-1-start))\n            stack.append(i)\n        \n        return result\n```","slug":"leetcode-LargestRectangleinHistogram","published":1,"updated":"2019-02-25T05:48:23.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82m002zkvpxfmbw5m81","content":"<h2 id=\"Largest-Rectangle-in-Histogram\"><a href=\"#Largest-Rectangle-in-Histogram\" class=\"headerlink\" title=\"Largest Rectangle in Histogram\"></a><a href=\"https://leetcode.com/problems/largest-rectangle-in-histogram/\" target=\"_blank\" rel=\"noopener\">Largest Rectangle in Histogram</a></h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br>（在条形图中取最大矩形面积）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_84.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-堆栈\"><a href=\"#1-堆栈\" class=\"headerlink\" title=\"1. 堆栈\"></a>1. 堆栈</h3><p>维护一个栈来存储升序序列，当遇到当前 height 小于栈顶 height 时，考虑计算。以栈顶的高度为高，栈顶 index 到 i-1 为宽的矩形。其中在pop过程中栈顶为空时，则需要将其维护为 “-1”，因为当 stack 为空时，说明数组中的最小值（所有高度中的最小值已经pop出来了，因此前面的所有都可以算作面积）。其时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下：</p>\n<p><strong>Note:</strong></p>\n<ol>\n<li>在 heights 尾部增加一个 “0” 是为了防止在数组尾部的最后一个升序序列没有计算，如[3, 4, 1, 3, 5, 7]。</li>\n<li>stack 存储的是 index 是为了方便计算矩形的 width。</li>\n<li>可以事先维护 stack 为 [-1]，这样就不用考虑单独 stack 为空的情况了。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        heights.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, height <span class=\"keyword\">in</span> enumerate(heights):</span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> height &lt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                top = stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    start = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    start = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">                result = max(result, heights[top] * (i<span class=\"number\">-1</span>-start))</span><br><span class=\"line\">            stack.append(i)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Largest-Rectangle-in-Histogram\"><a href=\"#Largest-Rectangle-in-Histogram\" class=\"headerlink\" title=\"Largest Rectangle in Histogram\"></a><a href=\"https://leetcode.com/problems/largest-rectangle-in-histogram/\" target=\"_blank\" rel=\"noopener\">Largest Rectangle in Histogram</a></h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br>（在条形图中取最大矩形面积）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_84.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-堆栈\"><a href=\"#1-堆栈\" class=\"headerlink\" title=\"1. 堆栈\"></a>1. 堆栈</h3><p>维护一个栈来存储升序序列，当遇到当前 height 小于栈顶 height 时，考虑计算。以栈顶的高度为高，栈顶 index 到 i-1 为宽的矩形。其中在pop过程中栈顶为空时，则需要将其维护为 “-1”，因为当 stack 为空时，说明数组中的最小值（所有高度中的最小值已经pop出来了，因此前面的所有都可以算作面积）。其时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下：</p>\n<p><strong>Note:</strong></p>\n<ol>\n<li>在 heights 尾部增加一个 “0” 是为了防止在数组尾部的最后一个升序序列没有计算，如[3, 4, 1, 3, 5, 7]。</li>\n<li>stack 存储的是 index 是为了方便计算矩形的 width。</li>\n<li>可以事先维护 stack 为 [-1]，这样就不用考虑单独 stack 为空的情况了。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        heights.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, height <span class=\"keyword\">in</span> enumerate(heights):</span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> height &lt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                top = stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    start = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    start = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">                result = max(result, heights[top] * (i<span class=\"number\">-1</span>-start))</span><br><span class=\"line\">            stack.append(i)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Letter Combinations of a Phone Number","date":"2018-11-30T12:28:46.000Z","_content":"\n## [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n（根据九宫格键盘将数字映射到字符）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_17.png\" width = \"500\" align=center/>\n</div>\n\n### 1. map / hash_table 进行索引\n这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了`digits == ''`的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。\n\n```python\nclass Solution:\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        dict = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        result = []\n        for ch in digits:\n            letter = dict[ch]\n            if len(result) == 0:\n                result = letter\n            else:\n                new_result = []\n                for a in result:\n                    for b in letter:\n                        new_result.append(a + b)\n                result = new_result\n                \n        return result \n```","source":"_posts/leetcode-LetterCombinationsofaPhoneNumber.md","raw":"---\ntitle: LeetCode_Letter Combinations of a Phone Number\ndate: 2018-11-30 20:28:46\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - back tracking\n---\n\n## [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n（根据九宫格键盘将数字映射到字符）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_17.png\" width = \"500\" align=center/>\n</div>\n\n### 1. map / hash_table 进行索引\n这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了`digits == ''`的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。\n\n```python\nclass Solution:\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        dict = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        result = []\n        for ch in digits:\n            letter = dict[ch]\n            if len(result) == 0:\n                result = letter\n            else:\n                new_result = []\n                for a in result:\n                    for b in letter:\n                        new_result.append(a + b)\n                result = new_result\n                \n        return result \n```","slug":"leetcode-LetterCombinationsofaPhoneNumber","published":1,"updated":"2019-01-09T09:51:23.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82n0032kvpxpz7ugla2","content":"<h2 id=\"Letter-Combinations-of-a-Phone-Number\"><a href=\"#Letter-Combinations-of-a-Phone-Number\" class=\"headerlink\" title=\"Letter Combinations of a Phone Number\"></a><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">Letter Combinations of a Phone Number</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>（根据九宫格键盘将数字映射到字符）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_17.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-map-hash-table-进行索引\"><a href=\"#1-map-hash-table-进行索引\" class=\"headerlink\" title=\"1. map / hash_table 进行索引\"></a>1. map / hash_table 进行索引</h3><p>这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了<code>digits == &#39;&#39;</code>的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type digits: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;</span><br><span class=\"line\">            <span class=\"string\">'2'</span>: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>],</span><br><span class=\"line\">            <span class=\"string\">'3'</span>: [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>],</span><br><span class=\"line\">            <span class=\"string\">'4'</span>: [<span class=\"string\">'g'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'i'</span>],</span><br><span class=\"line\">            <span class=\"string\">'5'</span>: [<span class=\"string\">'j'</span>, <span class=\"string\">'k'</span>, <span class=\"string\">'l'</span>],</span><br><span class=\"line\">            <span class=\"string\">'6'</span>: [<span class=\"string\">'m'</span>, <span class=\"string\">'n'</span>, <span class=\"string\">'o'</span>],</span><br><span class=\"line\">            <span class=\"string\">'7'</span>: [<span class=\"string\">'p'</span>, <span class=\"string\">'q'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'s'</span>],</span><br><span class=\"line\">            <span class=\"string\">'8'</span>: [<span class=\"string\">'t'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'v'</span>],</span><br><span class=\"line\">            <span class=\"string\">'9'</span>: [<span class=\"string\">'w'</span>, <span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'z'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> digits:</span><br><span class=\"line\">            letter = dict[ch]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result = letter</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_result = []</span><br><span class=\"line\">                <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> letter:</span><br><span class=\"line\">                        new_result.append(a + b)</span><br><span class=\"line\">                result = new_result</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Letter-Combinations-of-a-Phone-Number\"><a href=\"#Letter-Combinations-of-a-Phone-Number\" class=\"headerlink\" title=\"Letter Combinations of a Phone Number\"></a><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">Letter Combinations of a Phone Number</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>（根据九宫格键盘将数字映射到字符）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_17.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-map-hash-table-进行索引\"><a href=\"#1-map-hash-table-进行索引\" class=\"headerlink\" title=\"1. map / hash_table 进行索引\"></a>1. map / hash_table 进行索引</h3><p>这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了<code>digits == &#39;&#39;</code>的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type digits: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;</span><br><span class=\"line\">            <span class=\"string\">'2'</span>: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>],</span><br><span class=\"line\">            <span class=\"string\">'3'</span>: [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>],</span><br><span class=\"line\">            <span class=\"string\">'4'</span>: [<span class=\"string\">'g'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'i'</span>],</span><br><span class=\"line\">            <span class=\"string\">'5'</span>: [<span class=\"string\">'j'</span>, <span class=\"string\">'k'</span>, <span class=\"string\">'l'</span>],</span><br><span class=\"line\">            <span class=\"string\">'6'</span>: [<span class=\"string\">'m'</span>, <span class=\"string\">'n'</span>, <span class=\"string\">'o'</span>],</span><br><span class=\"line\">            <span class=\"string\">'7'</span>: [<span class=\"string\">'p'</span>, <span class=\"string\">'q'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'s'</span>],</span><br><span class=\"line\">            <span class=\"string\">'8'</span>: [<span class=\"string\">'t'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'v'</span>],</span><br><span class=\"line\">            <span class=\"string\">'9'</span>: [<span class=\"string\">'w'</span>, <span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'z'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> digits:</span><br><span class=\"line\">            letter = dict[ch]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                result = letter</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_result = []</span><br><span class=\"line\">                <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> letter:</span><br><span class=\"line\">                        new_result.append(a + b)</span><br><span class=\"line\">                result = new_result</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Longest Common Prefix","date":"2018-11-29T02:37:25.000Z","_content":"\n## [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)\n\nWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". \n（寻找最长公共前缀序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_14.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：\n```python\nclass Solution:\n    def commonPrefixof2(self, str1, str2):\n        result = \"\"\n        n = min(len(str1), len(str2))\n        for i in range(n):\n            if str1[i] == str2[i]:\n                result += str2[i]\n            else:\n                break\n        return result    \n        \n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        result = '' \n        n = len(strs)\n        \n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        elif n == 2:\n            return self.commonPrefixof2(strs[0], strs[1])\n        else: \n            result1 = self.longestCommonPrefix(strs[:n//2])\n            result2 = self.longestCommonPrefix(strs[n//2:])\n            return self.commonPrefixof2(result1, result2)\n```\n\n### 2. Zip函数 & Set\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\" \n        if not strs:\n            return \"\"\n        \n        for i, word in enumerate(zip(*strs)):\n            if len(set(word)) > 1:\n                return strs[0][:i]\n\n        return min(strs)\n```\n\n\n### 3. 字符子串组成Set\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        n = len(strs)\n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        length = min([len(s) for s in strs])\n        \n        while length > 0:\n            substrings = [s[:length] for s in strs]\n            if len(set(substrings)) == 1:\n                return substrings[0]\n            length -= 1\n        return \"\"\n```","source":"_posts/leetcode-LongestCommonPrefix.md","raw":"---\ntitle: LeetCode_Longest Common Prefix\ndate: 2018-11-29 10:37:25\ncategories: LeetCode\ntags: \n  - easy\n  - string\n---\n\n## [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)\n\nWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". \n（寻找最长公共前缀序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_14.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：\n```python\nclass Solution:\n    def commonPrefixof2(self, str1, str2):\n        result = \"\"\n        n = min(len(str1), len(str2))\n        for i in range(n):\n            if str1[i] == str2[i]:\n                result += str2[i]\n            else:\n                break\n        return result    \n        \n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        result = '' \n        n = len(strs)\n        \n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        elif n == 2:\n            return self.commonPrefixof2(strs[0], strs[1])\n        else: \n            result1 = self.longestCommonPrefix(strs[:n//2])\n            result2 = self.longestCommonPrefix(strs[n//2:])\n            return self.commonPrefixof2(result1, result2)\n```\n\n### 2. Zip函数 & Set\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\" \n        if not strs:\n            return \"\"\n        \n        for i, word in enumerate(zip(*strs)):\n            if len(set(word)) > 1:\n                return strs[0][:i]\n\n        return min(strs)\n```\n\n\n### 3. 字符子串组成Set\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        n = len(strs)\n        if n == 0:\n            return \"\"\n        elif n == 1:\n            return strs[0]\n        length = min([len(s) for s in strs])\n        \n        while length > 0:\n            substrings = [s[:length] for s in strs]\n            if len(set(substrings)) == 1:\n                return substrings[0]\n            length -= 1\n        return \"\"\n```","slug":"leetcode-LongestCommonPrefix","published":1,"updated":"2018-11-29T03:35:29.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82o0035kvpx3xwugzbf","content":"<h2 id=\"Longest-Common-Prefix\"><a href=\"#Longest-Common-Prefix\" class=\"headerlink\" title=\"Longest Common Prefix\"></a><a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">Longest Common Prefix</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.<br>（寻找最长公共前缀序列）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_14.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commonPrefixof2</span><span class=\"params\">(self, str1, str2)</span>:</span></span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = min(len(str1), len(str2))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i] == str2[i]:</span><br><span class=\"line\">                result += str2[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = <span class=\"string\">''</span> </span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(strs[<span class=\"number\">0</span>], strs[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: </span><br><span class=\"line\">            result1 = self.longestCommonPrefix(strs[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">            result2 = self.longestCommonPrefix(strs[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(result1, result2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Zip函数-amp-Set\"><a href=\"#2-Zip函数-amp-Set\" class=\"headerlink\" title=\"2. Zip函数 &amp; Set\"></a>2. Zip函数 &amp; Set</h3><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, word <span class=\"keyword\">in</span> enumerate(zip(*strs)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(word)) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>][:i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(strs)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-字符子串组成Set\"><a href=\"#3-字符子串组成Set\" class=\"headerlink\" title=\"3. 字符子串组成Set\"></a>3. 字符子串组成Set</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        length = min([len(s) <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> length &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            substrings = [s[:length] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(substrings)) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> substrings[<span class=\"number\">0</span>]</span><br><span class=\"line\">            length -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Common-Prefix\"><a href=\"#Longest-Common-Prefix\" class=\"headerlink\" title=\"Longest Common Prefix\"></a><a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">Longest Common Prefix</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.<br>（寻找最长公共前缀序列）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_14.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commonPrefixof2</span><span class=\"params\">(self, str1, str2)</span>:</span></span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = min(len(str1), len(str2))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i] == str2[i]:</span><br><span class=\"line\">                result += str2[i]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result    </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = <span class=\"string\">''</span> </span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(strs[<span class=\"number\">0</span>], strs[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: </span><br><span class=\"line\">            result1 = self.longestCommonPrefix(strs[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">            result2 = self.longestCommonPrefix(strs[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.commonPrefixof2(result1, result2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Zip函数-amp-Set\"><a href=\"#2-Zip函数-amp-Set\" class=\"headerlink\" title=\"2. Zip函数 &amp; Set\"></a>2. Zip函数 &amp; Set</h3><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, word <span class=\"keyword\">in</span> enumerate(zip(*strs)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(word)) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>][:i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(strs)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-字符子串组成Set\"><a href=\"#3-字符子串组成Set\" class=\"headerlink\" title=\"3. 字符子串组成Set\"></a>3. 字符子串组成Set</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type strs: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(strs)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>]</span><br><span class=\"line\">        length = min([len(s) <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> length &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            substrings = [s[:length] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strs]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(set(substrings)) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> substrings[<span class=\"number\">0</span>]</span><br><span class=\"line\">            length -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Length of Last Word","date":"2019-01-13T07:15:22.000Z","_content":"\n## [Length of Last Word](https://leetcode.com/problems/length-of-last-word/)\n\nGiven a string s consists of upper/lower-case alphabets and empty space characters “ ”, return the length of last word in the string. If the last word does not exist, return 0.\n（字符串最后一个单词的长度）\n\n<!--more-->\n\n**Note:**\nA word is defined as a character sequence consists of non-space characters only.\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_58.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 字符串处理\n本题考查`python`中基本的字符串处理函数，比较简单。具体实现方法如下：\n（其中之所以需要使用 `strip()` 是因为当字符串为 “a ” 时，最后一个单词应该是 \"a\"）\n\n```python\nclass Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n\n        words = s.strip().split(' ')\n\n        if len(words) == 0:\n\t        return 0\n        else:\n\t        return len(words[-1])\n```","source":"_posts/leetcode-LengthofLastWord.md","raw":"---\ntitle: LeetCode_Length of Last Word\ndate: 2019-01-13 15:15:22\ncategories: LeetCode\ntags: \n  - easy\n  - string\n---\n\n## [Length of Last Word](https://leetcode.com/problems/length-of-last-word/)\n\nGiven a string s consists of upper/lower-case alphabets and empty space characters “ ”, return the length of last word in the string. If the last word does not exist, return 0.\n（字符串最后一个单词的长度）\n\n<!--more-->\n\n**Note:**\nA word is defined as a character sequence consists of non-space characters only.\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_58.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 字符串处理\n本题考查`python`中基本的字符串处理函数，比较简单。具体实现方法如下：\n（其中之所以需要使用 `strip()` 是因为当字符串为 “a ” 时，最后一个单词应该是 \"a\"）\n\n```python\nclass Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n\n        words = s.strip().split(' ')\n\n        if len(words) == 0:\n\t        return 0\n        else:\n\t        return len(words[-1])\n```","slug":"leetcode-LengthofLastWord","published":1,"updated":"2019-01-13T07:30:46.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82p0037kvpxaxh3tlhk","content":"<h2 id=\"Length-of-Last-Word\"><a href=\"#Length-of-Last-Word\" class=\"headerlink\" title=\"Length of Last Word\"></a><a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">Length of Last Word</a></h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters “ ”, return the length of last word in the string. If the last word does not exist, return 0.<br>（字符串最后一个单词的长度）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong><br>A word is defined as a character sequence consists of non-space characters only.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_58.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-字符串处理\"><a href=\"#1-字符串处理\" class=\"headerlink\" title=\"1. 字符串处理\"></a>1. 字符串处理</h3><p>本题考查<code>python</code>中基本的字符串处理函数，比较简单。具体实现方法如下：<br>（其中之所以需要使用 <code>strip()</code> 是因为当字符串为 “a ” 时，最后一个单词应该是 “a”）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        words = s.strip().split(<span class=\"string\">' '</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(words) == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> len(words[<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Length-of-Last-Word\"><a href=\"#Length-of-Last-Word\" class=\"headerlink\" title=\"Length of Last Word\"></a><a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">Length of Last Word</a></h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters “ ”, return the length of last word in the string. If the last word does not exist, return 0.<br>（字符串最后一个单词的长度）</p>","more":"<p><strong>Note:</strong><br>A word is defined as a character sequence consists of non-space characters only.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_58.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-字符串处理\"><a href=\"#1-字符串处理\" class=\"headerlink\" title=\"1. 字符串处理\"></a>1. 字符串处理</h3><p>本题考查<code>python</code>中基本的字符串处理函数，比较简单。具体实现方法如下：<br>（其中之所以需要使用 <code>strip()</code> 是因为当字符串为 “a ” 时，最后一个单词应该是 “a”）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        words = s.strip().split(<span class=\"string\">' '</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(words) == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> len(words[<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Longest Substring Without Repeating Characters","date":"2018-11-23T06:33:59.000Z","_content":"\n## [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\nGiven a string, find the length of the longest substring without repeating characters.\n（字符串中的最大不重复子串）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_3.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力循环\n\n对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\\\(O(n^3)\\\\)。在测试过程中会 Time Limit Exceeded。\n\n### 2. 移动窗口 / 动态规划\n\n这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\\\(O(2n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        long = 0\n        i = 0\n        j = 0\n        \n        while(i < len(s) and j < len(s)):\n            if (s[j] not in d) or (d[s[j]] == 0):\n                d[s[j]] = 1\n                j += 1\n                long = max(long, j-i)\n            else:\n                d[s[i]] = 0\n                i += 1 \n        return long\n```\n\n上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        i = 0\n        j = 0\n        long = 0\n        while j < len(s) :\n            if s[j] in d and d[s[j]] > i:\n                i = d[s[j]]\n            else:\n            \tlong = max(long, j - i + 1)\n            d[s[j]] = j + 1\n            j += 1\n            \n        return long\n```\n\n**注**： 测试的时候考虑字符串为空等临界条件。\n\n\n\n\n\n\n","source":"_posts/leetcode-LongestSubstringWithoutRepeatingCharacters.md","raw":"---\ntitle: LeetCode_Longest Substring Without Repeating Characters\ndate: 2018-11-23 14:33:59\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - hash table\n  - dynamic programming\n---\n\n## [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\nGiven a string, find the length of the longest substring without repeating characters.\n（字符串中的最大不重复子串）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_3.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 暴力循环\n\n对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\\\(O(n^3)\\\\)。在测试过程中会 Time Limit Exceeded。\n\n### 2. 移动窗口 / 动态规划\n\n这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\\\(O(2n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        long = 0\n        i = 0\n        j = 0\n        \n        while(i < len(s) and j < len(s)):\n            if (s[j] not in d) or (d[s[j]] == 0):\n                d[s[j]] = 1\n                j += 1\n                long = max(long, j-i)\n            else:\n                d[s[i]] = 0\n                i += 1 \n        return long\n```\n\n上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\\\(O(n)\\\\)。具体实现过程如下：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        i = 0\n        j = 0\n        long = 0\n        while j < len(s) :\n            if s[j] in d and d[s[j]] > i:\n                i = d[s[j]]\n            else:\n            \tlong = max(long, j - i + 1)\n            d[s[j]] = j + 1\n            j += 1\n            \n        return long\n```\n\n**注**： 测试的时候考虑字符串为空等临界条件。\n\n\n\n\n\n\n","slug":"leetcode-LongestSubstringWithoutRepeatingCharacters","published":1,"updated":"2018-11-27T06:24:48.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82r0039kvpx2r0tt9qf","content":"<h2 id=\"Longest-Substring-Without-Repeating-Characters\"><a href=\"#Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"Longest Substring Without Repeating Characters\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">Longest Substring Without Repeating Characters</a></h2><p>Given a string, find the length of the longest substring without repeating characters.<br>（字符串中的最大不重复子串）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_3.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\(O(n^3)\\)。在测试过程中会 Time Limit Exceeded。</p>\n<h3 id=\"2-移动窗口-动态规划\"><a href=\"#2-移动窗口-动态规划\" class=\"headerlink\" title=\"2. 移动窗口 / 动态规划\"></a>2. 移动窗口 / 动态规划</h3><p>这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\(O(2n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len(s) <span class=\"keyword\">and</span> j &lt; len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[j] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> d) <span class=\"keyword\">or</span> (d[s[j]] == <span class=\"number\">0</span>):</span><br><span class=\"line\">                d[s[j]] = <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">                long = max(long, j-i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[s[i]] = <span class=\"number\">0</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p>上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(s) :</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> d[s[j]] &gt; i:</span><br><span class=\"line\">                i = d[s[j]]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            \tlong = max(long, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">            d[s[j]] = j + <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>： 测试的时候考虑字符串为空等临界条件。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Substring-Without-Repeating-Characters\"><a href=\"#Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"Longest Substring Without Repeating Characters\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">Longest Substring Without Repeating Characters</a></h2><p>Given a string, find the length of the longest substring without repeating characters.<br>（字符串中的最大不重复子串）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_3.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \\(O(n^3)\\)。在测试过程中会 Time Limit Exceeded。</p>\n<h3 id=\"2-移动窗口-动态规划\"><a href=\"#2-移动窗口-动态规划\" class=\"headerlink\" title=\"2. 移动窗口 / 动态规划\"></a>2. 移动窗口 / 动态规划</h3><p>这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \\(O(2n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len(s) <span class=\"keyword\">and</span> j &lt; len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[j] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> d) <span class=\"keyword\">or</span> (d[s[j]] == <span class=\"number\">0</span>):</span><br><span class=\"line\">                d[s[j]] = <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">                long = max(long, j-i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[s[i]] = <span class=\"number\">0</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p>上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \\(O(n)\\)。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        long = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(s) :</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> d[s[j]] &gt; i:</span><br><span class=\"line\">                i = d[s[j]]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            \tlong = max(long, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">            d[s[j]] = j + <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> long</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>： 测试的时候考虑字符串为空等临界条件。</p>"},{"title":"LeetCode_Longest Palindromic Substring","date":"2018-11-26T03:28:13.000Z","_content":"\n## [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\n\nGiven a string **s**, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n（寻找最长回文序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_5.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1.动态规划\n这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：\n\n\\\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\\\]\n\n然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\\\(O(n^2)\\\\)，空间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        dp = [[0] * n  for i in range(n)]\n    \n        result = ''\n        max_len = 0\n        for i in range(n):\n            dp[i][i] = 1\n            result = s[i]\n            max_len = 1\n        \n        for j in range(n):\n            for i in range(0, j):\n                if s[i] == s[j] and (dp[i+1][j-1] == 1 or i == j-1):\n                    dp[i][j] = 1\n                    if max_len <= j - i + 1:\n                        result = s[i:j+1]\n                        max_len = j - i + 1\n        \n        return result\n```\n\n","source":"_posts/leetcode-LongestPalindromicSubstring.md","raw":"---\ntitle: LeetCode_Longest Palindromic Substring\ndate: 2018-11-26 11:28:13\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - dynamic programming\n---\n\n## [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\n\nGiven a string **s**, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n（寻找最长回文序列）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_5.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1.动态规划\n这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：\n\n\\\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\\\]\n\n然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\\\(O(n^2)\\\\)，空间复杂度为 \\\\(O(n^2)\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        dp = [[0] * n  for i in range(n)]\n    \n        result = ''\n        max_len = 0\n        for i in range(n):\n            dp[i][i] = 1\n            result = s[i]\n            max_len = 1\n        \n        for j in range(n):\n            for i in range(0, j):\n                if s[i] == s[j] and (dp[i+1][j-1] == 1 or i == j-1):\n                    dp[i][j] = 1\n                    if max_len <= j - i + 1:\n                        result = s[i:j+1]\n                        max_len = j - i + 1\n        \n        return result\n```\n\n","slug":"leetcode-LongestPalindromicSubstring","published":1,"updated":"2018-11-27T06:24:40.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82u003ckvpxqhtqiza6","content":"<h2 id=\"Longest-Palindromic-Substring\"><a href=\"#Longest-Palindromic-Substring\" class=\"headerlink\" title=\"Longest Palindromic Substring\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">Longest Palindromic Substring</a></h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>（寻找最长回文序列）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_5.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：</p>\n<p>\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\]</p>\n<p>然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\(O(n^2)\\)，空间复杂度为 \\(O(n^2)\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>] * n  <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    </span><br><span class=\"line\">        result = <span class=\"string\">''</span></span><br><span class=\"line\">        max_len = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dp[i][i] = <span class=\"number\">1</span></span><br><span class=\"line\">            result = s[i]</span><br><span class=\"line\">            max_len = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[i] == s[j] <span class=\"keyword\">and</span> (dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>] == <span class=\"number\">1</span> <span class=\"keyword\">or</span> i == j<span class=\"number\">-1</span>):</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> max_len &lt;= j - i + <span class=\"number\">1</span>:</span><br><span class=\"line\">                        result = s[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">                        max_len = j - i + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Palindromic-Substring\"><a href=\"#Longest-Palindromic-Substring\" class=\"headerlink\" title=\"Longest Palindromic Substring\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">Longest Palindromic Substring</a></h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>（寻找最长回文序列）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_5.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这也是一道很典型的动态规划的题目。简单地来看可以有如下规律：</p>\n<p>\\[ if s[i] == s[j]\\ and\\ dp[i+1][j-1] == 1,\\ dp[i][j] = 1\\]</p>\n<p>然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \\(O(n^2)\\)，空间复杂度为 \\(O(n^2)\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>] * n  <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    </span><br><span class=\"line\">        result = <span class=\"string\">''</span></span><br><span class=\"line\">        max_len = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dp[i][i] = <span class=\"number\">1</span></span><br><span class=\"line\">            result = s[i]</span><br><span class=\"line\">            max_len = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[i] == s[j] <span class=\"keyword\">and</span> (dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>] == <span class=\"number\">1</span> <span class=\"keyword\">or</span> i == j<span class=\"number\">-1</span>):</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> max_len &lt;= j - i + <span class=\"number\">1</span>:</span><br><span class=\"line\">                        result = s[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">                        max_len = j - i + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Maximum Depth of Binary Tree","date":"2019-03-04T09:10:20.000Z","_content":"\n## [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\nGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n（二叉树的深度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_104.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n找到左子树和右子树的最大深度，从而返回该深度+1即为结果。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        max_depth = max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        return max_depth + 1\n```\n\n\n\n\n","source":"_posts/leetcode-MaximumDepthofBinaryTree.md","raw":"---\ntitle: LeetCode_Maximum Depth of Binary Tree\ndate: 2019-03-04 17:10:20\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n---\n\n## [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\nGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n（二叉树的深度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_104.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n找到左子树和右子树的最大深度，从而返回该深度+1即为结果。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        max_depth = max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        return max_depth + 1\n```\n\n\n\n\n","slug":"leetcode-MaximumDepthofBinaryTree","published":1,"updated":"2019-03-04T09:16:31.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82v003ekvpxhi0l2skc","content":"<h2 id=\"Maximum-Depth-of-Binary-Tree\"><a href=\"#Maximum-Depth-of-Binary-Tree\" class=\"headerlink\" title=\"Maximum Depth of Binary Tree\"></a><a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">Maximum Depth of Binary Tree</a></h2><p>Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br>（二叉树的深度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_104.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>找到左子树和右子树的最大深度，从而返回该深度+1即为结果。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        max_depth = max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_depth + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Maximum-Depth-of-Binary-Tree\"><a href=\"#Maximum-Depth-of-Binary-Tree\" class=\"headerlink\" title=\"Maximum Depth of Binary Tree\"></a><a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">Maximum Depth of Binary Tree</a></h2><p>Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br>（二叉树的深度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_104.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>找到左子树和右子树的最大深度，从而返回该深度+1即为结果。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        max_depth = max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_depth + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Longest Valid Parentheses","date":"2018-12-21T03:00:45.000Z","_content":"\n## [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)\n\nGiven a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n（最长有效括号对）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_32.png\" width = \"500\" align=center/>\n</div>\n\n### 1.动态规划\n这是一个很直观的动态规划的题目，需要分两种情况讨论：\n1. 当前字符为 ')' 且前一个字符为 '(' ，则动态规划公式可以为 dp[i] = dp[i-2] + 2\n2. 当前字符为 ')' 且前一个字符为 ')' ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 '(' 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。\n具体实现过程如下：\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        if n <= 1:\n            return 0\n        \n        dp = [0 for _ in range(n)]\n        \n        for i in range(1, n):\n            if s[i] == ')' and s[i-1] == '(':\n                if i >=2:\n                    dp[i] = dp[i-2] + 2\n                else:\n                    dp[i] = 2\n            if s[i] == ')' and s[i-1] == ')':\n                if i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n        \n        return max(dp)\n```\n\n### 2.栈 \n首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 '(' 就 push 进去新的index，遇到 ')' 就pop堆栈并分两种情况讨论：\n1. 此时堆栈为空，表示 ')' 的个数大于 '(' ，因此我们可以把此时的 index push进去，表示重新开始；\n2. 此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        stack = []\n        stack.append(-1)\n        \n        max_re = 0\n        for i, ch in enumerate(s):\n            if ch == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    stack.append(i)\n                else:\n                    max_re = max(max_re, i - stack[-1])\n                    \n        return max_re\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-LongestValidParentheses.md","raw":"---\ntitle: LeetCode_Longest Valid Parentheses\ndate: 2018-12-21 11:00:45\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n---\n\n## [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)\n\nGiven a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n（最长有效括号对）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_32.png\" width = \"500\" align=center/>\n</div>\n\n### 1.动态规划\n这是一个很直观的动态规划的题目，需要分两种情况讨论：\n1. 当前字符为 ')' 且前一个字符为 '(' ，则动态规划公式可以为 dp[i] = dp[i-2] + 2\n2. 当前字符为 ')' 且前一个字符为 ')' ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 '(' 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。\n具体实现过程如下：\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        if n <= 1:\n            return 0\n        \n        dp = [0 for _ in range(n)]\n        \n        for i in range(1, n):\n            if s[i] == ')' and s[i-1] == '(':\n                if i >=2:\n                    dp[i] = dp[i-2] + 2\n                else:\n                    dp[i] = 2\n            if s[i] == ')' and s[i-1] == ')':\n                if i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n        \n        return max(dp)\n```\n\n### 2.栈 \n首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 '(' 就 push 进去新的index，遇到 ')' 就pop堆栈并分两种情况讨论：\n1. 此时堆栈为空，表示 ')' 的个数大于 '(' ，因此我们可以把此时的 index push进去，表示重新开始；\n2. 此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        \n        stack = []\n        stack.append(-1)\n        \n        max_re = 0\n        for i, ch in enumerate(s):\n            if ch == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    stack.append(i)\n                else:\n                    max_re = max(max_re, i - stack[-1])\n                    \n        return max_re\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-LongestValidParentheses","published":1,"updated":"2018-12-21T04:01:02.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82w003hkvpx46szbsq7","content":"<h2 id=\"Longest-Valid-Parentheses\"><a href=\"#Longest-Valid-Parentheses\" class=\"headerlink\" title=\"Longest Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Longest Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.<br>（最长有效括号对）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_32.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这是一个很直观的动态规划的题目，需要分两种情况讨论：</p>\n<ol>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘(‘ ，则动态规划公式可以为 dp[i] = dp[i-2] + 2</li>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘)’ ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 ‘(‘ 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。<br>具体实现过程如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i] = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">')'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈\"><a href=\"#2-栈\" class=\"headerlink\" title=\"2.栈\"></a>2.栈</h3><p>首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 ‘(‘ 就 push 进去新的index，遇到 ‘)’ 就pop堆栈并分两种情况讨论：</p>\n<ol>\n<li>此时堆栈为空，表示 ‘)’ 的个数大于 ‘(‘ ，因此我们可以把此时的 index push进去，表示重新开始；</li>\n<li>此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        stack.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        max_re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, ch <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    stack.append(i)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    max_re = max(max_re, i - stack[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_re</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Longest-Valid-Parentheses\"><a href=\"#Longest-Valid-Parentheses\" class=\"headerlink\" title=\"Longest Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Longest Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.<br>（最长有效括号对）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_32.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1.动态规划\"></a>1.动态规划</h3><p>这是一个很直观的动态规划的题目，需要分两种情况讨论：</p>\n<ol>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘(‘ ，则动态规划公式可以为 dp[i] = dp[i-2] + 2</li>\n<li>当前字符为 ‘)’ 且前一个字符为 ‘)’ ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 ‘(‘ 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。<br>具体实现过程如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i] = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">')'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>] + <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈\"><a href=\"#2-栈\" class=\"headerlink\" title=\"2.栈\"></a>2.栈</h3><p>首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 ‘(‘ 就 push 进去新的index，遇到 ‘)’ 就pop堆栈并分两种情况讨论：</p>\n<ol>\n<li>此时堆栈为空，表示 ‘)’ 的个数大于 ‘(‘ ，因此我们可以把此时的 index push进去，表示重新开始；</li>\n<li>此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        stack.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        max_re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, ch <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    stack.append(i)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    max_re = max(max_re, i - stack[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_re</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Maximal Rectangle","date":"2019-02-25T02:56:42.000Z","_content":"\n## [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)\n\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n(最大矩形)\n\n<!--more-->\n\n**Follow up:**\n\nGiven a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_85.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 问题转换 & 栈\n基于上一题，**Largest Rectangle in Histogram**，我们可以考虑将这题中的求最大矩形面积转换为直方图中的求最大矩形的面积。通过遍历矩阵的每一行，将矩阵中纵列 “1” 的序列长度表示为直方图的高度，也就是我们求 m 个直方图中的最大矩形面积。具体实现过程如下：\n\n```python\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        n = len(matrix[0])\n        height = [0] * (n + 1)\n        ans = 0\n        for row in matrix:\n            for i in range(n):\n                height[i] = height[i] + 1 if row[i] == '1' else 0\n            stack = [-1]\n            for i in range(n + 1):\n                while height[i] < height[stack[-1]]:\n                    h = height[stack.pop()]\n                    w = i - 1 - stack[-1] \n                    ans = max(ans, h * w)\n                stack.append(i)\n        return ans\n```\n\n### 2. 动态规划 \n这道题的动态规划的算法方面不太好理解，不能直接用二维动规来解决问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def maximalRectangle(self, matrix: 'List[List[str]]') -> 'int':\n        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n   \n   \t\t# 对每一行进行计算, 递推公式如下:\n   \t\t#    每一行开始时,左边界 left 定为0, 右边界 right 定为n\n   \t\t#    height[j]好算:\n   \t\t#        如果matrix[i][j] = 0, height[j] = 0\n   \t\t#        如果matrix[i][j] = 1, height[j]++\n   \t\t#    left[j]从左往右算:\n   \t\t#        如果matrix[i][j] = 0, left[j]=0, 同时cur_left变为当前j+1(因为潜在的左边界可能就在j+1)\n   \t\t#        如果matrix[i][j] = 1, left[j]= max(left[j], cur_left), 哪个大取哪个.\n   \t\t#        (解释: 因为我们要的是过往所有行中0到该列位置最晚遇到1的位置)\n   \t\t#    right[j]从右往左算:\n   \t\t#        如果matrix[i][j] = 0, right[j]=n, 同时cur_right变为当前j(因为潜在的右边界就在当前j位置)\n   \t\t#        如果matrix[i][j] = 1, right[j]= min(right[j], cur_right), 哪个小取哪个.\n   \t\t#        (解释: 因为我们要的是过往所有行中COL-1到该列位置最早遇到0的位置)\n        left = [0 for _ in range(n)]\n        right = [n for _ in range(n)]\n        height = [0 for _ in range(n)]\n        \n        max_res = 0\n        for i in range(m):\n            cur_left = 0\n            cur_right = n\n            for j in range(n):\n                if  matrix[i][j] == '1':\n                    height[j] += 1\n                    left[j] = max(left[j], cur_left)\n                else:\n                    height[j] = 0\n                    left[j] = 0\n                    cur_left = j + 1\n            for j in range(n-1, -1, -1):\n                if matrix[i][j] == '1':\n                    right[j] = min(right[j], cur_right)\n                else:\n                    right[j] = n\n                    cur_right = j\n            for j in range(n):\n                max_res = max(max_res, (right[j] - left[j]) * height[j])\n        return max_res\n```\n","source":"_posts/leetcode-MaximalRectangle.md","raw":"---\ntitle: LeetCode_Maximal Rectangle\ndate: 2019-02-25 10:56:42\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - hash table\n  - dynamic programming\n  - stack\n---\n\n## [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)\n\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n(最大矩形)\n\n<!--more-->\n\n**Follow up:**\n\nGiven a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_85.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 问题转换 & 栈\n基于上一题，**Largest Rectangle in Histogram**，我们可以考虑将这题中的求最大矩形面积转换为直方图中的求最大矩形的面积。通过遍历矩阵的每一行，将矩阵中纵列 “1” 的序列长度表示为直方图的高度，也就是我们求 m 个直方图中的最大矩形面积。具体实现过程如下：\n\n```python\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        n = len(matrix[0])\n        height = [0] * (n + 1)\n        ans = 0\n        for row in matrix:\n            for i in range(n):\n                height[i] = height[i] + 1 if row[i] == '1' else 0\n            stack = [-1]\n            for i in range(n + 1):\n                while height[i] < height[stack[-1]]:\n                    h = height[stack.pop()]\n                    w = i - 1 - stack[-1] \n                    ans = max(ans, h * w)\n                stack.append(i)\n        return ans\n```\n\n### 2. 动态规划 \n这道题的动态规划的算法方面不太好理解，不能直接用二维动规来解决问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def maximalRectangle(self, matrix: 'List[List[str]]') -> 'int':\n        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n   \n   \t\t# 对每一行进行计算, 递推公式如下:\n   \t\t#    每一行开始时,左边界 left 定为0, 右边界 right 定为n\n   \t\t#    height[j]好算:\n   \t\t#        如果matrix[i][j] = 0, height[j] = 0\n   \t\t#        如果matrix[i][j] = 1, height[j]++\n   \t\t#    left[j]从左往右算:\n   \t\t#        如果matrix[i][j] = 0, left[j]=0, 同时cur_left变为当前j+1(因为潜在的左边界可能就在j+1)\n   \t\t#        如果matrix[i][j] = 1, left[j]= max(left[j], cur_left), 哪个大取哪个.\n   \t\t#        (解释: 因为我们要的是过往所有行中0到该列位置最晚遇到1的位置)\n   \t\t#    right[j]从右往左算:\n   \t\t#        如果matrix[i][j] = 0, right[j]=n, 同时cur_right变为当前j(因为潜在的右边界就在当前j位置)\n   \t\t#        如果matrix[i][j] = 1, right[j]= min(right[j], cur_right), 哪个小取哪个.\n   \t\t#        (解释: 因为我们要的是过往所有行中COL-1到该列位置最早遇到0的位置)\n        left = [0 for _ in range(n)]\n        right = [n for _ in range(n)]\n        height = [0 for _ in range(n)]\n        \n        max_res = 0\n        for i in range(m):\n            cur_left = 0\n            cur_right = n\n            for j in range(n):\n                if  matrix[i][j] == '1':\n                    height[j] += 1\n                    left[j] = max(left[j], cur_left)\n                else:\n                    height[j] = 0\n                    left[j] = 0\n                    cur_left = j + 1\n            for j in range(n-1, -1, -1):\n                if matrix[i][j] == '1':\n                    right[j] = min(right[j], cur_right)\n                else:\n                    right[j] = n\n                    cur_right = j\n            for j in range(n):\n                max_res = max(max_res, (right[j] - left[j]) * height[j])\n        return max_res\n```\n","slug":"leetcode-MaximalRectangle","published":1,"updated":"2019-02-25T06:31:03.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht82z003kkvpxhngqa6nb","content":"<h2 id=\"Maximal-Rectangle\"><a href=\"#Maximal-Rectangle\" class=\"headerlink\" title=\"Maximal Rectangle\"></a><a href=\"https://leetcode.com/problems/maximal-rectangle/\" target=\"_blank\" rel=\"noopener\">Maximal Rectangle</a></h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.<br>(最大矩形)</p>\n<a id=\"more\"></a>\n<p><strong>Follow up:</strong></p>\n<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_85.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-问题转换-amp-栈\"><a href=\"#1-问题转换-amp-栈\" class=\"headerlink\" title=\"1. 问题转换 &amp; 栈\"></a>1. 问题转换 &amp; 栈</h3><p>基于上一题，<strong>Largest Rectangle in Histogram</strong>，我们可以考虑将这题中的求最大矩形面积转换为直方图中的求最大矩形的面积。通过遍历矩阵的每一行，将矩阵中纵列 “1” 的序列长度表示为直方图的高度，也就是我们求 m 个直方图中的最大矩形面积。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">        height = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                height[i] = height[i] + <span class=\"number\">1</span> <span class=\"keyword\">if</span> row[i] == <span class=\"string\">'1'</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">            stack = [<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">while</span> height[i] &lt; height[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                    h = height[stack.pop()]</span><br><span class=\"line\">                    w = i - <span class=\"number\">1</span> - stack[<span class=\"number\">-1</span>] </span><br><span class=\"line\">                    ans = max(ans, h * w)</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>这道题的动态规划的算法方面不太好理解，不能直接用二维动规来解决问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[str]]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">   </span><br><span class=\"line\">   \t\t<span class=\"comment\"># 对每一行进行计算, 递推公式如下:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    每一行开始时,左边界 left 定为0, 右边界 right 定为n</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    height[j]好算:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 0, height[j] = 0</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 1, height[j]++</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    left[j]从左往右算:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 0, left[j]=0, 同时cur_left变为当前j+1(因为潜在的左边界可能就在j+1)</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 1, left[j]= max(left[j], cur_left), 哪个大取哪个.</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        (解释: 因为我们要的是过往所有行中0到该列位置最晚遇到1的位置)</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    right[j]从右往左算:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 0, right[j]=n, 同时cur_right变为当前j(因为潜在的右边界就在当前j位置)</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 1, right[j]= min(right[j], cur_right), 哪个小取哪个.</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        (解释: 因为我们要的是过往所有行中COL-1到该列位置最早遇到0的位置)</span></span><br><span class=\"line\">        left = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        right = [n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        height = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        max_res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            cur_left = <span class=\"number\">0</span></span><br><span class=\"line\">            cur_right = n</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span>  matrix[i][j] == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">                    height[j] += <span class=\"number\">1</span></span><br><span class=\"line\">                    left[j] = max(left[j], cur_left)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    height[j] = <span class=\"number\">0</span></span><br><span class=\"line\">                    left[j] = <span class=\"number\">0</span></span><br><span class=\"line\">                    cur_left = j + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">                    right[j] = min(right[j], cur_right)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right[j] = n</span><br><span class=\"line\">                    cur_right = j</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                max_res = max(max_res, (right[j] - left[j]) * height[j])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_res</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Maximal-Rectangle\"><a href=\"#Maximal-Rectangle\" class=\"headerlink\" title=\"Maximal Rectangle\"></a><a href=\"https://leetcode.com/problems/maximal-rectangle/\" target=\"_blank\" rel=\"noopener\">Maximal Rectangle</a></h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.<br>(最大矩形)</p>","more":"<p><strong>Follow up:</strong></p>\n<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_85.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-问题转换-amp-栈\"><a href=\"#1-问题转换-amp-栈\" class=\"headerlink\" title=\"1. 问题转换 &amp; 栈\"></a>1. 问题转换 &amp; 栈</h3><p>基于上一题，<strong>Largest Rectangle in Histogram</strong>，我们可以考虑将这题中的求最大矩形面积转换为直方图中的求最大矩形的面积。通过遍历矩阵的每一行，将矩阵中纵列 “1” 的序列长度表示为直方图的高度，也就是我们求 m 个直方图中的最大矩形面积。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">        height = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                height[i] = height[i] + <span class=\"number\">1</span> <span class=\"keyword\">if</span> row[i] == <span class=\"string\">'1'</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">            stack = [<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">while</span> height[i] &lt; height[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                    h = height[stack.pop()]</span><br><span class=\"line\">                    w = i - <span class=\"number\">1</span> - stack[<span class=\"number\">-1</span>] </span><br><span class=\"line\">                    ans = max(ans, h * w)</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>这道题的动态规划的算法方面不太好理解，不能直接用二维动规来解决问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[str]]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">   </span><br><span class=\"line\">   \t\t<span class=\"comment\"># 对每一行进行计算, 递推公式如下:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    每一行开始时,左边界 left 定为0, 右边界 right 定为n</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    height[j]好算:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 0, height[j] = 0</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 1, height[j]++</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    left[j]从左往右算:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 0, left[j]=0, 同时cur_left变为当前j+1(因为潜在的左边界可能就在j+1)</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 1, left[j]= max(left[j], cur_left), 哪个大取哪个.</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        (解释: 因为我们要的是过往所有行中0到该列位置最晚遇到1的位置)</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#    right[j]从右往左算:</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 0, right[j]=n, 同时cur_right变为当前j(因为潜在的右边界就在当前j位置)</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        如果matrix[i][j] = 1, right[j]= min(right[j], cur_right), 哪个小取哪个.</span></span><br><span class=\"line\">   \t\t<span class=\"comment\">#        (解释: 因为我们要的是过往所有行中COL-1到该列位置最早遇到0的位置)</span></span><br><span class=\"line\">        left = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        right = [n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        height = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        max_res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            cur_left = <span class=\"number\">0</span></span><br><span class=\"line\">            cur_right = n</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span>  matrix[i][j] == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">                    height[j] += <span class=\"number\">1</span></span><br><span class=\"line\">                    left[j] = max(left[j], cur_left)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    height[j] = <span class=\"number\">0</span></span><br><span class=\"line\">                    left[j] = <span class=\"number\">0</span></span><br><span class=\"line\">                    cur_left = j + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">                    right[j] = min(right[j], cur_right)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right[j] = n</span><br><span class=\"line\">                    cur_right = j</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                max_res = max(max_res, (right[j] - left[j]) * height[j])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_res</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Interleaving String","date":"2019-02-27T12:45:31.000Z","_content":"\n## [Interleaving String](https://leetcode.com/problems/interleaving-string/)\n\nGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n（判断s1 与 s2 相互插入可否组成 s3）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_97.png\" width = \"500\" align=center/>\n</div>\n\n**字符串匹配 & 动态规划 死锁**\n\n### 1. 动态规划\ndp[i][j]表示用 s1 的前 i 个字符和 s2 的前 j 个字符能不能按照规则表示出 s3 的前 i+j 个字符。\n递推表达式为：\ndp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1]) \n其中需要注意维护边界，具体实现过程如下：\n\n```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        len1, len2, len3 = len(s1), len(s2), len(s3)\n        if len1 + len2 != len3:\n            return False\n        \n        dp = [[False] * (len2 + 1) for _ in range(len1 + 1)]\n        \n        for i in range(len1+1):\n            for j in range(len2+1):\n                if i==0 and j==0:\n                    dp[i][j] = True\n                elif i==0:\n                    dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n                elif j==0:\n                    dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n                else:\n                    dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1]) \n        \n        return dp[len1][len2]\n```","source":"_posts/leetcode-InterleavingString.md","raw":"---\ntitle: LeetCode_Interleaving String\ndate: 2019-02-27 20:45:31\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - dynamic programming\n---\n\n## [Interleaving String](https://leetcode.com/problems/interleaving-string/)\n\nGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n（判断s1 与 s2 相互插入可否组成 s3）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_97.png\" width = \"500\" align=center/>\n</div>\n\n**字符串匹配 & 动态规划 死锁**\n\n### 1. 动态规划\ndp[i][j]表示用 s1 的前 i 个字符和 s2 的前 j 个字符能不能按照规则表示出 s3 的前 i+j 个字符。\n递推表达式为：\ndp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1]) \n其中需要注意维护边界，具体实现过程如下：\n\n```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        len1, len2, len3 = len(s1), len(s2), len(s3)\n        if len1 + len2 != len3:\n            return False\n        \n        dp = [[False] * (len2 + 1) for _ in range(len1 + 1)]\n        \n        for i in range(len1+1):\n            for j in range(len2+1):\n                if i==0 and j==0:\n                    dp[i][j] = True\n                elif i==0:\n                    dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n                elif j==0:\n                    dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n                else:\n                    dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1]) \n        \n        return dp[len1][len2]\n```","slug":"leetcode-InterleavingString","published":1,"updated":"2019-02-27T13:06:20.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht833003okvpxw3kfdski","content":"<h2 id=\"Interleaving-String\"><a href=\"#Interleaving-String\" class=\"headerlink\" title=\"Interleaving String\"></a><a href=\"https://leetcode.com/problems/interleaving-string/\" target=\"_blank\" rel=\"noopener\">Interleaving String</a></h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.<br>（判断s1 与 s2 相互插入可否组成 s3）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_97.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p><strong>字符串匹配 &amp; 动态规划 死锁</strong></p>\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>dp[i][j]表示用 s1 的前 i 个字符和 s2 的前 j 个字符能不能按照规则表示出 s3 的前 i+j 个字符。<br>递推表达式为：<br>dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1])<br>其中需要注意维护边界，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isInterleave</span><span class=\"params\">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        len1, len2, len3 = len(s1), len(s2), len(s3)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len1 + len2 != len3:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len2 + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len1 + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len1+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len2+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"keyword\">True</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> s2[j<span class=\"number\">-1</span>] == s3[j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][<span class=\"number\">0</span>] = dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] <span class=\"keyword\">and</span> s1[i<span class=\"number\">-1</span>] == s3[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = (dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> s2[j<span class=\"number\">-1</span>] == s3[i + j <span class=\"number\">-1</span>]) <span class=\"keyword\">or</span> (dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> s1[i<span class=\"number\">-1</span>] == s3[i + j <span class=\"number\">-1</span>]) </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len1][len2]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Interleaving-String\"><a href=\"#Interleaving-String\" class=\"headerlink\" title=\"Interleaving String\"></a><a href=\"https://leetcode.com/problems/interleaving-string/\" target=\"_blank\" rel=\"noopener\">Interleaving String</a></h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.<br>（判断s1 与 s2 相互插入可否组成 s3）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_97.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p><strong>字符串匹配 &amp; 动态规划 死锁</strong></p>\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>dp[i][j]表示用 s1 的前 i 个字符和 s2 的前 j 个字符能不能按照规则表示出 s3 的前 i+j 个字符。<br>递推表达式为：<br>dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1])<br>其中需要注意维护边界，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isInterleave</span><span class=\"params\">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        len1, len2, len3 = len(s1), len(s2), len(s3)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len1 + len2 != len3:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len2 + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len1 + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len1+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len2+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"keyword\">True</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> s2[j<span class=\"number\">-1</span>] == s3[j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][<span class=\"number\">0</span>] = dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] <span class=\"keyword\">and</span> s1[i<span class=\"number\">-1</span>] == s3[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = (dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> s2[j<span class=\"number\">-1</span>] == s3[i + j <span class=\"number\">-1</span>]) <span class=\"keyword\">or</span> (dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> s1[i<span class=\"number\">-1</span>] == s3[i + j <span class=\"number\">-1</span>]) </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len1][len2]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Median of Two Sorted Arrays","date":"2018-11-23T10:30:10.000Z","_content":"\n## [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\nThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be **O(log (m+n))**. You may assume nums1 and nums2 cannot be both empty.\n（两个有序数组的中位数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_4.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法_1\n我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\\\((m+n)\\\\)个数中的第\\\\((m+n)/2\\\\)数值的大小（需要单独考虑\\\\((m+n)\\\\)的奇偶性）。其时间复杂度为 \\\\(O(log(m+n))\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def findKth(self, nums1, nums2, k):\n        if not nums1:\n            return nums2[k]\n        if not nums2:\n            return nums1[k]\n        \n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        i, j = len1 // 2, len2 // 2\n        \n        if i + j < k:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1, nums2[j+1:], k-j-1)\n            else:\n                return self.findKth(nums1[i+1: ], nums2, k-i-1)\n        else:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1[:i], nums2, k)\n            else:\n                return self.findKth(nums1, nums2[:j], k)\n                \n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        length = len(nums1) + len(nums2)\n        \n        if length % 2:\n            return self.findKth(nums1, nums2, length//2)\n        else:\n            return (self.findKth(nums1, nums2, length//2) + self.findKth(nums1, nums2, length//2-1))/2\n```\n\n### 2. 分治法_2\n与上面的思路相同，但是不同的是找第 \\\\(k\\\\) 个值时，并不是直接将两个数组混合一起找第 \\\\(k\\\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\\\(i\\\\)，使得 \\\\(A[i]\\\\) 和 \\\\(B[k-i]\\\\) 刚好满足其中一个是第\\\\(k\\\\)个数。其时间复杂度为 \\\\(O(log(min(m, n)))\\\\)。具体实现过程如下：\n```python\ndef findKth(self, nums1, nums2, k):\n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        if len1 > len2:\n            len1, len2, nums1, nums2 = len2, len1, nums2, nums1\n        if not nums1:\n            return nums2[k]\n        if k == len1 + len2 - 1:\n            return max(nums1[-1], nums2[-1])\n        \n        i = len1 // 2\n        j = k - i\n        \n        if nums1[i] > nums2[j]:\n            # Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.\n            return self.findKth(nums1[:i], nums2[j:], i)\n        else:\n            return self.findKth(nums1[i:], nums2[:j], j)\n```\n\n### 3. Sort()函数\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        num = sorted(nums1 + nums2)\n        l = len(num)\n        if l%2 == 0:\n            return((num[l//2] + num[l//2-1])/2)\n        if l%2 != 0:\n            return(num[l//2])\n```","source":"_posts/leetcode-MedianofTwoSortedArrays.md","raw":"---\ntitle: LeetCode_Median of Two Sorted Arrays\ndate: 2018-11-23 18:30:10\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - binary search\n  - divide and conquer\n---\n\n## [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\nThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be **O(log (m+n))**. You may assume nums1 and nums2 cannot be both empty.\n（两个有序数组的中位数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_4.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法_1\n我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\\\((m+n)\\\\)个数中的第\\\\((m+n)/2\\\\)数值的大小（需要单独考虑\\\\((m+n)\\\\)的奇偶性）。其时间复杂度为 \\\\(O(log(m+n))\\\\)。具体实现过程如下：\n```python\nclass Solution:\n    def findKth(self, nums1, nums2, k):\n        if not nums1:\n            return nums2[k]\n        if not nums2:\n            return nums1[k]\n        \n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        i, j = len1 // 2, len2 // 2\n        \n        if i + j < k:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1, nums2[j+1:], k-j-1)\n            else:\n                return self.findKth(nums1[i+1: ], nums2, k-i-1)\n        else:\n            if nums1[i] > nums2[j]:\n                return self.findKth(nums1[:i], nums2, k)\n            else:\n                return self.findKth(nums1, nums2[:j], k)\n                \n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        length = len(nums1) + len(nums2)\n        \n        if length % 2:\n            return self.findKth(nums1, nums2, length//2)\n        else:\n            return (self.findKth(nums1, nums2, length//2) + self.findKth(nums1, nums2, length//2-1))/2\n```\n\n### 2. 分治法_2\n与上面的思路相同，但是不同的是找第 \\\\(k\\\\) 个值时，并不是直接将两个数组混合一起找第 \\\\(k\\\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\\\(i\\\\)，使得 \\\\(A[i]\\\\) 和 \\\\(B[k-i]\\\\) 刚好满足其中一个是第\\\\(k\\\\)个数。其时间复杂度为 \\\\(O(log(min(m, n)))\\\\)。具体实现过程如下：\n```python\ndef findKth(self, nums1, nums2, k):\n        len1 = len(nums1)\n        len2 = len(nums2)\n        \n        if len1 > len2:\n            len1, len2, nums1, nums2 = len2, len1, nums2, nums1\n        if not nums1:\n            return nums2[k]\n        if k == len1 + len2 - 1:\n            return max(nums1[-1], nums2[-1])\n        \n        i = len1 // 2\n        j = k - i\n        \n        if nums1[i] > nums2[j]:\n            # Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.\n            return self.findKth(nums1[:i], nums2[j:], i)\n        else:\n            return self.findKth(nums1[i:], nums2[:j], j)\n```\n\n### 3. Sort()函数\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        num = sorted(nums1 + nums2)\n        l = len(num)\n        if l%2 == 0:\n            return((num[l//2] + num[l//2-1])/2)\n        if l%2 != 0:\n            return(num[l//2])\n```","slug":"leetcode-MedianofTwoSortedArrays","published":1,"updated":"2018-11-29T03:23:37.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht834003rkvpxv5strfep","content":"<h2 id=\"Median-of-Two-Sorted-Arrays\"><a href=\"#Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"Median of Two Sorted Arrays\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">Median of Two Sorted Arrays</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be <strong>O(log (m+n))</strong>. You may assume nums1 and nums2 cannot be both empty.<br>（两个有序数组的中位数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_4.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法-1\"><a href=\"#1-分治法-1\" class=\"headerlink\" title=\"1. 分治法_1\"></a>1. 分治法_1</h3><p>我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\((m+n)\\)个数中的第\\((m+n)/2\\)数值的大小（需要单独考虑\\((m+n)\\)的奇偶性）。其时间复杂度为 \\(O(log(m+n))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums1[k]</span><br><span class=\"line\">        </span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        i, j = len1 // <span class=\"number\">2</span>, len2 // <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + j &lt; k:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[j+<span class=\"number\">1</span>:], k-j<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[i+<span class=\"number\">1</span>: ], nums2, k-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2, k)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[:j], k)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        length = len(nums1) + len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> length % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1, nums2, length//<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.findKth(nums1, nums2, length//<span class=\"number\">2</span>) + self.findKth(nums1, nums2, length//<span class=\"number\">2</span><span class=\"number\">-1</span>))/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-分治法-2\"><a href=\"#2-分治法-2\" class=\"headerlink\" title=\"2. 分治法_2\"></a>2. 分治法_2</h3><p>与上面的思路相同，但是不同的是找第 \\(k\\) 个值时，并不是直接将两个数组混合一起找第 \\(k\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\(i\\)，使得 \\(A[i]\\) 和 \\(B[k-i]\\) 刚好满足其中一个是第\\(k\\)个数。其时间复杂度为 \\(O(log(min(m, n)))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len1 &gt; len2:</span><br><span class=\"line\">            len1, len2, nums1, nums2 = len2, len1, nums2, nums1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == len1 + len2 - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max(nums1[<span class=\"number\">-1</span>], nums2[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = len1 // <span class=\"number\">2</span></span><br><span class=\"line\">        j = k - i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">            <span class=\"comment\"># Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2[j:], i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[i:], nums2[:j], j)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-Sort-函数\"><a href=\"#3-Sort-函数\" class=\"headerlink\" title=\"3. Sort()函数\"></a>3. Sort()函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num = sorted(nums1 + nums2)</span><br><span class=\"line\">        l = len(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>((num[l//<span class=\"number\">2</span>] + num[l//<span class=\"number\">2</span><span class=\"number\">-1</span>])/<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>(num[l//<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Median-of-Two-Sorted-Arrays\"><a href=\"#Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"Median of Two Sorted Arrays\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">Median of Two Sorted Arrays</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be <strong>O(log (m+n))</strong>. You may assume nums1 and nums2 cannot be both empty.<br>（两个有序数组的中位数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_4.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法-1\"><a href=\"#1-分治法-1\" class=\"headerlink\" title=\"1. 分治法_1\"></a>1. 分治法_1</h3><p>我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\\((m+n)\\)个数中的第\\((m+n)/2\\)数值的大小（需要单独考虑\\((m+n)\\)的奇偶性）。其时间复杂度为 \\(O(log(m+n))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums1[k]</span><br><span class=\"line\">        </span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        i, j = len1 // <span class=\"number\">2</span>, len2 // <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + j &lt; k:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[j+<span class=\"number\">1</span>:], k-j<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[i+<span class=\"number\">1</span>: ], nums2, k-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2, k)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.findKth(nums1, nums2[:j], k)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        length = len(nums1) + len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> length % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1, nums2, length//<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.findKth(nums1, nums2, length//<span class=\"number\">2</span>) + self.findKth(nums1, nums2, length//<span class=\"number\">2</span><span class=\"number\">-1</span>))/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-分治法-2\"><a href=\"#2-分治法-2\" class=\"headerlink\" title=\"2. 分治法_2\"></a>2. 分治法_2</h3><p>与上面的思路相同，但是不同的是找第 \\(k\\) 个值时，并不是直接将两个数组混合一起找第 \\(k\\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \\(i\\)，使得 \\(A[i]\\) 和 \\(B[k-i]\\) 刚好满足其中一个是第\\(k\\)个数。其时间复杂度为 \\(O(log(min(m, n)))\\)。具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKth</span><span class=\"params\">(self, nums1, nums2, k)</span>:</span></span><br><span class=\"line\">        len1 = len(nums1)</span><br><span class=\"line\">        len2 = len(nums2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len1 &gt; len2:</span><br><span class=\"line\">            len1, len2, nums1, nums2 = len2, len1, nums2, nums1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums2[k]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == len1 + len2 - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max(nums1[<span class=\"number\">-1</span>], nums2[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = len1 // <span class=\"number\">2</span></span><br><span class=\"line\">        j = k - i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">            <span class=\"comment\"># Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[:i], nums2[j:], i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.findKth(nums1[i:], nums2[:j], j)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-Sort-函数\"><a href=\"#3-Sort-函数\" class=\"headerlink\" title=\"3. Sort()函数\"></a>3. Sort()函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums1: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type nums2: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num = sorted(nums1 + nums2)</span><br><span class=\"line\">        l = len(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>((num[l//<span class=\"number\">2</span>] + num[l//<span class=\"number\">2</span><span class=\"number\">-1</span>])/<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>(num[l//<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Maximum Subarray","date":"2019-01-09T14:16:20.000Z","_content":"\n## [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)\n\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n(数组连续子串的和最大)\n\n<!--more-->\n\n**Follow up:**\n\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_53.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n这个题目写出动规表达式就很容易得到具体的解法：dp[i+1] = max(dp[i]+nums[i+1], nums[i+1])。具体的解法如下：\n\n```python\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [nums[0] for _ in range(n)]\n        \n        for i in range(1, n):\n\t        dp[i] = max(dp[i-1] + nums[i], nums[i])\n\n        return max(dp)\n```\n\n### 2. 分治法\n\n题中要求使用分治法来解决这个问题，我们可以分 3 类情况来讨论。对于一个数组 nums 的 [left, right]子串，其中点为 mid = (left + right) // 2，\n1. 答案序列完全在[left, mid - 1]中；\n2. 答案序列完全在[mid + 1, right]中；\n3. 答案序列为包含 mid 的左右延续的序列。\n\n```python\nclass Solution:\n    def divide(self, left, right):\n        if (left > right):\n            return self.nums[0]\n        \n        # divide and conquer         \n        mid = (left + right) // 2\n        left_max = self.divide(left, mid-1)\n        right_max = self.divide(mid+1, right)\n\n        # situation 3 left part        \n        sum = 0\n        max_lsum = 0\n        for i in range(mid-1, left-1, -1):\n            sum += self.nums[i]\n            max_lsum = max(max_lsum, sum)\n\n        # situation 3 right part \n        sum = 0\n        max_rsum = 0\n        for i in range(mid+1, right+1):\n            sum += self.nums[i]\n            max_rsum = max(max_rsum, sum)\n\n        max_sum = max(left_max, right_max)\n        max_sum = max(max_sum, max_lsum + self.nums[mid] + max_rsum)\n\n        return max_sum\n    \n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        self.nums = nums\n        n = len(nums)\n        return self.divide(0, n-1)\n\n```\n\n","source":"_posts/leetcode-MaximumSubarray.md","raw":"---\ntitle: LeetCode_Maximum Subarray\ndate: 2019-01-09 22:16:20\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - divide and conquer\n  - dynamic programming\n---\n\n## [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)\n\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n(数组连续子串的和最大)\n\n<!--more-->\n\n**Follow up:**\n\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_53.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n这个题目写出动规表达式就很容易得到具体的解法：dp[i+1] = max(dp[i]+nums[i+1], nums[i+1])。具体的解法如下：\n\n```python\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [nums[0] for _ in range(n)]\n        \n        for i in range(1, n):\n\t        dp[i] = max(dp[i-1] + nums[i], nums[i])\n\n        return max(dp)\n```\n\n### 2. 分治法\n\n题中要求使用分治法来解决这个问题，我们可以分 3 类情况来讨论。对于一个数组 nums 的 [left, right]子串，其中点为 mid = (left + right) // 2，\n1. 答案序列完全在[left, mid - 1]中；\n2. 答案序列完全在[mid + 1, right]中；\n3. 答案序列为包含 mid 的左右延续的序列。\n\n```python\nclass Solution:\n    def divide(self, left, right):\n        if (left > right):\n            return self.nums[0]\n        \n        # divide and conquer         \n        mid = (left + right) // 2\n        left_max = self.divide(left, mid-1)\n        right_max = self.divide(mid+1, right)\n\n        # situation 3 left part        \n        sum = 0\n        max_lsum = 0\n        for i in range(mid-1, left-1, -1):\n            sum += self.nums[i]\n            max_lsum = max(max_lsum, sum)\n\n        # situation 3 right part \n        sum = 0\n        max_rsum = 0\n        for i in range(mid+1, right+1):\n            sum += self.nums[i]\n            max_rsum = max(max_rsum, sum)\n\n        max_sum = max(left_max, right_max)\n        max_sum = max(max_sum, max_lsum + self.nums[mid] + max_rsum)\n\n        return max_sum\n    \n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        self.nums = nums\n        n = len(nums)\n        return self.divide(0, n-1)\n\n```\n\n","slug":"leetcode-MaximumSubarray","published":1,"updated":"2019-01-10T03:15:51.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht836003vkvpxvjpm99qs","content":"<h2 id=\"Maximum-Subarray\"><a href=\"#Maximum-Subarray\" class=\"headerlink\" title=\"Maximum Subarray\"></a><a href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">Maximum Subarray</a></h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.<br>(数组连续子串的和最大)</p>\n<a id=\"more\"></a>\n<p><strong>Follow up:</strong></p>\n<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_53.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这个题目写出动规表达式就很容易得到具体的解法：dp[i+1] = max(dp[i]+nums[i+1], nums[i+1])。具体的解法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        dp = [nums[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">\t        dp[i] = max(dp[i<span class=\"number\">-1</span>] + nums[i], nums[i])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-分治法\"><a href=\"#2-分治法\" class=\"headerlink\" title=\"2. 分治法\"></a>2. 分治法</h3><p>题中要求使用分治法来解决这个问题，我们可以分 3 类情况来讨论。对于一个数组 nums 的 [left, right]子串，其中点为 mid = (left + right) // 2，</p>\n<ol>\n<li>答案序列完全在[left, mid - 1]中；</li>\n<li>答案序列完全在[mid + 1, right]中；</li>\n<li>答案序列为包含 mid 的左右延续的序列。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># divide and conquer         </span></span><br><span class=\"line\">        mid = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">        left_max = self.divide(left, mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        right_max = self.divide(mid+<span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># situation 3 left part        </span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">        max_lsum = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(mid<span class=\"number\">-1</span>, left<span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            sum += self.nums[i]</span><br><span class=\"line\">            max_lsum = max(max_lsum, sum)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># situation 3 right part </span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">        max_rsum = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(mid+<span class=\"number\">1</span>, right+<span class=\"number\">1</span>):</span><br><span class=\"line\">            sum += self.nums[i]</span><br><span class=\"line\">            max_rsum = max(max_rsum, sum)</span><br><span class=\"line\"></span><br><span class=\"line\">        max_sum = max(left_max, right_max)</span><br><span class=\"line\">        max_sum = max(max_sum, max_lsum + self.nums[mid] + max_rsum)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_sum</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.divide(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Maximum-Subarray\"><a href=\"#Maximum-Subarray\" class=\"headerlink\" title=\"Maximum Subarray\"></a><a href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">Maximum Subarray</a></h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.<br>(数组连续子串的和最大)</p>","more":"<p><strong>Follow up:</strong></p>\n<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_53.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这个题目写出动规表达式就很容易得到具体的解法：dp[i+1] = max(dp[i]+nums[i+1], nums[i+1])。具体的解法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        dp = [nums[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">\t        dp[i] = max(dp[i<span class=\"number\">-1</span>] + nums[i], nums[i])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-分治法\"><a href=\"#2-分治法\" class=\"headerlink\" title=\"2. 分治法\"></a>2. 分治法</h3><p>题中要求使用分治法来解决这个问题，我们可以分 3 类情况来讨论。对于一个数组 nums 的 [left, right]子串，其中点为 mid = (left + right) // 2，</p>\n<ol>\n<li>答案序列完全在[left, mid - 1]中；</li>\n<li>答案序列完全在[mid + 1, right]中；</li>\n<li>答案序列为包含 mid 的左右延续的序列。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># divide and conquer         </span></span><br><span class=\"line\">        mid = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">        left_max = self.divide(left, mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        right_max = self.divide(mid+<span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># situation 3 left part        </span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">        max_lsum = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(mid<span class=\"number\">-1</span>, left<span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            sum += self.nums[i]</span><br><span class=\"line\">            max_lsum = max(max_lsum, sum)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># situation 3 right part </span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">        max_rsum = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(mid+<span class=\"number\">1</span>, right+<span class=\"number\">1</span>):</span><br><span class=\"line\">            sum += self.nums[i]</span><br><span class=\"line\">            max_rsum = max(max_rsum, sum)</span><br><span class=\"line\"></span><br><span class=\"line\">        max_sum = max(left_max, right_max)</span><br><span class=\"line\">        max_sum = max(max_sum, max_lsum + self.nums[mid] + max_rsum)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_sum</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.divide(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Merge Intervals","date":"2019-01-10T13:39:48.000Z","_content":"\n## [Merge Intervals](https://leetcode.com/problems/merge-intervals/)\n\nGiven a collection of intervals, merge all overlapping intervals.\n(合并间隔区间)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_56.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 贪心算法\n\n类似于教室安排问题，根据每个间隔区间的 start 排序，然后遍历所有的间隔区间：\n1. 当前间隔区间的 start 位置大于之前所有合并的区间的 end 时，加入新的间隔区间；\n2. 更新合并区间的 end 为之前合并区间的 end 和当前间隔区间 end 的最大值。\n\n```python\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x.start)\n        \n        result = []\n        for interval in intervals:\n            if not result or result[-1].end < interval.start:\n                result.append(interval)\n            else:\n                result[-1].end = max(result[-1].end, interval.end)\n                \n        return result\n```","source":"_posts/leetcode-MergeIntervals.md","raw":"---\ntitle: LeetCode_Merge Intervals\ndate: 2019-01-10 21:39:48\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - sort\n---\n\n## [Merge Intervals](https://leetcode.com/problems/merge-intervals/)\n\nGiven a collection of intervals, merge all overlapping intervals.\n(合并间隔区间)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_56.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 贪心算法\n\n类似于教室安排问题，根据每个间隔区间的 start 排序，然后遍历所有的间隔区间：\n1. 当前间隔区间的 start 位置大于之前所有合并的区间的 end 时，加入新的间隔区间；\n2. 更新合并区间的 end 为之前合并区间的 end 和当前间隔区间 end 的最大值。\n\n```python\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x.start)\n        \n        result = []\n        for interval in intervals:\n            if not result or result[-1].end < interval.start:\n                result.append(interval)\n            else:\n                result[-1].end = max(result[-1].end, interval.end)\n                \n        return result\n```","slug":"leetcode-MergeIntervals","published":1,"updated":"2019-01-10T14:16:04.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht836003xkvpxtcrnrelj","content":"<h2 id=\"Merge-Intervals\"><a href=\"#Merge-Intervals\" class=\"headerlink\" title=\"Merge Intervals\"></a><a href=\"https://leetcode.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">Merge Intervals</a></h2><p>Given a collection of intervals, merge all overlapping intervals.<br>(合并间隔区间)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_56.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-贪心算法\"><a href=\"#1-贪心算法\" class=\"headerlink\" title=\"1. 贪心算法\"></a>1. 贪心算法</h3><p>类似于教室安排问题，根据每个间隔区间的 start 排序，然后遍历所有的间隔区间：</p>\n<ol>\n<li>当前间隔区间的 start 位置大于之前所有合并的区间的 end 时，加入新的间隔区间；</li>\n<li>更新合并区间的 end 为之前合并区间的 end 和当前间隔区间 end 的最大值。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type intervals: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        intervals.sort(key=<span class=\"keyword\">lambda</span> x: x.start)</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> result <span class=\"keyword\">or</span> result[<span class=\"number\">-1</span>].end &lt; interval.start:</span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result[<span class=\"number\">-1</span>].end = max(result[<span class=\"number\">-1</span>].end, interval.end)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Merge-Intervals\"><a href=\"#Merge-Intervals\" class=\"headerlink\" title=\"Merge Intervals\"></a><a href=\"https://leetcode.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">Merge Intervals</a></h2><p>Given a collection of intervals, merge all overlapping intervals.<br>(合并间隔区间)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_56.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-贪心算法\"><a href=\"#1-贪心算法\" class=\"headerlink\" title=\"1. 贪心算法\"></a>1. 贪心算法</h3><p>类似于教室安排问题，根据每个间隔区间的 start 排序，然后遍历所有的间隔区间：</p>\n<ol>\n<li>当前间隔区间的 start 位置大于之前所有合并的区间的 end 时，加入新的间隔区间；</li>\n<li>更新合并区间的 end 为之前合并区间的 end 和当前间隔区间 end 的最大值。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type intervals: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[Interval]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        intervals.sort(key=<span class=\"keyword\">lambda</span> x: x.start)</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> result <span class=\"keyword\">or</span> result[<span class=\"number\">-1</span>].end &lt; interval.start:</span><br><span class=\"line\">                result.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result[<span class=\"number\">-1</span>].end = max(result[<span class=\"number\">-1</span>].end, interval.end)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Merge Two Sorted Lists","date":"2018-12-06T08:02:30.000Z","_content":"\n## [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n（合并有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_21.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个链表指针\n链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if l1 == None:\n            return l2\n        if l2 == None:\n            return l1\n        \n        if l1.val <= l2.val:\n            target = l1\n            p = l1.next\n            q = l2\n        else:\n            target = l2\n            p = l1\n            q = l2.next\n        tail = target\n        \n        while p != None and q != None:\n            if p.val <= q.val:\n                tail.next = p\n                tail = p\n                p = p.next\n            else:\n                tail.next = q\n                tail = q\n                q = q.next\n            \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n        \n        return target\n```\n\n### 2. 增加头结点\n在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1 or not l2:\n        \treturn l1 or l2\n\n        tail = target = ListNode(0)\n        \n        while l1 and l2:\n            if l1.val <= l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n            \n        tail.next = l1 or l2\n        \n        return target.next\n```","source":"_posts/leetcode-MergeTwoSortedLists.md","raw":"---\ntitle: LeetCode_Merge Two Sorted Lists\ndate: 2018-12-06 16:02:30\ncategories: LeetCode\ntags: \n  - easy\n  - linked list\n---\n\n## [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n（合并有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_21.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 三个链表指针\n链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if l1 == None:\n            return l2\n        if l2 == None:\n            return l1\n        \n        if l1.val <= l2.val:\n            target = l1\n            p = l1.next\n            q = l2\n        else:\n            target = l2\n            p = l1\n            q = l2.next\n        tail = target\n        \n        while p != None and q != None:\n            if p.val <= q.val:\n                tail.next = p\n                tail = p\n                p = p.next\n            else:\n                tail.next = q\n                tail = q\n                q = q.next\n            \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n        \n        return target\n```\n\n### 2. 增加头结点\n在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1 or not l2:\n        \treturn l1 or l2\n\n        tail = target = ListNode(0)\n        \n        while l1 and l2:\n            if l1.val <= l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n            \n        tail.next = l1 or l2\n        \n        return target.next\n```","slug":"leetcode-MergeTwoSortedLists","published":1,"updated":"2018-12-06T08:48:59.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8380040kvpxtkdl8c0k","content":"<h2 id=\"Merge-Two-Sorted-Lists\"><a href=\"#Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"Merge Two Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge Two Sorted Lists</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br>（合并有序链表）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_21.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个链表指针\"><a href=\"#1-三个链表指针\" class=\"headerlink\" title=\"1. 三个链表指针\"></a>1. 三个链表指针</h3><p>链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l2 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">            target = l1</span><br><span class=\"line\">            p = l1.next</span><br><span class=\"line\">            q = l2</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            target = l2</span><br><span class=\"line\">            p = l1</span><br><span class=\"line\">            q = l2.next</span><br><span class=\"line\">        tail = target</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt;= q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                tail = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                tail = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-增加头结点\"><a href=\"#2-增加头结点\" class=\"headerlink\" title=\"2. 增加头结点\"></a>2. 增加头结点</h3><p>在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> l2:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = target = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                tail.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        tail.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target.next</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Merge-Two-Sorted-Lists\"><a href=\"#Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"Merge Two Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge Two Sorted Lists</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br>（合并有序链表）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_21.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-三个链表指针\"><a href=\"#1-三个链表指针\" class=\"headerlink\" title=\"1. 三个链表指针\"></a>1. 三个链表指针</h3><p>链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l2 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">            target = l1</span><br><span class=\"line\">            p = l1.next</span><br><span class=\"line\">            q = l2</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            target = l2</span><br><span class=\"line\">            p = l1</span><br><span class=\"line\">            q = l2.next</span><br><span class=\"line\">        tail = target</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt;= q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                tail = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                tail = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-增加头结点\"><a href=\"#2-增加头结点\" class=\"headerlink\" title=\"2. 增加头结点\"></a>2. 增加头结点</h3><p>在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> l2:</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = target = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                tail.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        tail.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> target.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Merge Sorted Array","date":"2019-02-25T13:51:03.000Z","_content":"\n## [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)\n\nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n(合并有序数组)\n\n<!--more-->\n\n**Note:**\n1. The number of elements initialized in nums1 and nums2 are m and n respectively.\n2. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_88.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 反向插入\n由于最终的数组的长度是已知的，我们可以直接从最后一个位置向前遍历，寻找最大值。具体实现过程如下：\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        index = m + n - 1\n        while index >= 0:\n            if m > 0 and n > 0:\n                if nums1[m-1] > nums2[n-1]:\n                    nums1[index] = nums1[m-1]\n                    m -= 1\n                else:\n                    nums1[index] = nums2[n-1]\n                    n -= 1\n                index -= 1\n            elif n > 0:\n                nums1[: index+1] = nums2[: index+1]\n                break\n            else:\n                break\n```","source":"_posts/leetcode-MergeSortedArray.md","raw":"---\ntitle: LeetCode_Merge Sorted Array\ndate: 2019-02-25 21:51:03\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - two pointers\n---\n\n## [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)\n\nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n(合并有序数组)\n\n<!--more-->\n\n**Note:**\n1. The number of elements initialized in nums1 and nums2 are m and n respectively.\n2. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_88.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 反向插入\n由于最终的数组的长度是已知的，我们可以直接从最后一个位置向前遍历，寻找最大值。具体实现过程如下：\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        index = m + n - 1\n        while index >= 0:\n            if m > 0 and n > 0:\n                if nums1[m-1] > nums2[n-1]:\n                    nums1[index] = nums1[m-1]\n                    m -= 1\n                else:\n                    nums1[index] = nums2[n-1]\n                    n -= 1\n                index -= 1\n            elif n > 0:\n                nums1[: index+1] = nums2[: index+1]\n                break\n            else:\n                break\n```","slug":"leetcode-MergeSortedArray","published":1,"updated":"2019-02-26T02:22:09.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8390043kvpxus7rb68f","content":"<h2 id=\"Merge-Sorted-Array\"><a href=\"#Merge-Sorted-Array\" class=\"headerlink\" title=\"Merge Sorted Array\"></a><a href=\"https://leetcode.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"noopener\">Merge Sorted Array</a></h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.<br>(合并有序数组)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li>\n<li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_88.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-反向插入\"><a href=\"#1-反向插入\" class=\"headerlink\" title=\"1. 反向插入\"></a>1. 反向插入</h3><p>由于最终的数组的长度是已知的，我们可以直接从最后一个位置向前遍历，寻找最大值。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        index = m + n - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> index &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums1[m<span class=\"number\">-1</span>] &gt; nums2[n<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    nums1[index] = nums1[m<span class=\"number\">-1</span>]</span><br><span class=\"line\">                    m -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    nums1[index] = nums2[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">                    n -= <span class=\"number\">1</span></span><br><span class=\"line\">                index -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums1[: index+<span class=\"number\">1</span>] = nums2[: index+<span class=\"number\">1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Merge-Sorted-Array\"><a href=\"#Merge-Sorted-Array\" class=\"headerlink\" title=\"Merge Sorted Array\"></a><a href=\"https://leetcode.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"noopener\">Merge Sorted Array</a></h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.<br>(合并有序数组)</p>","more":"<p><strong>Note:</strong></p>\n<ol>\n<li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li>\n<li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_88.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-反向插入\"><a href=\"#1-反向插入\" class=\"headerlink\" title=\"1. 反向插入\"></a>1. 反向插入</h3><p>由于最终的数组的长度是已知的，我们可以直接从最后一个位置向前遍历，寻找最大值。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        index = m + n - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> index &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums1[m<span class=\"number\">-1</span>] &gt; nums2[n<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    nums1[index] = nums1[m<span class=\"number\">-1</span>]</span><br><span class=\"line\">                    m -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    nums1[index] = nums2[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">                    n -= <span class=\"number\">1</span></span><br><span class=\"line\">                index -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums1[: index+<span class=\"number\">1</span>] = nums2[: index+<span class=\"number\">1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Minimum Depth of Binary Tree","date":"2019-03-05T01:56:49.000Z","_content":"\n## [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)\n\nGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.\n（二叉树的最低深度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_111.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n注意左（右）子树深度为0的地方，也就是当左（右）子树为空时，应该按照右（左）子树的深度计算。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def minDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        left, right = self.minDepth(root.left), self.minDepth(root.right)\n        if left == 0 or right == 0:\n            return left + right + 1\n        \n        return min(left, right) + 1\n```","source":"_posts/leetcode-MinimumDepthofBinaryTree.md","raw":"---\ntitle: LeetCode_Minimum Depth of Binary Tree\ndate: 2019-03-05 09:56:49\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n  - bfs\n---\n\n## [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)\n\nGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.\n（二叉树的最低深度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_111.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n注意左（右）子树深度为0的地方，也就是当左（右）子树为空时，应该按照右（左）子树的深度计算。具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def minDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        left, right = self.minDepth(root.left), self.minDepth(root.right)\n        if left == 0 or right == 0:\n            return left + right + 1\n        \n        return min(left, right) + 1\n```","slug":"leetcode-MinimumDepthofBinaryTree","published":1,"updated":"2019-03-05T02:14:52.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83a0047kvpx1w3it9x3","content":"<h2 id=\"Minimum-Depth-of-Binary-Tree\"><a href=\"#Minimum-Depth-of-Binary-Tree\" class=\"headerlink\" title=\"Minimum Depth of Binary Tree\"></a><a href=\"https://leetcode.com/problems/minimum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">Minimum Depth of Binary Tree</a></h2><p>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.<br>（二叉树的最低深度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_111.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>注意左（右）子树深度为0的地方，也就是当左（右）子树为空时，应该按照右（左）子树的深度计算。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left, right = self.minDepth(root.left), self.minDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == <span class=\"number\">0</span> <span class=\"keyword\">or</span> right == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left + right + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(left, right) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Minimum-Depth-of-Binary-Tree\"><a href=\"#Minimum-Depth-of-Binary-Tree\" class=\"headerlink\" title=\"Minimum Depth of Binary Tree\"></a><a href=\"https://leetcode.com/problems/minimum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">Minimum Depth of Binary Tree</a></h2><p>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.<br>（二叉树的最低深度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_111.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>注意左（右）子树深度为0的地方，也就是当左（右）子树为空时，应该按照右（左）子树的深度计算。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left, right = self.minDepth(root.left), self.minDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == <span class=\"number\">0</span> <span class=\"keyword\">or</span> right == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left + right + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(left, right) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Merge k Sorted Lists","date":"2018-12-11T14:34:00.000Z","_content":"\n## [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\n\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n（合并k个有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_23.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法\n这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nclass Solution:\n    def merge2Lists(self, left, right):\n        head = ListNode(0)\n        p = left\n        q = right\n        tail = head\n        \n        while p != None and q != None:\n            if p.val < q.val:\n                tail.next = p\n                p = p.next\n            else:\n                tail.next = q\n                q = q.next\n            tail = tail.next\n        \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n            \n        return head.next\n        \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        n = len(lists)\n        if n == 0:\n            return []\n        if n == 1:\n            return lists[0]\n        \n        left_list = self.mergeKLists(lists[:n//2])\n        right_list = self.mergeKLists(lists[n//2:])\n        return self.merge2Lists(left_list, right_list)\n```\n\n\n### 2. 堆排序\n另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nfrom heapq import heappush, heappop\n\nclass Solution:      \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if lists == []:\n            return []\n        \n        heap = []\n        for list in lists:\n            while list:\n                heappush(heap, list.val)\n                list = list.next\n       \n        head = ListNode(0)\n        tail = head\n        while heap:\n            tail.next = ListNode(heappop(heap))\n            tail = tail.next\n        \n        return head.next\n```\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-MergekSortedLists.md","raw":"---\ntitle: LeetCode_Merge k Sorted Lists\ndate: 2018-12-11 22:34:00\ncategories: LeetCode\ntags: \n  - hard\n  - linked list\n  - heap\n  - divide and conquer\n---\n\n## [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\n\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n（合并k个有序链表）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_23.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 分治法\n这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nclass Solution:\n    def merge2Lists(self, left, right):\n        head = ListNode(0)\n        p = left\n        q = right\n        tail = head\n        \n        while p != None and q != None:\n            if p.val < q.val:\n                tail.next = p\n                p = p.next\n            else:\n                tail.next = q\n                q = q.next\n            tail = tail.next\n        \n        if p != None:\n            tail.next = p\n        else:\n            tail.next = q\n            \n        return head.next\n        \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        n = len(lists)\n        if n == 0:\n            return []\n        if n == 1:\n            return lists[0]\n        \n        left_list = self.mergeKLists(lists[:n//2])\n        right_list = self.mergeKLists(lists[n//2:])\n        return self.merge2Lists(left_list, right_list)\n```\n\n\n### 2. 堆排序\n另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\\\(O(mlog(n))\\\\)，其中 \\\\(n\\\\) 为序列个数，\\\\(m\\\\) 为所有序列的长度和。具体实现过程如下：\n\n```python\nfrom heapq import heappush, heappop\n\nclass Solution:      \n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if lists == []:\n            return []\n        \n        heap = []\n        for list in lists:\n            while list:\n                heappush(heap, list.val)\n                list = list.next\n       \n        head = ListNode(0)\n        tail = head\n        while heap:\n            tail.next = ListNode(heappop(heap))\n            tail = tail.next\n        \n        return head.next\n```\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-MergekSortedLists","published":1,"updated":"2018-12-11T15:11:31.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83c004akvpxyvlw389o","content":"<h2 id=\"Merge-k-Sorted-Lists\"><a href=\"#Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"Merge k Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge k Sorted Lists</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br>（合并k个有序链表）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_23.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法\"><a href=\"#1-分治法\" class=\"headerlink\" title=\"1. 分治法\"></a>1. 分治法</h3><p>这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge2Lists</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = left</span><br><span class=\"line\">        q = right</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt; q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(lists)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        left_list = self.mergeKLists(lists[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        right_list = self.mergeKLists(lists[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.merge2Lists(left_list, right_list)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-堆排序\"><a href=\"#2-堆排序\" class=\"headerlink\" title=\"2. 堆排序\"></a>2. 堆排序</h3><p>另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> heapq <span class=\"keyword\">import</span> heappush, heappop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists == []:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        heap = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> list:</span><br><span class=\"line\">                heappush(heap, list.val)</span><br><span class=\"line\">                list = list.next</span><br><span class=\"line\">       </span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">            tail.next = ListNode(heappop(heap))</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Merge-k-Sorted-Lists\"><a href=\"#Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"Merge k Sorted Lists\"></a><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">Merge k Sorted Lists</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br>（合并k个有序链表）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_23.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-分治法\"><a href=\"#1-分治法\" class=\"headerlink\" title=\"1. 分治法\"></a>1. 分治法</h3><p>这个问题是一个典型的分治法解决的问题。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge2Lists</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = left</span><br><span class=\"line\">        q = right</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> q != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val &lt; q.val:</span><br><span class=\"line\">                tail.next = p</span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tail.next = q</span><br><span class=\"line\">                q = q.next</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            tail.next = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tail.next = q</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(lists)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        left_list = self.mergeKLists(lists[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">        right_list = self.mergeKLists(lists[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.merge2Lists(left_list, right_list)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-堆排序\"><a href=\"#2-堆排序\" class=\"headerlink\" title=\"2. 堆排序\"></a>2. 堆排序</h3><p>另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \\(O(mlog(n))\\)，其中 \\(n\\) 为序列个数，\\(m\\) 为所有序列的长度和。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> heapq <span class=\"keyword\">import</span> heappush, heappop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type lists: List[ListNode]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lists == []:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        heap = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> list:</span><br><span class=\"line\">                heappush(heap, list.val)</span><br><span class=\"line\">                list = list.next</span><br><span class=\"line\">       </span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">            tail.next = ListNode(heappop(heap))</span><br><span class=\"line\">            tail = tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Minimum Window Substring","date":"2019-02-22T10:31:19.000Z","_content":"\n## [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)\n\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n（包含字符串的最小窗口）\n\n<!--more-->\n\n**Note:** \n1. If there is no such window in S that covers all characters in T, return the empty string \"\".\n2. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_76.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 哈希表 & 双指针\n\n很直观，这题需要用到 HashMap 来存储目标字符串。用 left，right 两个指针指向 S，在遍历 S 的过程中，right 不断地右移来找到复合要求的字符串，也就是 required_char == 0 的时候，考虑向右移动 left，直到发现了当前的 S[left: right+1] 不符合要求的时候，重新向右移动 right。具体实现过程如下：\n\n```python\nimport collections\n\nclass Solution:\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\n        if not s or not t:\n            return \"\"\n\n        t_dict = collections.Counter(t)\n        required_char = len(t_dict)\n\n        len_s = len(s)\n        re_len, re = len_s + 1, \"\"\n        left, right = 0, 0\n\n        while right < len_s:\n            if s[right] not in t_dict:\n                right += 1\n                continue\n            t_dict[s[right]] -= 1\n            if t_dict[s[right]] == 0:\n                required_char -= 1\n\n            while required_char == 0:\n                if right - left + 1 < re_len:\n                    re = s[left: right + 1]\n                    re_len = right - left + 1 \n\n                if s[left] not in t_dict:\n                    left += 1\n                    continue\n                \n                t_dict[s[left]] += 1\n                if t_dict[s[left]] == 1:\n                    required_char += 1\n                left += 1\n\n            right += 1\n\n        if re_len == len_s + 1:\n            return \"\"\n        return re\n```","source":"_posts/leetcode-MinimumWindowSubstring.md","raw":"---\ntitle: LeetCode_Minimum Window Substring\ndate: 2019-02-22 18:31:19\ncategories: LeetCode\ntags: \n  - hard\n  - hash table\n  - two pointers\n  - string\n---\n\n## [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)\n\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n（包含字符串的最小窗口）\n\n<!--more-->\n\n**Note:** \n1. If there is no such window in S that covers all characters in T, return the empty string \"\".\n2. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_76.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 哈希表 & 双指针\n\n很直观，这题需要用到 HashMap 来存储目标字符串。用 left，right 两个指针指向 S，在遍历 S 的过程中，right 不断地右移来找到复合要求的字符串，也就是 required_char == 0 的时候，考虑向右移动 left，直到发现了当前的 S[left: right+1] 不符合要求的时候，重新向右移动 right。具体实现过程如下：\n\n```python\nimport collections\n\nclass Solution:\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\n        if not s or not t:\n            return \"\"\n\n        t_dict = collections.Counter(t)\n        required_char = len(t_dict)\n\n        len_s = len(s)\n        re_len, re = len_s + 1, \"\"\n        left, right = 0, 0\n\n        while right < len_s:\n            if s[right] not in t_dict:\n                right += 1\n                continue\n            t_dict[s[right]] -= 1\n            if t_dict[s[right]] == 0:\n                required_char -= 1\n\n            while required_char == 0:\n                if right - left + 1 < re_len:\n                    re = s[left: right + 1]\n                    re_len = right - left + 1 \n\n                if s[left] not in t_dict:\n                    left += 1\n                    continue\n                \n                t_dict[s[left]] += 1\n                if t_dict[s[left]] == 1:\n                    required_char += 1\n                left += 1\n\n            right += 1\n\n        if re_len == len_s + 1:\n            return \"\"\n        return re\n```","slug":"leetcode-MinimumWindowSubstring","published":1,"updated":"2019-02-23T05:56:18.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83e004ekvpxy0kw89g6","content":"<h2 id=\"Minimum-Window-Substring\"><a href=\"#Minimum-Window-Substring\" class=\"headerlink\" title=\"Minimum Window Substring\"></a><a href=\"https://leetcode.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">Minimum Window Substring</a></h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).<br>（包含字符串的最小窗口）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> </p>\n<ol>\n<li>If there is no such window in S that covers all characters in T, return the empty string “”.</li>\n<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_76.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-哈希表-amp-双指针\"><a href=\"#1-哈希表-amp-双指针\" class=\"headerlink\" title=\"1. 哈希表 &amp; 双指针\"></a>1. 哈希表 &amp; 双指针</h3><p>很直观，这题需要用到 HashMap 来存储目标字符串。用 left，right 两个指针指向 S，在遍历 S 的过程中，right 不断地右移来找到复合要求的字符串，也就是 required_char == 0 的时候，考虑向右移动 left，直到发现了当前的 S[left: right+1] 不符合要求的时候，重新向右移动 right。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minWindow</span><span class=\"params\">(self, s: <span class=\"string\">'str'</span>, t: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> t:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t_dict = collections.Counter(t)</span><br><span class=\"line\">        required_char = len(t_dict)</span><br><span class=\"line\"></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        re_len, re = len_s + <span class=\"number\">1</span>, <span class=\"string\">\"\"</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> right &lt; len_s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[right] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> t_dict:</span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            t_dict[s[right]] -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> t_dict[s[right]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                required_char -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> required_char == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> right - left + <span class=\"number\">1</span> &lt; re_len:</span><br><span class=\"line\">                    re = s[left: right + <span class=\"number\">1</span>]</span><br><span class=\"line\">                    re_len = right - left + <span class=\"number\">1</span> </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[left] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> t_dict:</span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                t_dict[s[left]] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> t_dict[s[left]] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    required_char += <span class=\"number\">1</span></span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            right += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> re_len == len_s + <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Minimum-Window-Substring\"><a href=\"#Minimum-Window-Substring\" class=\"headerlink\" title=\"Minimum Window Substring\"></a><a href=\"https://leetcode.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">Minimum Window Substring</a></h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).<br>（包含字符串的最小窗口）</p>","more":"<p><strong>Note:</strong> </p>\n<ol>\n<li>If there is no such window in S that covers all characters in T, return the empty string “”.</li>\n<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_76.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-哈希表-amp-双指针\"><a href=\"#1-哈希表-amp-双指针\" class=\"headerlink\" title=\"1. 哈希表 &amp; 双指针\"></a>1. 哈希表 &amp; 双指针</h3><p>很直观，这题需要用到 HashMap 来存储目标字符串。用 left，right 两个指针指向 S，在遍历 S 的过程中，right 不断地右移来找到复合要求的字符串，也就是 required_char == 0 的时候，考虑向右移动 left，直到发现了当前的 S[left: right+1] 不符合要求的时候，重新向右移动 right。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minWindow</span><span class=\"params\">(self, s: <span class=\"string\">'str'</span>, t: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> t:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t_dict = collections.Counter(t)</span><br><span class=\"line\">        required_char = len(t_dict)</span><br><span class=\"line\"></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        re_len, re = len_s + <span class=\"number\">1</span>, <span class=\"string\">\"\"</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> right &lt; len_s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[right] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> t_dict:</span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            t_dict[s[right]] -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> t_dict[s[right]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                required_char -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> required_char == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> right - left + <span class=\"number\">1</span> &lt; re_len:</span><br><span class=\"line\">                    re = s[left: right + <span class=\"number\">1</span>]</span><br><span class=\"line\">                    re_len = right - left + <span class=\"number\">1</span> </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[left] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> t_dict:</span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                t_dict[s[left]] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> t_dict[s[left]] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    required_char += <span class=\"number\">1</span></span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            right += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> re_len == len_s + <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Minimum Path Sum","date":"2019-01-15T06:06:43.000Z","_content":"\n## [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)\n\nGiven a **m x n** grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.\n（最小带权路径和，只能向右或者向下移动从左上角移动到右下角的带权路径和）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_64.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n在前两道题目的基础上，类似于求一个带权路径和的问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n\n        dp = [[0]*n for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if i==0 and j==0:\n                    dp[i][j] = grid[i][j]\n                elif i==0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j==0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]\n\n        return dp[m-1][n-1]\n```","source":"_posts/leetcode-MinimumPathSum.md","raw":"---\ntitle: LeetCode_Minimum Path Sum\ndate: 2019-01-15 14:06:43\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - dynamic programming\n---\n\n## [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)\n\nGiven a **m x n** grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.\n（最小带权路径和，只能向右或者向下移动从左上角移动到右下角的带权路径和）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_64.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n在前两道题目的基础上，类似于求一个带权路径和的问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n\n        dp = [[0]*n for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if i==0 and j==0:\n                    dp[i][j] = grid[i][j]\n                elif i==0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j==0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]\n\n        return dp[m-1][n-1]\n```","slug":"leetcode-MinimumPathSum","published":1,"updated":"2019-01-15T06:24:24.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83f004hkvpx1e25xvsc","content":"<h2 id=\"Minimum-Path-Sum\"><a href=\"#Minimum-Path-Sum\" class=\"headerlink\" title=\"Minimum Path Sum\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">Minimum Path Sum</a></h2><p>Given a <strong>m x n</strong> grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.<br>（最小带权路径和，只能向右或者向下移动从左上角移动到右下角的带权路径和）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_64.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>在前两道题目的基础上，类似于求一个带权路径和的问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minPathSum</span><span class=\"params\">(self, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type grid: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = grid[i][j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>] + grid[i][j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j] + grid[i][j]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = min(dp[i][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j]) + grid[i][j]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Minimum-Path-Sum\"><a href=\"#Minimum-Path-Sum\" class=\"headerlink\" title=\"Minimum Path Sum\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">Minimum Path Sum</a></h2><p>Given a <strong>m x n</strong> grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.<br>（最小带权路径和，只能向右或者向下移动从左上角移动到右下角的带权路径和）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_64.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>在前两道题目的基础上，类似于求一个带权路径和的问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minPathSum</span><span class=\"params\">(self, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type grid: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = grid[i][j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>] + grid[i][j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j] + grid[i][j]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = min(dp[i][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j]) + grid[i][j]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Multiply Strings","date":"2019-01-03T14:45:45.000Z","_content":"\n## [Multiply Strings](https://leetcode.com/problems/multiply-strings/)\n\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n（用非库函数的方式返回两个字符串表示的整数的乘积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_43.png\" width = \"500\" align=center/>\n</div>\n\nNote:\n- The length of both num1 and num2 is < 110.\n- Both num1 and num2 contain only digits 0-9.\n- Both num1 and num2 do not contain any leading zero, except the number 0 itself.\n- You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n### 实现库函数 atoi 和 itoa\n由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 `ord()`表示将字符转换为ASCII码，`chr()`表示将ASCII码转换为字符。具体实现过程如下：\n\n```python\nclass Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        def atoi(s):\n            result = 0\n            for char in s:\n                result = result * 10 + (ord(char) - ord('0'))\n            return result\n    \n        def itoa(num):\n            if num == 0:\n                return \"0\"\n            s = \"\"\n            while num:\n                char = num % 10 + ord('0')\n                s = chr(char) + s\n                num = num // 10\n            \n            return s\n        \n        return itoa(atoi(num1) * atoi(num2))\n```","source":"_posts/leetcode-MultiplyStrings.md","raw":"---\ntitle: LeetCode_Multiply Strings\ndate: 2019-01-03 22:45:45\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - string\n---\n\n## [Multiply Strings](https://leetcode.com/problems/multiply-strings/)\n\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n（用非库函数的方式返回两个字符串表示的整数的乘积）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_43.png\" width = \"500\" align=center/>\n</div>\n\nNote:\n- The length of both num1 and num2 is < 110.\n- Both num1 and num2 contain only digits 0-9.\n- Both num1 and num2 do not contain any leading zero, except the number 0 itself.\n- You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n### 实现库函数 atoi 和 itoa\n由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 `ord()`表示将字符转换为ASCII码，`chr()`表示将ASCII码转换为字符。具体实现过程如下：\n\n```python\nclass Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        def atoi(s):\n            result = 0\n            for char in s:\n                result = result * 10 + (ord(char) - ord('0'))\n            return result\n    \n        def itoa(num):\n            if num == 0:\n                return \"0\"\n            s = \"\"\n            while num:\n                char = num % 10 + ord('0')\n                s = chr(char) + s\n                num = num // 10\n            \n            return s\n        \n        return itoa(atoi(num1) * atoi(num2))\n```","slug":"leetcode-MultiplyStrings","published":1,"updated":"2019-01-03T15:02:36.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83g004kkvpxnl8o46nu","content":"<h2 id=\"Multiply-Strings\"><a href=\"#Multiply-Strings\" class=\"headerlink\" title=\"Multiply Strings\"></a><a href=\"https://leetcode.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">Multiply Strings</a></h2><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.<br>（用非库函数的方式返回两个字符串表示的整数的乘积）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_43.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>Note:</p>\n<ul>\n<li>The length of both num1 and num2 is &lt; 110.</li>\n<li>Both num1 and num2 contain only digits 0-9.</li>\n<li>Both num1 and num2 do not contain any leading zero, except the number 0 itself.</li>\n<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>\n</ul>\n<h3 id=\"实现库函数-atoi-和-itoa\"><a href=\"#实现库函数-atoi-和-itoa\" class=\"headerlink\" title=\"实现库函数 atoi 和 itoa\"></a>实现库函数 atoi 和 itoa</h3><p>由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 <code>ord()</code>表示将字符转换为ASCII码，<code>chr()</code>表示将ASCII码转换为字符。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, num1, num2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num1: str</span></span><br><span class=\"line\"><span class=\"string\">        :type num2: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">atoi</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">                result = result * <span class=\"number\">10</span> + (ord(char) - ord(<span class=\"string\">'0'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">itoa</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span></span><br><span class=\"line\">            s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> num:</span><br><span class=\"line\">                char = num % <span class=\"number\">10</span> + ord(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">                s = chr(char) + s</span><br><span class=\"line\">                num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> itoa(atoi(num1) * atoi(num2))</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Multiply-Strings\"><a href=\"#Multiply-Strings\" class=\"headerlink\" title=\"Multiply Strings\"></a><a href=\"https://leetcode.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">Multiply Strings</a></h2><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.<br>（用非库函数的方式返回两个字符串表示的整数的乘积）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_43.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>Note:</p>\n<ul>\n<li>The length of both num1 and num2 is &lt; 110.</li>\n<li>Both num1 and num2 contain only digits 0-9.</li>\n<li>Both num1 and num2 do not contain any leading zero, except the number 0 itself.</li>\n<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>\n</ul>\n<h3 id=\"实现库函数-atoi-和-itoa\"><a href=\"#实现库函数-atoi-和-itoa\" class=\"headerlink\" title=\"实现库函数 atoi 和 itoa\"></a>实现库函数 atoi 和 itoa</h3><p>由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 <code>ord()</code>表示将字符转换为ASCII码，<code>chr()</code>表示将ASCII码转换为字符。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, num1, num2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type num1: str</span></span><br><span class=\"line\"><span class=\"string\">        :type num2: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">atoi</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">                result = result * <span class=\"number\">10</span> + (ord(char) - ord(<span class=\"string\">'0'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">itoa</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span></span><br><span class=\"line\">            s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> num:</span><br><span class=\"line\">                char = num % <span class=\"number\">10</span> + ord(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">                s = chr(char) + s</span><br><span class=\"line\">                num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> itoa(atoi(num1) * atoi(num2))</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_N-Queens","date":"2019-01-09T07:26:07.000Z","_content":"\n## [N-Queens](https://leetcode.com/problems/n-queens/)\n\nThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n(N皇后的问题，求所有解)\n\n<div align=center>\n\t<img src=\"/images/leetcode_51_1.png\" width = \"200\" align=center/>\n</div>\n\n<!--more-->\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_51.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 回溯法\n类似于这种解空间可以用树表示，且存在某种约束条件的问题可以用回溯法求解。具体实现过程如下：\n\n```python\nimport copy\n\nclass Solution:\n\tdef check(self, matrix, _i, _j):\n\t\tfor i in range(self.n):\n\t\t\tfor j in range(self.n):\n\t\t\t\tif matrix[i][j] == 'Q':\n\t\t\t\t\tif j == _j or abs(_i - i) == abs(_j - j):\n\t\t\t\t\t\treturn False\n\t\treturn True\n\n\tdef dfs(self, i, matrix):\n\t\tif (i == self.n):\n\t\t\tresult = []\n\t\t\tfor row in matrix:\n\t\t\t\tresult.append(''.join(row))\n\t\t\tself.result.append(result)\n\t\telse:\n\t\t\tfor j in range(self.n):\n\t\t\t\tif self.check(matrix, i, j):\n\t\t\t\t\tmatrix[i][j] = 'Q'\n\t\t\t\t\tself.dfs(i+1, matrix)\n\t\t\t\t\tmatrix[i][j] = '.'\n\t\n\tdef solveNQueens(self, n):\n\t\t\"\"\"\n\t\t:type n: int\n\t\t:rtype: List[List[str]]\n\t\t\"\"\"\n\t\tself.n = n\n\t\tself.result = []\n\n\t\tmatrix = [['.' for _ in range(self.n)] for _ in range(self.n)]\n\n\t\tself.dfs(0, matrix)\n\t\treturn self.result\n```\n\n\n\n\n\n","source":"_posts/leetcode-N-Queens.md","raw":"---\ntitle: LeetCode_N-Queens\ndate: 2019-01-09 15:26:07\ncategories: LeetCode\ntags: \n  - hard\n  - back tracking\n---\n\n## [N-Queens](https://leetcode.com/problems/n-queens/)\n\nThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n(N皇后的问题，求所有解)\n\n<div align=center>\n\t<img src=\"/images/leetcode_51_1.png\" width = \"200\" align=center/>\n</div>\n\n<!--more-->\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_51.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 回溯法\n类似于这种解空间可以用树表示，且存在某种约束条件的问题可以用回溯法求解。具体实现过程如下：\n\n```python\nimport copy\n\nclass Solution:\n\tdef check(self, matrix, _i, _j):\n\t\tfor i in range(self.n):\n\t\t\tfor j in range(self.n):\n\t\t\t\tif matrix[i][j] == 'Q':\n\t\t\t\t\tif j == _j or abs(_i - i) == abs(_j - j):\n\t\t\t\t\t\treturn False\n\t\treturn True\n\n\tdef dfs(self, i, matrix):\n\t\tif (i == self.n):\n\t\t\tresult = []\n\t\t\tfor row in matrix:\n\t\t\t\tresult.append(''.join(row))\n\t\t\tself.result.append(result)\n\t\telse:\n\t\t\tfor j in range(self.n):\n\t\t\t\tif self.check(matrix, i, j):\n\t\t\t\t\tmatrix[i][j] = 'Q'\n\t\t\t\t\tself.dfs(i+1, matrix)\n\t\t\t\t\tmatrix[i][j] = '.'\n\t\n\tdef solveNQueens(self, n):\n\t\t\"\"\"\n\t\t:type n: int\n\t\t:rtype: List[List[str]]\n\t\t\"\"\"\n\t\tself.n = n\n\t\tself.result = []\n\n\t\tmatrix = [['.' for _ in range(self.n)] for _ in range(self.n)]\n\n\t\tself.dfs(0, matrix)\n\t\treturn self.result\n```\n\n\n\n\n\n","slug":"leetcode-N-Queens","published":1,"updated":"2019-01-09T14:12:45.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83h004okvpx3cvtzho1","content":"<h2 id=\"N-Queens\"><a href=\"#N-Queens\" class=\"headerlink\" title=\"N-Queens\"></a><a href=\"https://leetcode.com/problems/n-queens/\" target=\"_blank\" rel=\"noopener\">N-Queens</a></h2><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>(N皇后的问题，求所有解)</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_51_1.png\" width=\"200\" align=\"center/\"><br></div>\n\n<a id=\"more\"></a>\n<p>Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_51.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>类似于这种解空间可以用树表示，且存在某种约束条件的问题可以用回溯法求解。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(self, matrix, _i, _j)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">'Q'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> j == _j <span class=\"keyword\">or</span> abs(_i - i) == abs(_j - j):</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, matrix)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == self.n):</span><br><span class=\"line\">\t\t\tresult = []</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">\t\t\t\tresult.append(<span class=\"string\">''</span>.join(row))</span><br><span class=\"line\">\t\t\tself.result.append(result)</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.check(matrix, i, j):</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\t\t\tself.dfs(i+<span class=\"number\">1</span>, matrix)</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveNQueens</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type n: int</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.n = n</span><br><span class=\"line\">\t\tself.result = []</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmatrix = [[<span class=\"string\">'.'</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.dfs(<span class=\"number\">0</span>, matrix)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"N-Queens\"><a href=\"#N-Queens\" class=\"headerlink\" title=\"N-Queens\"></a><a href=\"https://leetcode.com/problems/n-queens/\" target=\"_blank\" rel=\"noopener\">N-Queens</a></h2><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>(N皇后的问题，求所有解)</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_51_1.png\" width=\"200\" align=\"center/\"><br></div>","more":"<p>Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_51.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>类似于这种解空间可以用树表示，且存在某种约束条件的问题可以用回溯法求解。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(self, matrix, _i, _j)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">'Q'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> j == _j <span class=\"keyword\">or</span> abs(_i - i) == abs(_j - j):</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, matrix)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == self.n):</span><br><span class=\"line\">\t\t\tresult = []</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">\t\t\t\tresult.append(<span class=\"string\">''</span>.join(row))</span><br><span class=\"line\">\t\t\tself.result.append(result)</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.check(matrix, i, j):</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\t\t\tself.dfs(i+<span class=\"number\">1</span>, matrix)</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveNQueens</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type n: int</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.n = n</span><br><span class=\"line\">\t\tself.result = []</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmatrix = [[<span class=\"string\">'.'</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.dfs(<span class=\"number\">0</span>, matrix)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Next Permutation","date":"2018-12-21T02:13:55.000Z","_content":"\n## [Next Permutation](https://leetcode.com/problems/next-permutation/)\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.\n（从小到大全排列的下一个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_31.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 后向遍历\n整体的思路就是从后向前遍历：\n1. 当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。\n2. 将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。\n3. 再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。\n\n```python\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return\n        for i in range(n-1, -1, -1):\n            if i == 0:\n                nums.reverse()\n                return \n            if nums[i] > nums[i-1]:\n                break\n        \n        j, k = i, n-1\n        while j < k:\n            nums[j], nums[k] = nums[k], nums[j]\n            j += 1\n            k -= 1\n      \n        for j in range(i, n):\n            if nums[j] > nums[i-1]:\n                nums[i-1], nums[j] = nums[j], nums[i-1]\n                break\n            \n        return\n```\n\n\n## 2. 后向遍历\n另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。","source":"_posts/leetcode-NextPermutation.md","raw":"---\ntitle: LeetCode_Next Permutation\ndate: 2018-12-21 10:13:55\ncategories: LeetCode\ntags: \n  - medium\n  - array\n---\n\n## [Next Permutation](https://leetcode.com/problems/next-permutation/)\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.\n（从小到大全排列的下一个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_31.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 后向遍历\n整体的思路就是从后向前遍历：\n1. 当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。\n2. 将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。\n3. 再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。\n\n```python\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return\n        for i in range(n-1, -1, -1):\n            if i == 0:\n                nums.reverse()\n                return \n            if nums[i] > nums[i-1]:\n                break\n        \n        j, k = i, n-1\n        while j < k:\n            nums[j], nums[k] = nums[k], nums[j]\n            j += 1\n            k -= 1\n      \n        for j in range(i, n):\n            if nums[j] > nums[i-1]:\n                nums[i-1], nums[j] = nums[j], nums[i-1]\n                break\n            \n        return\n```\n\n\n## 2. 后向遍历\n另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。","slug":"leetcode-NextPermutation","published":1,"updated":"2018-12-21T02:54:15.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83i004rkvpx1ttgkf2r","content":"<h2 id=\"Next-Permutation\"><a href=\"#Next-Permutation\" class=\"headerlink\" title=\"Next Permutation\"></a><a href=\"https://leetcode.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">Next Permutation</a></h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.<br>（从小到大全排列的下一个）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_31.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-后向遍历\"><a href=\"#1-后向遍历\" class=\"headerlink\" title=\"1. 后向遍历\"></a>1. 后向遍历</h3><p>整体的思路就是从后向前遍历：</p>\n<ol>\n<li>当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。</li>\n<li>将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。</li>\n<li>再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums.reverse()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        j, k = i, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">            nums[j], nums[k] = nums[k], nums[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                nums[i<span class=\"number\">-1</span>], nums[j] = nums[j], nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-后向遍历\"><a href=\"#2-后向遍历\" class=\"headerlink\" title=\"2. 后向遍历\"></a>2. 后向遍历</h2><p>另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Next-Permutation\"><a href=\"#Next-Permutation\" class=\"headerlink\" title=\"Next Permutation\"></a><a href=\"https://leetcode.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">Next Permutation</a></h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.<br>（从小到大全排列的下一个）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_31.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-后向遍历\"><a href=\"#1-后向遍历\" class=\"headerlink\" title=\"1. 后向遍历\"></a>1. 后向遍历</h3><p>整体的思路就是从后向前遍历：</p>\n<ol>\n<li>当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。</li>\n<li>将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。</li>\n<li>再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums.reverse()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        j, k = i, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">            nums[j], nums[k] = nums[k], nums[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                nums[i<span class=\"number\">-1</span>], nums[j] = nums[j], nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-后向遍历\"><a href=\"#2-后向遍历\" class=\"headerlink\" title=\"2. 后向遍历\"></a>2. 后向遍历</h2><p>另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。</p>"},{"title":"LeetCode_Palindrome Number","date":"2018-11-26T13:56:36.000Z","_content":"\n## [Palindrome Number](https://leetcode.com/problems/palindrome-number/)\n\nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n（判断数字是否是回文序列）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_9.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串翻转\n\n```python\nclass Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        string  = str(x)\n        \n        return string == string[::-1]\n```","source":"_posts/leetcode-PalindromeNumber.md","raw":"---\ntitle: LeetCode_Palindrome Number\ndate: 2018-11-26 21:56:36\ncategories: LeetCode\ntags: \n  - easy\n  - math\n---\n\n## [Palindrome Number](https://leetcode.com/problems/palindrome-number/)\n\nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n（判断数字是否是回文序列）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_9.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串翻转\n\n```python\nclass Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        string  = str(x)\n        \n        return string == string[::-1]\n```","slug":"leetcode-PalindromeNumber","published":1,"updated":"2018-11-27T06:24:58.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83j004vkvpxb9at7vnt","content":"<h2 id=\"Palindrome-Number\"><a href=\"#Palindrome-Number\" class=\"headerlink\" title=\"Palindrome Number\"></a><a href=\"https://leetcode.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">Palindrome Number</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br>（判断数字是否是回文序列）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_9.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串翻转\"><a href=\"#字符串翻转\" class=\"headerlink\" title=\"字符串翻转\"></a>字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string  = str(x)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> string == string[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Palindrome-Number\"><a href=\"#Palindrome-Number\" class=\"headerlink\" title=\"Palindrome Number\"></a><a href=\"https://leetcode.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">Palindrome Number</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br>（判断数字是否是回文序列）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_9.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串翻转\"><a href=\"#字符串翻转\" class=\"headerlink\" title=\"字符串翻转\"></a>字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string  = str(x)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> string == string[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Partition List","date":"2019-02-25T06:30:54.000Z","_content":"\n## [Partition List](https://leetcode.com/problems/partition-list/)\n\nGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.\n(切分链表)\n\n<!--more-->\n\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_86.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 两个指针 In-place\n第一种是 in-place，具体实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_pre = new_head\n        p_cur = head\n          \n        p_insert = None\n        while p_cur:\n            if p_cur.val >= x and not p_insert:\n                p_insert = p_pre\n            elif p_cur.val < x:\n                if p_insert:\n                    p_pre.next = p_cur.next\n                    p_cur.next = p_insert.next\n                    p_insert.next = p_cur\n                    p_cur = p_pre.next\n                    p_insert = p_insert.next\n                    continue\n            p_pre = p_pre.next\n            p_cur = p_cur.next\n        \n        return new_head.next\n```\n\n### 2. 两个指针 \n第二种是新构建两个链表分别存储，具体实现过程如下：\n\n```python\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        p_l = l_head = ListNode(0)\n        p_r = r_head = ListNode(0)\n        \n        p_cur = head\n        while p_cur:\n            if p_cur.val >= x:\n                p_r.next = p_cur\n                p_r = p_r.next\n            else:\n                p_l.next = p_cur\n                p_l = p_l.next\n            p_cur = p_cur.next\n        \n        p_l.next = r_head.next\n        p_r.next = None\n        return l_head.next\n```","source":"_posts/leetcode-PartitionList.md","raw":"---\ntitle: LeetCode_Partition List\ndate: 2019-02-25 14:30:54\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n  - two pointers\n---\n\n## [Partition List](https://leetcode.com/problems/partition-list/)\n\nGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.\n(切分链表)\n\n<!--more-->\n\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_86.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 两个指针 In-place\n第一种是 in-place，具体实现过程如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_pre = new_head\n        p_cur = head\n          \n        p_insert = None\n        while p_cur:\n            if p_cur.val >= x and not p_insert:\n                p_insert = p_pre\n            elif p_cur.val < x:\n                if p_insert:\n                    p_pre.next = p_cur.next\n                    p_cur.next = p_insert.next\n                    p_insert.next = p_cur\n                    p_cur = p_pre.next\n                    p_insert = p_insert.next\n                    continue\n            p_pre = p_pre.next\n            p_cur = p_cur.next\n        \n        return new_head.next\n```\n\n### 2. 两个指针 \n第二种是新构建两个链表分别存储，具体实现过程如下：\n\n```python\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        p_l = l_head = ListNode(0)\n        p_r = r_head = ListNode(0)\n        \n        p_cur = head\n        while p_cur:\n            if p_cur.val >= x:\n                p_r.next = p_cur\n                p_r = p_r.next\n            else:\n                p_l.next = p_cur\n                p_l = p_l.next\n            p_cur = p_cur.next\n        \n        p_l.next = r_head.next\n        p_r.next = None\n        return l_head.next\n```","slug":"leetcode-PartitionList","published":1,"updated":"2019-02-25T08:00:10.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83l004ykvpxbqbp7fbl","content":"<h2 id=\"Partition-List\"><a href=\"#Partition-List\" class=\"headerlink\" title=\"Partition List\"></a><a href=\"https://leetcode.com/problems/partition-list/\" target=\"_blank\" rel=\"noopener\">Partition List</a></h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.<br>(切分链表)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_86.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-两个指针-In-place\"><a href=\"#1-两个指针-In-place\" class=\"headerlink\" title=\"1. 两个指针 In-place\"></a>1. 两个指针 In-place</h3><p>第一种是 in-place，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_pre = new_head</span><br><span class=\"line\">        p_cur = head</span><br><span class=\"line\">          </span><br><span class=\"line\">        p_insert = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p_cur.val &gt;= x <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p_insert:</span><br><span class=\"line\">                p_insert = p_pre</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> p_cur.val &lt; x:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p_insert:</span><br><span class=\"line\">                    p_pre.next = p_cur.next</span><br><span class=\"line\">                    p_cur.next = p_insert.next</span><br><span class=\"line\">                    p_insert.next = p_cur</span><br><span class=\"line\">                    p_cur = p_pre.next</span><br><span class=\"line\">                    p_insert = p_insert.next</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">            p_pre = p_pre.next</span><br><span class=\"line\">            p_cur = p_cur.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-两个指针\"><a href=\"#2-两个指针\" class=\"headerlink\" title=\"2. 两个指针\"></a>2. 两个指针</h3><p>第二种是新构建两个链表分别存储，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        p_l = l_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p_r = r_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_cur = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p_cur.val &gt;= x:</span><br><span class=\"line\">                p_r.next = p_cur</span><br><span class=\"line\">                p_r = p_r.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_l.next = p_cur</span><br><span class=\"line\">                p_l = p_l.next</span><br><span class=\"line\">            p_cur = p_cur.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_l.next = r_head.next</span><br><span class=\"line\">        p_r.next = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> l_head.next</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Partition-List\"><a href=\"#Partition-List\" class=\"headerlink\" title=\"Partition List\"></a><a href=\"https://leetcode.com/problems/partition-list/\" target=\"_blank\" rel=\"noopener\">Partition List</a></h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.<br>(切分链表)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_86.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-两个指针-In-place\"><a href=\"#1-两个指针-In-place\" class=\"headerlink\" title=\"1. 两个指针 In-place\"></a>1. 两个指针 In-place</h3><p>第一种是 in-place，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_pre = new_head</span><br><span class=\"line\">        p_cur = head</span><br><span class=\"line\">          </span><br><span class=\"line\">        p_insert = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p_cur.val &gt;= x <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p_insert:</span><br><span class=\"line\">                p_insert = p_pre</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> p_cur.val &lt; x:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p_insert:</span><br><span class=\"line\">                    p_pre.next = p_cur.next</span><br><span class=\"line\">                    p_cur.next = p_insert.next</span><br><span class=\"line\">                    p_insert.next = p_cur</span><br><span class=\"line\">                    p_cur = p_pre.next</span><br><span class=\"line\">                    p_insert = p_insert.next</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">            p_pre = p_pre.next</span><br><span class=\"line\">            p_cur = p_cur.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-两个指针\"><a href=\"#2-两个指针\" class=\"headerlink\" title=\"2. 两个指针\"></a>2. 两个指针</h3><p>第二种是新构建两个链表分别存储，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        p_l = l_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p_r = r_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_cur = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p_cur.val &gt;= x:</span><br><span class=\"line\">                p_r.next = p_cur</span><br><span class=\"line\">                p_r = p_r.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_l.next = p_cur</span><br><span class=\"line\">                p_l = p_l.next</span><br><span class=\"line\">            p_cur = p_cur.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_l.next = r_head.next</span><br><span class=\"line\">        p_r.next = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> l_head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_N-Queens II","date":"2019-01-09T14:06:26.000Z","_content":"\n## [N-Queens II](https://leetcode.com/problems/n-queens-ii/)\n\nThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n(N皇后的问题，求解个数)\n\n<div align=center>\n\t<img src=\"/images/leetcode_51_1.png\" width = \"200\" align=center/>\n</div>\n\n<!--more-->\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_52.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法\n与前一题方法相同，只需将具体的解法保存。具体实现过程如下：\n\n```python\nimport copy\n\nclass Solution:\n\tdef check(self, matrix, _i, _j):\n\t\tfor i in range(self.n):\n\t\t\tfor j in range(self.n):\n\t\t\t\tif matrix[i][j] == 'Q':\n\t\t\t\t\tif j == _j or abs(_i - i) == abs(_j - j):\n\t\t\t\t\t\treturn False\n\t\treturn True\n\n\tdef dfs(self, i, matrix):\n\t\tif (i == self.n):\n\t\t\tself.count += 1\n\t\telse:\n\t\t\tfor j in range(self.n):\n\t\t\t\tif self.check(matrix, i, j):\n\t\t\t\t\tmatrix[i][j] = 'Q'\n\t\t\t\t\tself.dfs(i+1, matrix)\n\t\t\t\t\tmatrix[i][j] = '.'\n\t\n\tdef totalNQueens(self, n):\n\t\t\"\"\"\n\t\t:type n: int\n\t\t:rtype: List[List[str]]\n\t\t\"\"\"\n\t\tself.n = n\n\t\tself.count = 0\n\n\t\tmatrix = [['.' for _ in range(self.n)] for _ in range(self.n)]\n\n\t\tself.dfs(0, matrix)\n\t\treturn self.count\n```","source":"_posts/leetcode-N-QueensII.md","raw":"---\ntitle: LeetCode_N-Queens II\ndate: 2019-01-09 22:06:26\ncategories: LeetCode\ntags: \n  - hard\n  - back tracking\n---\n\n## [N-Queens II](https://leetcode.com/problems/n-queens-ii/)\n\nThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n(N皇后的问题，求解个数)\n\n<div align=center>\n\t<img src=\"/images/leetcode_51_1.png\" width = \"200\" align=center/>\n</div>\n\n<!--more-->\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_52.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法\n与前一题方法相同，只需将具体的解法保存。具体实现过程如下：\n\n```python\nimport copy\n\nclass Solution:\n\tdef check(self, matrix, _i, _j):\n\t\tfor i in range(self.n):\n\t\t\tfor j in range(self.n):\n\t\t\t\tif matrix[i][j] == 'Q':\n\t\t\t\t\tif j == _j or abs(_i - i) == abs(_j - j):\n\t\t\t\t\t\treturn False\n\t\treturn True\n\n\tdef dfs(self, i, matrix):\n\t\tif (i == self.n):\n\t\t\tself.count += 1\n\t\telse:\n\t\t\tfor j in range(self.n):\n\t\t\t\tif self.check(matrix, i, j):\n\t\t\t\t\tmatrix[i][j] = 'Q'\n\t\t\t\t\tself.dfs(i+1, matrix)\n\t\t\t\t\tmatrix[i][j] = '.'\n\t\n\tdef totalNQueens(self, n):\n\t\t\"\"\"\n\t\t:type n: int\n\t\t:rtype: List[List[str]]\n\t\t\"\"\"\n\t\tself.n = n\n\t\tself.count = 0\n\n\t\tmatrix = [['.' for _ in range(self.n)] for _ in range(self.n)]\n\n\t\tself.dfs(0, matrix)\n\t\treturn self.count\n```","slug":"leetcode-N-QueensII","published":1,"updated":"2019-01-09T14:21:07.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83m0052kvpx00dseizv","content":"<h2 id=\"N-Queens-II\"><a href=\"#N-Queens-II\" class=\"headerlink\" title=\"N-Queens II\"></a><a href=\"https://leetcode.com/problems/n-queens-ii/\" target=\"_blank\" rel=\"noopener\">N-Queens II</a></h2><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>(N皇后的问题，求解个数)</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_51_1.png\" width=\"200\" align=\"center/\"><br></div>\n\n<a id=\"more\"></a>\n<p>Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_52.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>与前一题方法相同，只需将具体的解法保存。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(self, matrix, _i, _j)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">'Q'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> j == _j <span class=\"keyword\">or</span> abs(_i - i) == abs(_j - j):</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, matrix)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == self.n):</span><br><span class=\"line\">\t\t\tself.count += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.check(matrix, i, j):</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\t\t\tself.dfs(i+<span class=\"number\">1</span>, matrix)</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">totalNQueens</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type n: int</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.n = n</span><br><span class=\"line\">\t\tself.count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmatrix = [[<span class=\"string\">'.'</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.dfs(<span class=\"number\">0</span>, matrix)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self.count</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"N-Queens-II\"><a href=\"#N-Queens-II\" class=\"headerlink\" title=\"N-Queens II\"></a><a href=\"https://leetcode.com/problems/n-queens-ii/\" target=\"_blank\" rel=\"noopener\">N-Queens II</a></h2><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>(N皇后的问题，求解个数)</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_51_1.png\" width=\"200\" align=\"center/\"><br></div>","more":"<p>Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_52.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法\"><a href=\"#1-回溯法\" class=\"headerlink\" title=\"1. 回溯法\"></a>1. 回溯法</h3><p>与前一题方法相同，只需将具体的解法保存。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(self, matrix, _i, _j)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">'Q'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> j == _j <span class=\"keyword\">or</span> abs(_i - i) == abs(_j - j):</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, matrix)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == self.n):</span><br><span class=\"line\">\t\t\tself.count += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(self.n):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.check(matrix, i, j):</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\t\t\tself.dfs(i+<span class=\"number\">1</span>, matrix)</span><br><span class=\"line\">\t\t\t\t\tmatrix[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">totalNQueens</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type n: int</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.n = n</span><br><span class=\"line\">\t\tself.count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmatrix = [[<span class=\"string\">'.'</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.n)]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.dfs(<span class=\"number\">0</span>, matrix)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self.count</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Path Sum","date":"2019-03-05T02:16:53.000Z","_content":"\n## [Path Sum](https://leetcode.com/problems/path-sum/)\n\nGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children.\n（二叉树路径和）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_112.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root:\n            return False\n        \n        # must be leaf \n        if root.val == sum and not root.left and not root.right:\n            return True\n        \n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\n```","source":"_posts/leetcode-PathSum.md","raw":"---\ntitle: LeetCode_Path Sum\ndate: 2019-03-05 10:16:53\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n---\n\n## [Path Sum](https://leetcode.com/problems/path-sum/)\n\nGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children.\n（二叉树路径和）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_112.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root:\n            return False\n        \n        # must be leaf \n        if root.val == sum and not root.left and not root.right:\n            return True\n        \n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\n```","slug":"leetcode-PathSum","published":1,"updated":"2019-03-05T02:22:46.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83n0054kvpx3ksm4wp5","content":"<h2 id=\"Path-Sum\"><a href=\"#Path-Sum\" class=\"headerlink\" title=\"Path Sum\"></a><a href=\"https://leetcode.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">Path Sum</a></h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children.<br>（二叉树路径和）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_112.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># must be leaf </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.val == sum <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.hasPathSum(root.left, sum-root.val) <span class=\"keyword\">or</span> self.hasPathSum(root.right, sum-root.val)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Path-Sum\"><a href=\"#Path-Sum\" class=\"headerlink\" title=\"Path Sum\"></a><a href=\"https://leetcode.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">Path Sum</a></h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children.<br>（二叉树路径和）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_112.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># must be leaf </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.val == sum <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.hasPathSum(root.left, sum-root.val) <span class=\"keyword\">or</span> self.hasPathSum(root.right, sum-root.val)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Path Sum II","date":"2019-03-05T03:43:37.000Z","_content":"\n## [Path Sum II](https://leetcode.com/problems/path-sum-ii/)\n\nGiven a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children.\n（二叉树路径和并返回相应路径）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_113.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n这道题是很清晰的递归的问题，需要注意的是节点的值可能是负值。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        def path_helper(head, path, sum):\n            if sum == head.val and not head.left and not head.right:\n                self.paths.append(path+[head.val])\n                return\n            \n            if head.left:\n                path_helper(head.left, path+[head.val], sum-head.val)\n            if head.right:\n                path_helper(head.right, path+[head.val], sum-head.val)\n                  \n        if not root:\n            return []\n        \n        self.paths = []\n        path_helper(root, [], sum)\n        \n        return self.paths\n```\n\n\n\n\n\n\n","source":"_posts/leetcode-PathSumII.md","raw":"---\ntitle: LeetCode_Path Sum II\ndate: 2019-03-05 11:43:37\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - dfs\n---\n\n## [Path Sum II](https://leetcode.com/problems/path-sum-ii/)\n\nGiven a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children.\n（二叉树路径和并返回相应路径）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_113.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n这道题是很清晰的递归的问题，需要注意的是节点的值可能是负值。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        def path_helper(head, path, sum):\n            if sum == head.val and not head.left and not head.right:\n                self.paths.append(path+[head.val])\n                return\n            \n            if head.left:\n                path_helper(head.left, path+[head.val], sum-head.val)\n            if head.right:\n                path_helper(head.right, path+[head.val], sum-head.val)\n                  \n        if not root:\n            return []\n        \n        self.paths = []\n        path_helper(root, [], sum)\n        \n        return self.paths\n```\n\n\n\n\n\n\n","slug":"leetcode-PathSumII","published":1,"updated":"2019-03-05T06:14:16.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83o0057kvpxznbn61jz","content":"<h2 id=\"Path-Sum-II\"><a href=\"#Path-Sum-II\" class=\"headerlink\" title=\"Path Sum II\"></a><a href=\"https://leetcode.com/problems/path-sum-ii/\" target=\"_blank\" rel=\"noopener\">Path Sum II</a></h2><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children.<br>（二叉树路径和并返回相应路径）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_113.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>这道题是很清晰的递归的问题，需要注意的是节点的值可能是负值。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">path_helper</span><span class=\"params\">(head, path, sum)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> sum == head.val <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> head.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> head.right:</span><br><span class=\"line\">                self.paths.append(path+[head.val])</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> head.left:</span><br><span class=\"line\">                path_helper(head.left, path+[head.val], sum-head.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> head.right:</span><br><span class=\"line\">                path_helper(head.right, path+[head.val], sum-head.val)</span><br><span class=\"line\">                  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.paths = []</span><br><span class=\"line\">        path_helper(root, [], sum)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.paths</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Path-Sum-II\"><a href=\"#Path-Sum-II\" class=\"headerlink\" title=\"Path Sum II\"></a><a href=\"https://leetcode.com/problems/path-sum-ii/\" target=\"_blank\" rel=\"noopener\">Path Sum II</a></h2><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children.<br>（二叉树路径和并返回相应路径）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_113.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>这道题是很清晰的递归的问题，需要注意的是节点的值可能是负值。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">path_helper</span><span class=\"params\">(head, path, sum)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> sum == head.val <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> head.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> head.right:</span><br><span class=\"line\">                self.paths.append(path+[head.val])</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> head.left:</span><br><span class=\"line\">                path_helper(head.left, path+[head.val], sum-head.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> head.right:</span><br><span class=\"line\">                path_helper(head.right, path+[head.val], sum-head.val)</span><br><span class=\"line\">                  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.paths = []</span><br><span class=\"line\">        path_helper(root, [], sum)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.paths</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Permutations","date":"2019-01-09T05:24:50.000Z","_content":"\n## [Permutations](https://leetcode.com/problems/permutations/)\n\nGiven a collection of **distinct** integers, return all possible permutations.\n(排列组合)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_46.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：\n\n```python\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 1:\n            return [nums]\n\n        results = []\t\n        for item in nums:\n            new_nums = [num for num in nums if num != item]\n            result = self.permute(new_nums)\n            if len(result[0]) == 1:\n                results.append([item, result[0][0]])\n            else:\n                for _list in result:\n                    results.append([item] + [data for data in _list])\n        return results\n```\n\n\n### 2. DFS\n\n另外一个思路是在看别人的解法发现的，使用**深度优先搜索（DFS）**的方法，具体实现方法如下：\n\n```python\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        permutations = []\n        self.dfs(permutations, [], nums)\n        \n        return permutations\n    \n    def dfs(self, perms, perm_in_progress, nums):\n        # If we're out of numbers to use, Perm_in_progress is finished\n        if not nums:\n            perms.append(perm_in_progress)\n        for index in range(0, len(nums)):\n            self.dfs(perms, perm_in_progress + [nums[index]], nums[:index] + nums[index+1:])\n```\n","source":"_posts/leetcode-Permutations.md","raw":"---\ntitle: LeetCode_Permutations\ndate: 2019-01-09 13:24:50\ncategories: LeetCode\ntags: \n  - medium\n  - back tracking\n---\n\n## [Permutations](https://leetcode.com/problems/permutations/)\n\nGiven a collection of **distinct** integers, return all possible permutations.\n(排列组合)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_46.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：\n\n```python\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 1:\n            return [nums]\n\n        results = []\t\n        for item in nums:\n            new_nums = [num for num in nums if num != item]\n            result = self.permute(new_nums)\n            if len(result[0]) == 1:\n                results.append([item, result[0][0]])\n            else:\n                for _list in result:\n                    results.append([item] + [data for data in _list])\n        return results\n```\n\n\n### 2. DFS\n\n另外一个思路是在看别人的解法发现的，使用**深度优先搜索（DFS）**的方法，具体实现方法如下：\n\n```python\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        permutations = []\n        self.dfs(permutations, [], nums)\n        \n        return permutations\n    \n    def dfs(self, perms, perm_in_progress, nums):\n        # If we're out of numbers to use, Perm_in_progress is finished\n        if not nums:\n            perms.append(perm_in_progress)\n        for index in range(0, len(nums)):\n            self.dfs(perms, perm_in_progress + [nums[index]], nums[:index] + nums[index+1:])\n```\n","slug":"leetcode-Permutations","published":1,"updated":"2019-01-14T10:49:48.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83r005akvpx622bzyam","content":"<h2 id=\"Permutations\"><a href=\"#Permutations\" class=\"headerlink\" title=\"Permutations\"></a><a href=\"https://leetcode.com/problems/permutations/\" target=\"_blank\" rel=\"noopener\">Permutations</a></h2><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.<br>(排列组合)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_46.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\"></span><br><span class=\"line\">        results = []\t</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            new_nums = [num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num != item]</span><br><span class=\"line\">            result = self.permute(new_nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(result[<span class=\"number\">0</span>]) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                results.append([item, result[<span class=\"number\">0</span>][<span class=\"number\">0</span>]])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _list <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                    results.append([item] + [data <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> _list])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-DFS\"><a href=\"#2-DFS\" class=\"headerlink\" title=\"2. DFS\"></a>2. DFS</h3><p>另外一个思路是在看别人的解法发现的，使用<strong>深度优先搜索（DFS）</strong>的方法，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        permutations = []</span><br><span class=\"line\">        self.dfs(permutations, [], nums)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> permutations</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, perms, perm_in_progress, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># If we're out of numbers to use, Perm_in_progress is finished</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            perms.append(perm_in_progress)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(nums)):</span><br><span class=\"line\">            self.dfs(perms, perm_in_progress + [nums[index]], nums[:index] + nums[index+<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Permutations\"><a href=\"#Permutations\" class=\"headerlink\" title=\"Permutations\"></a><a href=\"https://leetcode.com/problems/permutations/\" target=\"_blank\" rel=\"noopener\">Permutations</a></h2><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.<br>(排列组合)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_46.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\"></span><br><span class=\"line\">        results = []\t</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            new_nums = [num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num != item]</span><br><span class=\"line\">            result = self.permute(new_nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(result[<span class=\"number\">0</span>]) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                results.append([item, result[<span class=\"number\">0</span>][<span class=\"number\">0</span>]])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _list <span class=\"keyword\">in</span> result:</span><br><span class=\"line\">                    results.append([item] + [data <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> _list])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-DFS\"><a href=\"#2-DFS\" class=\"headerlink\" title=\"2. DFS\"></a>2. DFS</h3><p>另外一个思路是在看别人的解法发现的，使用<strong>深度优先搜索（DFS）</strong>的方法，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        permutations = []</span><br><span class=\"line\">        self.dfs(permutations, [], nums)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> permutations</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, perms, perm_in_progress, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># If we're out of numbers to use, Perm_in_progress is finished</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            perms.append(perm_in_progress)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(nums)):</span><br><span class=\"line\">            self.dfs(perms, perm_in_progress + [nums[index]], nums[:index] + nums[index+<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Permutation Sequence","date":"2019-01-13T07:48:55.000Z","_content":"\n## [Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)\n\nThe set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\", \"132\", \"213\", \"231\", \"312\", \"321\". Given n and k, return the k_th permutation sequence.\n(排列组合结果的第 K 项)\n\n<!--more-->\n\n**Note:**\n1. Given n will be between 1 and 9 inclusive.\n2. Given k will be between 1 and n! inclusive.\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_60.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 找规律\n\n在n=4，k=9时，\n1. 最高位可以取{1, 2, 3, 4}，而每个数重复3!=6次。所以第 k=9 个排列的 s[0] 为{1, 2, 3, 4}中的第 9/6+1=2 个数字，即s[0]=2；\n2. 同样地，对于以 **2** 开头的6个数字而言，k=9是其中的第 k'=9%(3!)=3 个。而剩下的数字{1, 3, 4}的重复周期为 2!=2次。所以 s[1] 为{1, 3, 4} 中的第k'/(2!)+1=2个，即 s[1]=3；\n3. 以此类推，对于以 **23** 开头的2个数字而言，k=9是其中的第k''=k'%(2!)=1 个。剩下的数字{1, 4}的重复周期为 1!=1次。所以 s[2]=1；\n4. 对于以 **231** 开头的一个数字而言，k=9是其中的第k'''=k''/(1!)+1=1 个。所以s[3]=4。\n\n综上所述，按照顺序寻找 n 的全排列中的第 k 个，也是就是不断地对 (n-1)! 取商和余数的过程。这里使用 k-1 来判断是为了方便处理边界条件。具体实现方法如下：\n\n```python\nclass Solution:\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        nums = [str(i) for i in range(1, n+1)]\n        result = ''\n\n        k -= 1\n        for i in range(n):\n            rank, k = divmod(k, math.factorial(n-i-1))\n            result += nums[rank]\n            # nums.remove(nums[rank])\n            nums.pop(rank)\n\n        return result\n```\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-PermutationSequence.md","raw":"---\ntitle: LeetCode_Permutation Sequence\ndate: 2019-01-13 15:48:55\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - back tracking\n---\n\n## [Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)\n\nThe set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\", \"132\", \"213\", \"231\", \"312\", \"321\". Given n and k, return the k_th permutation sequence.\n(排列组合结果的第 K 项)\n\n<!--more-->\n\n**Note:**\n1. Given n will be between 1 and 9 inclusive.\n2. Given k will be between 1 and n! inclusive.\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_60.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 找规律\n\n在n=4，k=9时，\n1. 最高位可以取{1, 2, 3, 4}，而每个数重复3!=6次。所以第 k=9 个排列的 s[0] 为{1, 2, 3, 4}中的第 9/6+1=2 个数字，即s[0]=2；\n2. 同样地，对于以 **2** 开头的6个数字而言，k=9是其中的第 k'=9%(3!)=3 个。而剩下的数字{1, 3, 4}的重复周期为 2!=2次。所以 s[1] 为{1, 3, 4} 中的第k'/(2!)+1=2个，即 s[1]=3；\n3. 以此类推，对于以 **23** 开头的2个数字而言，k=9是其中的第k''=k'%(2!)=1 个。剩下的数字{1, 4}的重复周期为 1!=1次。所以 s[2]=1；\n4. 对于以 **231** 开头的一个数字而言，k=9是其中的第k'''=k''/(1!)+1=1 个。所以s[3]=4。\n\n综上所述，按照顺序寻找 n 的全排列中的第 k 个，也是就是不断地对 (n-1)! 取商和余数的过程。这里使用 k-1 来判断是为了方便处理边界条件。具体实现方法如下：\n\n```python\nclass Solution:\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        nums = [str(i) for i in range(1, n+1)]\n        result = ''\n\n        k -= 1\n        for i in range(n):\n            rank, k = divmod(k, math.factorial(n-i-1))\n            result += nums[rank]\n            # nums.remove(nums[rank])\n            nums.pop(rank)\n\n        return result\n```\n\n\n\n\n\n\n\n\n","slug":"leetcode-PermutationSequence","published":1,"updated":"2019-01-13T17:10:22.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83t005ekvpx6kfn72vx","content":"<h2 id=\"Permutation-Sequence\"><a href=\"#Permutation-Sequence\" class=\"headerlink\" title=\"Permutation Sequence\"></a><a href=\"https://leetcode.com/problems/permutation-sequence/\" target=\"_blank\" rel=\"noopener\">Permutation Sequence</a></h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: “123”, “132”, “213”, “231”, “312”, “321”. Given n and k, return the k_th permutation sequence.<br>(排列组合结果的第 K 项)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ol>\n<li>Given n will be between 1 and 9 inclusive.</li>\n<li>Given k will be between 1 and n! inclusive.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_60.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-找规律\"><a href=\"#1-找规律\" class=\"headerlink\" title=\"1. 找规律\"></a>1. 找规律</h3><p>在n=4，k=9时，</p>\n<ol>\n<li>最高位可以取{1, 2, 3, 4}，而每个数重复3!=6次。所以第 k=9 个排列的 s[0] 为{1, 2, 3, 4}中的第 9/6+1=2 个数字，即s[0]=2；</li>\n<li>同样地，对于以 <strong>2</strong> 开头的6个数字而言，k=9是其中的第 k’=9%(3!)=3 个。而剩下的数字{1, 3, 4}的重复周期为 2!=2次。所以 s[1] 为{1, 3, 4} 中的第k’/(2!)+1=2个，即 s[1]=3；</li>\n<li>以此类推，对于以 <strong>23</strong> 开头的2个数字而言，k=9是其中的第k’’=k’%(2!)=1 个。剩下的数字{1, 4}的重复周期为 1!=1次。所以 s[2]=1；</li>\n<li>对于以 <strong>231</strong> 开头的一个数字而言，k=9是其中的第k’’’=k’’/(1!)+1=1 个。所以s[3]=4。</li>\n</ol>\n<p>综上所述，按照顺序寻找 n 的全排列中的第 k 个，也是就是不断地对 (n-1)! 取商和余数的过程。这里使用 k-1 来判断是为了方便处理边界条件。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPermutation</span><span class=\"params\">(self, n, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        nums = [str(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        result = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">        k -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            rank, k = divmod(k, math.factorial(n-i<span class=\"number\">-1</span>))</span><br><span class=\"line\">            result += nums[rank]</span><br><span class=\"line\">            <span class=\"comment\"># nums.remove(nums[rank])</span></span><br><span class=\"line\">            nums.pop(rank)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Permutation-Sequence\"><a href=\"#Permutation-Sequence\" class=\"headerlink\" title=\"Permutation Sequence\"></a><a href=\"https://leetcode.com/problems/permutation-sequence/\" target=\"_blank\" rel=\"noopener\">Permutation Sequence</a></h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: “123”, “132”, “213”, “231”, “312”, “321”. Given n and k, return the k_th permutation sequence.<br>(排列组合结果的第 K 项)</p>","more":"<p><strong>Note:</strong></p>\n<ol>\n<li>Given n will be between 1 and 9 inclusive.</li>\n<li>Given k will be between 1 and n! inclusive.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_60.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-找规律\"><a href=\"#1-找规律\" class=\"headerlink\" title=\"1. 找规律\"></a>1. 找规律</h3><p>在n=4，k=9时，</p>\n<ol>\n<li>最高位可以取{1, 2, 3, 4}，而每个数重复3!=6次。所以第 k=9 个排列的 s[0] 为{1, 2, 3, 4}中的第 9/6+1=2 个数字，即s[0]=2；</li>\n<li>同样地，对于以 <strong>2</strong> 开头的6个数字而言，k=9是其中的第 k’=9%(3!)=3 个。而剩下的数字{1, 3, 4}的重复周期为 2!=2次。所以 s[1] 为{1, 3, 4} 中的第k’/(2!)+1=2个，即 s[1]=3；</li>\n<li>以此类推，对于以 <strong>23</strong> 开头的2个数字而言，k=9是其中的第k’’=k’%(2!)=1 个。剩下的数字{1, 4}的重复周期为 1!=1次。所以 s[2]=1；</li>\n<li>对于以 <strong>231</strong> 开头的一个数字而言，k=9是其中的第k’’’=k’’/(1!)+1=1 个。所以s[3]=4。</li>\n</ol>\n<p>综上所述，按照顺序寻找 n 的全排列中的第 k 个，也是就是不断地对 (n-1)! 取商和余数的过程。这里使用 k-1 来判断是为了方便处理边界条件。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPermutation</span><span class=\"params\">(self, n, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        nums = [str(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        result = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">        k -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            rank, k = divmod(k, math.factorial(n-i<span class=\"number\">-1</span>))</span><br><span class=\"line\">            result += nums[rank]</span><br><span class=\"line\">            <span class=\"comment\"># nums.remove(nums[rank])</span></span><br><span class=\"line\">            nums.pop(rank)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Permutations II","date":"2019-01-09T05:51:06.000Z","_content":"\n## [Permutations II](https://leetcode.com/problems/permutations-ii/)\n\nGiven a collection of numbers that might **contain duplicates**, return all possible unique permutations.\n(含有重复元素的全排列)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_47.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：\n\n```python\nclass Solution:\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 1:\n            return [nums]\n\n        results = []\t\n        for i, item in enumerate(nums):\n            new_nums = nums[0:i] + nums[i+1:]\n            remain_results = self.permuteUnique(new_nums)\n\n            if len(remain_results[0]) == 1:\n                result = [item, remain_results[0][0]]\n                if result not in results:\n                    results.append(result)\n            else:\n                for items in remain_results:\n                    result = [item] + [data for data in items]\n                    if result not in results:\n                        results.append(result)\n        return results\n```","source":"_posts/leetcode-PermutationsII.md","raw":"---\ntitle: LeetCode_Permutations II\ndate: 2019-01-09 13:51:06\ncategories: LeetCode\ntags: \n  - medium\n  - back tracking\n---\n\n## [Permutations II](https://leetcode.com/problems/permutations-ii/)\n\nGiven a collection of numbers that might **contain duplicates**, return all possible unique permutations.\n(含有重复元素的全排列)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_47.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：\n\n```python\nclass Solution:\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 1:\n            return [nums]\n\n        results = []\t\n        for i, item in enumerate(nums):\n            new_nums = nums[0:i] + nums[i+1:]\n            remain_results = self.permuteUnique(new_nums)\n\n            if len(remain_results[0]) == 1:\n                result = [item, remain_results[0][0]]\n                if result not in results:\n                    results.append(result)\n            else:\n                for items in remain_results:\n                    result = [item] + [data for data in items]\n                    if result not in results:\n                        results.append(result)\n        return results\n```","slug":"leetcode-PermutationsII","published":1,"updated":"2019-01-09T06:07:12.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83u005hkvpxkust0c23","content":"<h2 id=\"Permutations-II\"><a href=\"#Permutations-II\" class=\"headerlink\" title=\"Permutations II\"></a><a href=\"https://leetcode.com/problems/permutations-ii/\" target=\"_blank\" rel=\"noopener\">Permutations II</a></h2><p>Given a collection of numbers that might <strong>contain duplicates</strong>, return all possible unique permutations.<br>(含有重复元素的全排列)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_47.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\"></span><br><span class=\"line\">        results = []\t</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            new_nums = nums[<span class=\"number\">0</span>:i] + nums[i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">            remain_results = self.permuteUnique(new_nums)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(remain_results[<span class=\"number\">0</span>]) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                result = [item, remain_results[<span class=\"number\">0</span>][<span class=\"number\">0</span>]]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> result <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">                    results.append(result)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> items <span class=\"keyword\">in</span> remain_results:</span><br><span class=\"line\">                    result = [item] + [data <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> items]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> result <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">                        results.append(result)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Permutations-II\"><a href=\"#Permutations-II\" class=\"headerlink\" title=\"Permutations II\"></a><a href=\"https://leetcode.com/problems/permutations-ii/\" target=\"_blank\" rel=\"noopener\">Permutations II</a></h2><p>Given a collection of numbers that might <strong>contain duplicates</strong>, return all possible unique permutations.<br>(含有重复元素的全排列)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_47.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\"></span><br><span class=\"line\">        results = []\t</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            new_nums = nums[<span class=\"number\">0</span>:i] + nums[i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">            remain_results = self.permuteUnique(new_nums)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(remain_results[<span class=\"number\">0</span>]) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                result = [item, remain_results[<span class=\"number\">0</span>][<span class=\"number\">0</span>]]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> result <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">                    results.append(result)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> items <span class=\"keyword\">in</span> remain_results:</span><br><span class=\"line\">                    result = [item] + [data <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> items]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> result <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">                        results.append(result)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Populating Next Right Pointers in Each Node","date":"2019-03-05T12:58:21.000Z","_content":"\n## [Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)\n\nYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.\n（连接完全二叉树同一层的结点）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_116.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n在递归的过程中需要考虑左、右子树，兄弟结点之间的连接。具体实现过程如下：\n\n```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, left, right, next):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root or not root.left:\n            return root\n        \n        # 左、右子树的连接\n        if root.left and root.right:\n            root.left.next = root.right\n        \n        # 兄弟节点的连接\n        if root.next and root.right:\n            root.right.next = root.next.left\n            \n        self.connect(root.left)\n        self.connect(root.right)\n\n        return root\n```","source":"_posts/leetcode-PopulatingNextRightPointersinEachNode.md","raw":"---\ntitle: LeetCode_Populating Next Right Pointers in Each Node\ndate: 2019-03-05 20:58:21\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - dfs\n---\n\n## [Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)\n\nYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.\n（连接完全二叉树同一层的结点）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_116.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n在递归的过程中需要考虑左、右子树，兄弟结点之间的连接。具体实现过程如下：\n\n```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, left, right, next):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root or not root.left:\n            return root\n        \n        # 左、右子树的连接\n        if root.left and root.right:\n            root.left.next = root.right\n        \n        # 兄弟节点的连接\n        if root.next and root.right:\n            root.right.next = root.next.left\n            \n        self.connect(root.left)\n        self.connect(root.right)\n\n        return root\n```","slug":"leetcode-PopulatingNextRightPointersinEachNode","published":1,"updated":"2019-03-06T07:48:13.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht83y005lkvpxi7ndj2vy","content":"<h2 id=\"Populating-Next-Right-Pointers-in-Each-Node\"><a href=\"#Populating-Next-Right-Pointers-in-Each-Node\" class=\"headerlink\" title=\"Populating Next Right Pointers in Each Node\"></a><a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">Populating Next Right Pointers in Each Node</a></h2><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.<br>（连接完全二叉树同一层的结点）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_116.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>在递归的过程中需要考虑左、右子树，兄弟结点之间的连接。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\"># Definition for a Node.</span></span><br><span class=\"line\"><span class=\"string\">class Node:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, left, right, next):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left = left</span></span><br><span class=\"line\"><span class=\"string\">        self.right = right</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">connect</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> root.left:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 左、右子树的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">            root.left.next = root.right</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 兄弟节点的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.next <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">            root.right.next = root.next.left</span><br><span class=\"line\">            </span><br><span class=\"line\">        self.connect(root.left)</span><br><span class=\"line\">        self.connect(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Populating-Next-Right-Pointers-in-Each-Node\"><a href=\"#Populating-Next-Right-Pointers-in-Each-Node\" class=\"headerlink\" title=\"Populating Next Right Pointers in Each Node\"></a><a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">Populating Next Right Pointers in Each Node</a></h2><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.<br>（连接完全二叉树同一层的结点）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_116.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>在递归的过程中需要考虑左、右子树，兄弟结点之间的连接。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\"># Definition for a Node.</span></span><br><span class=\"line\"><span class=\"string\">class Node:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, left, right, next):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left = left</span></span><br><span class=\"line\"><span class=\"string\">        self.right = right</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">connect</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> root.left:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 左、右子树的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">            root.left.next = root.right</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 兄弟节点的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.next <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">            root.right.next = root.next.left</span><br><span class=\"line\">            </span><br><span class=\"line\">        self.connect(root.left)</span><br><span class=\"line\">        self.connect(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Populating Next Right Pointers in Each Node II","date":"2019-03-06T07:19:05.000Z","_content":"\n## [Populating Next Right Pointers in Each Node II](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)\n\nGiven a binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.\n（连接二叉树同一层的结点）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_117.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n```python\n\n```","source":"_posts/leetcode-PopulatingNextRightPointersinEachNodeII.md","raw":"---\ntitle: LeetCode_Populating Next Right Pointers in Each Node II\ndate: 2019-03-06 15:19:05\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - dfs\n---\n\n## [Populating Next Right Pointers in Each Node II](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)\n\nGiven a binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.\n（连接二叉树同一层的结点）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_117.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n```python\n\n```","slug":"leetcode-PopulatingNextRightPointersinEachNodeII","published":1,"updated":"2019-03-06T07:23:26.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht840005okvpxuv35p3l0","content":"<h2 id=\"Populating-Next-Right-Pointers-in-Each-Node-II\"><a href=\"#Populating-Next-Right-Pointers-in-Each-Node-II\" class=\"headerlink\" title=\"Populating Next Right Pointers in Each Node II\"></a><a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\" target=\"_blank\" rel=\"noopener\">Populating Next Right Pointers in Each Node II</a></h2><p>Given a binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.<br>（连接二叉树同一层的结点）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_117.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Populating-Next-Right-Pointers-in-Each-Node-II\"><a href=\"#Populating-Next-Right-Pointers-in-Each-Node-II\" class=\"headerlink\" title=\"Populating Next Right Pointers in Each Node II\"></a><a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\" target=\"_blank\" rel=\"noopener\">Populating Next Right Pointers in Each Node II</a></h2><p>Given a binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.<br>（连接二叉树同一层的结点）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_117.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Plus One","date":"2019-01-24T09:35:10.000Z","_content":"\n## [Plus One](https://leetcode.com/problems/plus-one/)\n\nGiven a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.\n（数组形式的数字串数值加1）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_66.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 加法进位原则\n**Note:** 需要特别注意第一个数字进位的情况。\n\n```python\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(digits)\n\n        add = 1\n        result = [0 for _ in range(n+1)]\n\n        for i in range(n-1, -1, -1):\n            add += digits[i]\n            result[i+1] = add % 10\n            add = add // 10\n        \n        if add == 0:\n            return result[1:]\n        else:\n            result[0] = add\n            return result\n```","source":"_posts/leetcode-PlusOne.md","raw":"---\ntitle: LeetCode_Plus One\ndate: 2019-01-24 17:35:10\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - math\n---\n\n## [Plus One](https://leetcode.com/problems/plus-one/)\n\nGiven a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.\n（数组形式的数字串数值加1）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_66.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 加法进位原则\n**Note:** 需要特别注意第一个数字进位的情况。\n\n```python\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(digits)\n\n        add = 1\n        result = [0 for _ in range(n+1)]\n\n        for i in range(n-1, -1, -1):\n            add += digits[i]\n            result[i+1] = add % 10\n            add = add // 10\n        \n        if add == 0:\n            return result[1:]\n        else:\n            result[0] = add\n            return result\n```","slug":"leetcode-PlusOne","published":1,"updated":"2019-01-24T10:47:57.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht842005skvpxwhe1de83","content":"<h2 id=\"Plus-One\"><a href=\"#Plus-One\" class=\"headerlink\" title=\"Plus One\"></a><a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">Plus One</a></h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.<br>（数组形式的数字串数值加1）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_66.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-加法进位原则\"><a href=\"#1-加法进位原则\" class=\"headerlink\" title=\"1. 加法进位原则\"></a>1. 加法进位原则</h3><p><strong>Note:</strong> 需要特别注意第一个数字进位的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">plusOne</span><span class=\"params\">(self, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type digits: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(digits)</span><br><span class=\"line\"></span><br><span class=\"line\">        add = <span class=\"number\">1</span></span><br><span class=\"line\">        result = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            add += digits[i]</span><br><span class=\"line\">            result[i+<span class=\"number\">1</span>] = add % <span class=\"number\">10</span></span><br><span class=\"line\">            add = add // <span class=\"number\">10</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> add == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result[<span class=\"number\">0</span>] = add</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Plus-One\"><a href=\"#Plus-One\" class=\"headerlink\" title=\"Plus One\"></a><a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">Plus One</a></h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.<br>（数组形式的数字串数值加1）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_66.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-加法进位原则\"><a href=\"#1-加法进位原则\" class=\"headerlink\" title=\"1. 加法进位原则\"></a>1. 加法进位原则</h3><p><strong>Note:</strong> 需要特别注意第一个数字进位的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">plusOne</span><span class=\"params\">(self, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type digits: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(digits)</span><br><span class=\"line\"></span><br><span class=\"line\">        add = <span class=\"number\">1</span></span><br><span class=\"line\">        result = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            add += digits[i]</span><br><span class=\"line\">            result[i+<span class=\"number\">1</span>] = add % <span class=\"number\">10</span></span><br><span class=\"line\">            add = add // <span class=\"number\">10</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> add == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result[<span class=\"number\">0</span>] = add</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Pow(x, n)","date":"2019-01-09T07:02:05.000Z","_content":"\n## [Pow(x, n)](https://leetcode.com/problems/powx-n/)\n\nImplement pow(x, n), which calculates x raised to the power n (x^n).\n(指数计算)\n\n<!--more-->\n\n**Note:** \n1. -100.0 < x < 100.0\n2. n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_50.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n\n类似于二分法的方式进行指数运算。其中比较巧妙的地方是在 abs(n) 是奇数时，无论 n 是正数还是负数，left = n // 2 一定是比较小的哪一个，因此最终的结果一定是另外**乘以 x**。\n\n```python\nclass Solution:\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        if n == -1:\n            return 1/x\n\n        left = n // 2\n        re = self.myPow(x, left)\n\n        if left * 2 == n:\n            return re * re\n        else:\n            return re * re * x\n```","source":"_posts/leetcode-Pow-x-n.md","raw":"---\ntitle: LeetCode_Pow(x, n)\ndate: 2019-01-09 15:02:05\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - hash table\n---\n\n## [Pow(x, n)](https://leetcode.com/problems/powx-n/)\n\nImplement pow(x, n), which calculates x raised to the power n (x^n).\n(指数计算)\n\n<!--more-->\n\n**Note:** \n1. -100.0 < x < 100.0\n2. n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_50.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n\n类似于二分法的方式进行指数运算。其中比较巧妙的地方是在 abs(n) 是奇数时，无论 n 是正数还是负数，left = n // 2 一定是比较小的哪一个，因此最终的结果一定是另外**乘以 x**。\n\n```python\nclass Solution:\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        if n == -1:\n            return 1/x\n\n        left = n // 2\n        re = self.myPow(x, left)\n\n        if left * 2 == n:\n            return re * re\n        else:\n            return re * re * x\n```","slug":"leetcode-Pow-x-n","published":1,"updated":"2019-01-09T07:24:48.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht843005vkvpxrnkx0q9y","content":"<h2 id=\"Pow-x-n\"><a href=\"#Pow-x-n\" class=\"headerlink\" title=\"Pow(x, n)\"></a><a href=\"https://leetcode.com/problems/powx-n/\" target=\"_blank\" rel=\"noopener\">Pow(x, n)</a></h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).<br>(指数计算)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> </p>\n<ol>\n<li>-100.0 &lt; x &lt; 100.0</li>\n<li>n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_50.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>类似于二分法的方式进行指数运算。其中比较巧妙的地方是在 abs(n) 是奇数时，无论 n 是正数还是负数，left = n // 2 一定是比较小的哪一个，因此最终的结果一定是另外<strong>乘以 x</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: float</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/x</span><br><span class=\"line\"></span><br><span class=\"line\">        left = n // <span class=\"number\">2</span></span><br><span class=\"line\">        re = self.myPow(x, left)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left * <span class=\"number\">2</span> == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> re * re</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> re * re * x</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Pow-x-n\"><a href=\"#Pow-x-n\" class=\"headerlink\" title=\"Pow(x, n)\"></a><a href=\"https://leetcode.com/problems/powx-n/\" target=\"_blank\" rel=\"noopener\">Pow(x, n)</a></h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).<br>(指数计算)</p>","more":"<p><strong>Note:</strong> </p>\n<ol>\n<li>-100.0 &lt; x &lt; 100.0</li>\n<li>n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_50.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>类似于二分法的方式进行指数运算。其中比较巧妙的地方是在 abs(n) 是奇数时，无论 n 是正数还是负数，left = n // 2 一定是比较小的哪一个，因此最终的结果一定是另外<strong>乘以 x</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: float</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: float</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/x</span><br><span class=\"line\"></span><br><span class=\"line\">        left = n // <span class=\"number\">2</span></span><br><span class=\"line\">        re = self.myPow(x, left)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left * <span class=\"number\">2</span> == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> re * re</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> re * re * x</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Regular Expression Matching","date":"2018-11-26T14:13:49.000Z","_content":"\n## [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)\n\nGiven an input **string (s)** and a **pattern (p)**, implement regular expression matching with support for **.** and **\\***, **.** matches any single character, **\\*** matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\n（字符串正则表达式匹配）\n\n<!--more-->\n\nNote:\n**s** could be empty and contains only lowercase letters a-z.\n**p** could be empty and contains only lowercase letters a-z, and characters like . or \\*.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_10.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归算法\n正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。\n  - len(p) >= 2 and p[1] = \\*，则需要分类讨论：\n  \t - p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；\n  \t - p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；\n  - len(p) < 2，可以直接判断；\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return not s\n        \n        first_match = bool(s) and (p[0] in {s[0], '.'})\n        \n        if len(p) >=2 and p[1] == '*':\n            return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])\n```\n\n### 2. 动态规划\ndp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 `j >= 2 and dp[i][j-2]` 表示不扩展当前的 \\* ，即认为此次匹配了0个。 `i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}` 表示扩展当前的 \\* ，即认为此次匹配了1个。\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s = len(s)\n        len_p = len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n        \n        dp[0][0] = True\n        for i in range(len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = (i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}) or (j >= 2 and dp[i][j-2])\n                else:\n                    dp[i][j] = (i >= 1 and dp[i-1][j-1] and p[j-1] in {s[i-1], '.'})\n                    \n        return dp[len_s][len_p]\n```\n\n\n\n\n\n\n","source":"_posts/leetcode-RegularExpressionMatching.md","raw":"---\ntitle: LeetCode_Regular Expression Matching\ndate: 2018-11-26 22:13:49\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n  - back tracking\n---\n\n## [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)\n\nGiven an input **string (s)** and a **pattern (p)**, implement regular expression matching with support for **.** and **\\***, **.** matches any single character, **\\*** matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\n（字符串正则表达式匹配）\n\n<!--more-->\n\nNote:\n**s** could be empty and contains only lowercase letters a-z.\n**p** could be empty and contains only lowercase letters a-z, and characters like . or \\*.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_10.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归算法\n正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。\n  - len(p) >= 2 and p[1] = \\*，则需要分类讨论：\n  \t - p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；\n  \t - p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；\n  - len(p) < 2，可以直接判断；\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return not s\n        \n        first_match = bool(s) and (p[0] in {s[0], '.'})\n        \n        if len(p) >=2 and p[1] == '*':\n            return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])\n```\n\n### 2. 动态规划\ndp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 `j >= 2 and dp[i][j-2]` 表示不扩展当前的 \\* ，即认为此次匹配了0个。 `i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}` 表示扩展当前的 \\* ，即认为此次匹配了1个。\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s = len(s)\n        len_p = len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n        \n        dp[0][0] = True\n        for i in range(len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = (i >= 1 and j >= 2 and dp[i-1][j] and p[j-2] in {s[i-1], '.'}) or (j >= 2 and dp[i][j-2])\n                else:\n                    dp[i][j] = (i >= 1 and dp[i-1][j-1] and p[j-1] in {s[i-1], '.'})\n                    \n        return dp[len_s][len_p]\n```\n\n\n\n\n\n\n","slug":"leetcode-RegularExpressionMatching","published":1,"updated":"2019-01-09T09:51:10.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht844005zkvpxjsvp7rqc","content":"<h2 id=\"Regular-Expression-Matching\"><a href=\"#Regular-Expression-Matching\" class=\"headerlink\" title=\"Regular Expression Matching\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/\" target=\"_blank\" rel=\"noopener\">Regular Expression Matching</a></h2><p>Given an input <strong>string (s)</strong> and a <strong>pattern (p)</strong>, implement regular expression matching with support for <strong>.</strong> and <strong>*</strong>, <strong>.</strong> matches any single character, <strong>*</strong> matches zero or more of the preceding element. The matching should cover the entire input string (not partial).<br>（字符串正则表达式匹配）</p>\n<a id=\"more\"></a>\n<p>Note:<br><strong>s</strong> could be empty and contains only lowercase letters a-z.<br><strong>p</strong> could be empty and contains only lowercase letters a-z, and characters like . or *.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_10.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归算法\"><a href=\"#1-递归算法\" class=\"headerlink\" title=\"1. 递归算法\"></a>1. 递归算法</h3><p>正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。</p>\n<ul>\n<li>len(p) &gt;= 2 and p[1] = *，则需要分类讨论：<ul>\n<li>p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；</li>\n<li>p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；</li>\n</ul>\n</li>\n<li>len(p) &lt; 2，可以直接判断；</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        first_match = bool(s) <span class=\"keyword\">and</span> (p[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> &#123;s[<span class=\"number\">0</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> p[<span class=\"number\">1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.isMatch(s, p[<span class=\"number\">2</span>:])) <span class=\"keyword\">or</span> (first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 <code>j &gt;= 2 and dp[i][j-2]</code> 表示不扩展当前的 * ，即认为此次匹配了0个。 <code>i &gt;= 1 and j &gt;= 2 and dp[i-1][j] and p[j-2] in {s[i-1], &#39;.&#39;}</code> 表示扩展当前的 * ，即认为此次匹配了1个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        len_p = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len_p + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len_p + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> p[j<span class=\"number\">-2</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;) <span class=\"keyword\">or</span> (j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i][j<span class=\"number\">-2</span>])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> p[j<span class=\"number\">-1</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_s][len_p]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Regular-Expression-Matching\"><a href=\"#Regular-Expression-Matching\" class=\"headerlink\" title=\"Regular Expression Matching\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/\" target=\"_blank\" rel=\"noopener\">Regular Expression Matching</a></h2><p>Given an input <strong>string (s)</strong> and a <strong>pattern (p)</strong>, implement regular expression matching with support for <strong>.</strong> and <strong>*</strong>, <strong>.</strong> matches any single character, <strong>*</strong> matches zero or more of the preceding element. The matching should cover the entire input string (not partial).<br>（字符串正则表达式匹配）</p>","more":"<p>Note:<br><strong>s</strong> could be empty and contains only lowercase letters a-z.<br><strong>p</strong> could be empty and contains only lowercase letters a-z, and characters like . or *.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_10.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归算法\"><a href=\"#1-递归算法\" class=\"headerlink\" title=\"1. 递归算法\"></a>1. 递归算法</h3><p>正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。</p>\n<ul>\n<li>len(p) &gt;= 2 and p[1] = *，则需要分类讨论：<ul>\n<li>p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ；</li>\n<li>p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ；</li>\n</ul>\n</li>\n<li>len(p) &lt; 2，可以直接判断；</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        first_match = bool(s) <span class=\"keyword\">and</span> (p[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> &#123;s[<span class=\"number\">0</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> p[<span class=\"number\">1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.isMatch(s, p[<span class=\"number\">2</span>:])) <span class=\"keyword\">or</span> (first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_match <span class=\"keyword\">and</span> self.isMatch(s[<span class=\"number\">1</span>:], p[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 <code>j &gt;= 2 and dp[i][j-2]</code> 表示不扩展当前的 * ，即认为此次匹配了0个。 <code>i &gt;= 1 and j &gt;= 2 and dp[i-1][j] and p[j-2] in {s[i-1], &#39;.&#39;}</code> 表示扩展当前的 * ，即认为此次匹配了1个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        len_p = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len_p + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len_p + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> p[j<span class=\"number\">-2</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;) <span class=\"keyword\">or</span> (j &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> dp[i][j<span class=\"number\">-2</span>])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = (i &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> p[j<span class=\"number\">-1</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'.'</span>&#125;)</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_s][len_p]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Recover Binary Search Tree","date":"2019-02-27T14:22:04.000Z","_content":"\n## [Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\n\nTwo elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.\n（复原二叉排序树）\n\n<!--more-->\n\n**Follow Up:** A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_99.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 中序遍历 & 树->数组\n中序遍历二叉树，保存所有的节点到数组；然后遍历数组查找不符合要求的节点指针，空间复杂度为 O(n)。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        def treelist(root):\n            if not root:\n                return\n            treelist(root.left)\n            tree_list.append(root)\n            treelist(root.right)\n            \n        tree_list = []\n        treelist(root)\n        \n        first_node, second_node = None, None\n        for i in range(len(tree_list) - 1):\n            if tree_list[i+1].val <= tree_list[i].val:\n                if not first_node:\n                    first_node = tree_list[i]\n                    second_node = tree_list[i+1]\n                else:\n                    second_node = tree_list[i+1]          \n\n        first_node.val, second_node.val = second_node.val, first_node.val\n```\n\n### 2. 中序遍历 \n题中的 Follow Up 提及最好是空间复杂度为 O(1)，因此在中序遍历的过程中需要同时找出不符合要求的节点指针。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return\n            \n            dfs(root.left)\n            \n            if self.prev and self.prev.val >= root.val and self.first_node == None:\n                self.first_node = self.prev\n            if self.prev and self.prev.val >= root.val and self.first_node != None:\n                self.second_node = root\n            self.prev = root\n            \n            dfs(root.right)\n        \n        self.prev = None\n        self.first_node = None\n        self.second_node = None\n        \n        dfs(root)\n        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val\n```\n","source":"_posts/leetcode-RecoverBinarySearchTree.md","raw":"---\ntitle: LeetCode_Recover Binary Search Tree\ndate: 2019-02-27 22:22:04\ncategories: LeetCode\ntags: \n  - hard\n  - tree\n  - dfs\n---\n\n## [Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\n\nTwo elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.\n（复原二叉排序树）\n\n<!--more-->\n\n**Follow Up:** A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_99.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 中序遍历 & 树->数组\n中序遍历二叉树，保存所有的节点到数组；然后遍历数组查找不符合要求的节点指针，空间复杂度为 O(n)。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        def treelist(root):\n            if not root:\n                return\n            treelist(root.left)\n            tree_list.append(root)\n            treelist(root.right)\n            \n        tree_list = []\n        treelist(root)\n        \n        first_node, second_node = None, None\n        for i in range(len(tree_list) - 1):\n            if tree_list[i+1].val <= tree_list[i].val:\n                if not first_node:\n                    first_node = tree_list[i]\n                    second_node = tree_list[i+1]\n                else:\n                    second_node = tree_list[i+1]          \n\n        first_node.val, second_node.val = second_node.val, first_node.val\n```\n\n### 2. 中序遍历 \n题中的 Follow Up 提及最好是空间复杂度为 O(1)，因此在中序遍历的过程中需要同时找出不符合要求的节点指针。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return\n            \n            dfs(root.left)\n            \n            if self.prev and self.prev.val >= root.val and self.first_node == None:\n                self.first_node = self.prev\n            if self.prev and self.prev.val >= root.val and self.first_node != None:\n                self.second_node = root\n            self.prev = root\n            \n            dfs(root.right)\n        \n        self.prev = None\n        self.first_node = None\n        self.second_node = None\n        \n        dfs(root)\n        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val\n```\n","slug":"leetcode-RecoverBinarySearchTree","published":1,"updated":"2019-02-27T15:08:01.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8460062kvpxe7ll7r9h","content":"<h2 id=\"Recover-Binary-Search-Tree\"><a href=\"#Recover-Binary-Search-Tree\" class=\"headerlink\" title=\"Recover Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/recover-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Recover Binary Search Tree</a></h2><p>Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.<br>（复原二叉排序树）</p>\n<a id=\"more\"></a>\n<p><strong>Follow Up:</strong> A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_99.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-中序遍历-amp-树-gt-数组\"><a href=\"#1-中序遍历-amp-树-gt-数组\" class=\"headerlink\" title=\"1. 中序遍历 &amp; 树-&gt;数组\"></a>1. 中序遍历 &amp; 树-&gt;数组</h3><p>中序遍历二叉树，保存所有的节点到数组；然后遍历数组查找不符合要求的节点指针，空间复杂度为 O(n)。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recoverTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify root in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">treelist</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            treelist(root.left)</span><br><span class=\"line\">            tree_list.append(root)</span><br><span class=\"line\">            treelist(root.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">        tree_list = []</span><br><span class=\"line\">        treelist(root)</span><br><span class=\"line\">        </span><br><span class=\"line\">        first_node, second_node = <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(tree_list) - <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tree_list[i+<span class=\"number\">1</span>].val &lt;= tree_list[i].val:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> first_node:</span><br><span class=\"line\">                    first_node = tree_list[i]</span><br><span class=\"line\">                    second_node = tree_list[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    second_node = tree_list[i+<span class=\"number\">1</span>]          </span><br><span class=\"line\"></span><br><span class=\"line\">        first_node.val, second_node.val = second_node.val, first_node.val</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序遍历\"><a href=\"#2-中序遍历\" class=\"headerlink\" title=\"2. 中序遍历\"></a>2. 中序遍历</h3><p>题中的 Follow Up 提及最好是空间复杂度为 O(1)，因此在中序遍历的过程中需要同时找出不符合要求的节点指针。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recoverTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify root in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            dfs(root.left)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.prev <span class=\"keyword\">and</span> self.prev.val &gt;= root.val <span class=\"keyword\">and</span> self.first_node == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                self.first_node = self.prev</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.prev <span class=\"keyword\">and</span> self.prev.val &gt;= root.val <span class=\"keyword\">and</span> self.first_node != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                self.second_node = root</span><br><span class=\"line\">            self.prev = root</span><br><span class=\"line\">            </span><br><span class=\"line\">            dfs(root.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.prev = <span class=\"keyword\">None</span></span><br><span class=\"line\">        self.first_node = <span class=\"keyword\">None</span></span><br><span class=\"line\">        self.second_node = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dfs(root)</span><br><span class=\"line\">        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Recover-Binary-Search-Tree\"><a href=\"#Recover-Binary-Search-Tree\" class=\"headerlink\" title=\"Recover Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/recover-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Recover Binary Search Tree</a></h2><p>Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.<br>（复原二叉排序树）</p>","more":"<p><strong>Follow Up:</strong> A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_99.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-中序遍历-amp-树-gt-数组\"><a href=\"#1-中序遍历-amp-树-gt-数组\" class=\"headerlink\" title=\"1. 中序遍历 &amp; 树-&gt;数组\"></a>1. 中序遍历 &amp; 树-&gt;数组</h3><p>中序遍历二叉树，保存所有的节点到数组；然后遍历数组查找不符合要求的节点指针，空间复杂度为 O(n)。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recoverTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify root in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">treelist</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            treelist(root.left)</span><br><span class=\"line\">            tree_list.append(root)</span><br><span class=\"line\">            treelist(root.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">        tree_list = []</span><br><span class=\"line\">        treelist(root)</span><br><span class=\"line\">        </span><br><span class=\"line\">        first_node, second_node = <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(tree_list) - <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tree_list[i+<span class=\"number\">1</span>].val &lt;= tree_list[i].val:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> first_node:</span><br><span class=\"line\">                    first_node = tree_list[i]</span><br><span class=\"line\">                    second_node = tree_list[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    second_node = tree_list[i+<span class=\"number\">1</span>]          </span><br><span class=\"line\"></span><br><span class=\"line\">        first_node.val, second_node.val = second_node.val, first_node.val</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序遍历\"><a href=\"#2-中序遍历\" class=\"headerlink\" title=\"2. 中序遍历\"></a>2. 中序遍历</h3><p>题中的 Follow Up 提及最好是空间复杂度为 O(1)，因此在中序遍历的过程中需要同时找出不符合要求的节点指针。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recoverTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify root in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            dfs(root.left)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.prev <span class=\"keyword\">and</span> self.prev.val &gt;= root.val <span class=\"keyword\">and</span> self.first_node == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                self.first_node = self.prev</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.prev <span class=\"keyword\">and</span> self.prev.val &gt;= root.val <span class=\"keyword\">and</span> self.first_node != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                self.second_node = root</span><br><span class=\"line\">            self.prev = root</span><br><span class=\"line\">            </span><br><span class=\"line\">            dfs(root.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.prev = <span class=\"keyword\">None</span></span><br><span class=\"line\">        self.first_node = <span class=\"keyword\">None</span></span><br><span class=\"line\">        self.second_node = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dfs(root)</span><br><span class=\"line\">        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Duplicates from Sorted Array","date":"2018-12-18T06:48:12.000Z","_content":"\n## [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n（删除数组中重复的元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_26.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 重复元素个数\n这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        k = 0\n        now = None\n        for i, item in enumerate(nums):\n            if item != now:\n                now = item\n                if k != 0:\n                    nums[i-k] = item\n            else:\n                k += 1\n        \n        return len(nums)-k\n```","source":"_posts/leetcode-RemoveDuplicatesfromSortedArray.md","raw":"---\ntitle: LeetCode_Remove Duplicates from Sorted Array\ndate: 2018-12-18 14:48:12\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - two pointers\n---\n\n## [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n（删除数组中重复的元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_26.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 重复元素个数\n这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        k = 0\n        now = None\n        for i, item in enumerate(nums):\n            if item != now:\n                now = item\n                if k != 0:\n                    nums[i-k] = item\n            else:\n                k += 1\n        \n        return len(nums)-k\n```","slug":"leetcode-RemoveDuplicatesfromSortedArray","published":1,"updated":"2018-12-18T08:13:23.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8470066kvpx5sz0al2p","content":"<h2 id=\"Remove-Duplicates-from-Sorted-Array\"><a href=\"#Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>（删除数组中重复的元素，限制空间复杂度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_26.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-重复元素个数\"><a href=\"#1-重复元素个数\" class=\"headerlink\" title=\"1. 重复元素个数\"></a>1. 重复元素个数</h3><p>这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        now = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item != now:</span><br><span class=\"line\">                now = item</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    nums[i-k] = item</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Duplicates-from-Sorted-Array\"><a href=\"#Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>（删除数组中重复的元素，限制空间复杂度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_26.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-重复元素个数\"><a href=\"#1-重复元素个数\" class=\"headerlink\" title=\"1. 重复元素个数\"></a>1. 重复元素个数</h3><p>这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        now = <span class=\"keyword\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item != now:</span><br><span class=\"line\">                now = item</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    nums[i-k] = item</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Duplicates from Sorted Array II","date":"2019-02-23T07:20:08.000Z","_content":"\n## [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\n\nGiven a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n（删除数组中超过两次的元素，in-place, 限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_80.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 重复元素个数\n需要维护一个变量来记录在遍历过程中数字是重复次数k，以及元素需要前移的步数move_before。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:        \n        if len(nums) <= 2:\n            return\n        \n        k, move_before = 0, 0\n        now = None\n        \n        for i, num in enumerate(nums):\n            if num != now:\n                now = num\n                if k > 2:\n                    move_before += k-2\n                k = 1\n            else:\n                k += 1\n            nums[i-move_before] = num\n        \n        # last item\n        if k > 2:\n            move_before += k-2\n        nums[i-move_before] = num\n\n        return len(nums) - move_before\n```","source":"_posts/leetcode-RemoveDuplicatesfromSortedArrayII.md","raw":"---\ntitle: LeetCode_Remove Duplicates from Sorted Array II\ndate: 2019-02-23 15:20:08\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - two pointers\n---\n\n## [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\n\nGiven a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n（删除数组中超过两次的元素，in-place, 限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_80.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 重复元素个数\n需要维护一个变量来记录在遍历过程中数字是重复次数k，以及元素需要前移的步数move_before。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:        \n        if len(nums) <= 2:\n            return\n        \n        k, move_before = 0, 0\n        now = None\n        \n        for i, num in enumerate(nums):\n            if num != now:\n                now = num\n                if k > 2:\n                    move_before += k-2\n                k = 1\n            else:\n                k += 1\n            nums[i-move_before] = num\n        \n        # last item\n        if k > 2:\n            move_before += k-2\n        nums[i-move_before] = num\n\n        return len(nums) - move_before\n```","slug":"leetcode-RemoveDuplicatesfromSortedArrayII","published":1,"updated":"2019-02-23T07:45:20.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8490069kvpx0jfu7bae","content":"<h2 id=\"Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array II\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array II</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>（删除数组中超过两次的元素，in-place, 限制空间复杂度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_80.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-重复元素个数\"><a href=\"#1-重复元素个数\" class=\"headerlink\" title=\"1. 重复元素个数\"></a>1. 重复元素个数</h3><p>需要维护一个变量来记录在遍历过程中数字是重复次数k，以及元素需要前移的步数move_before。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span>        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        k, move_before = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        now = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num != now:</span><br><span class=\"line\">                now = num</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">                    move_before += k<span class=\"number\">-2</span></span><br><span class=\"line\">                k = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">            nums[i-move_before] = num</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># last item</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            move_before += k<span class=\"number\">-2</span></span><br><span class=\"line\">        nums[i-move_before] = num</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums) - move_before</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array II\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array II</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>（删除数组中超过两次的元素，in-place, 限制空间复杂度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_80.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-重复元素个数\"><a href=\"#1-重复元素个数\" class=\"headerlink\" title=\"1. 重复元素个数\"></a>1. 重复元素个数</h3><p>需要维护一个变量来记录在遍历过程中数字是重复次数k，以及元素需要前移的步数move_before。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span>        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        k, move_before = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        now = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num != now:</span><br><span class=\"line\">                now = num</span><br><span class=\"line\">                <span class=\"keyword\">if</span> k &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">                    move_before += k<span class=\"number\">-2</span></span><br><span class=\"line\">                k = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">            nums[i-move_before] = num</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># last item</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            move_before += k<span class=\"number\">-2</span></span><br><span class=\"line\">        nums[i-move_before] = num</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums) - move_before</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Duplicates from Sorted List","date":"2019-02-23T08:45:56.000Z","_content":"\n## [Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\n\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n（移除链表中的重复元素（所有元素只出现一次））\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_83.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 指针遍历\n\n在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n            \n        p_pre = new_head   \n        p_cur = new_head.next\n        while p_cur != None:\n            while p_cur.next and p_cur.val == p_cur.next.val:\n                p_cur = p_cur.next\n            p_pre.next = p_cur\n            p_pre = p_cur\n            p_cur = p_cur.next \n        \n        return new_head.next\n```","source":"_posts/leetcode-RemoveDuplicatesfromSortedList.md","raw":"---\ntitle: LeetCode_Remove Duplicates from Sorted List\ndate: 2019-02-23 16:45:56\ncategories: LeetCode\ntags: \n  - easy\n  - linked list\n---\n\n## [Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\n\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n（移除链表中的重复元素（所有元素只出现一次））\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_83.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 指针遍历\n\n在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n            \n        p_pre = new_head   \n        p_cur = new_head.next\n        while p_cur != None:\n            while p_cur.next and p_cur.val == p_cur.next.val:\n                p_cur = p_cur.next\n            p_pre.next = p_cur\n            p_pre = p_cur\n            p_cur = p_cur.next \n        \n        return new_head.next\n```","slug":"leetcode-RemoveDuplicatesfromSortedList","published":1,"updated":"2019-02-23T08:48:04.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84c006dkvpxuasc8ro6","content":"<h2 id=\"Remove-Duplicates-from-Sorted-List\"><a href=\"#Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List</a></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br>（移除链表中的重复元素（所有元素只出现一次））</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_83.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-指针遍历\"><a href=\"#1-指针遍历\" class=\"headerlink\" title=\"1. 指针遍历\"></a>1. 指针遍历</h3><p>在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">            </span><br><span class=\"line\">        p_pre = new_head   </span><br><span class=\"line\">        p_cur = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p_cur.next <span class=\"keyword\">and</span> p_cur.val == p_cur.next.val:</span><br><span class=\"line\">                p_cur = p_cur.next</span><br><span class=\"line\">            p_pre.next = p_cur</span><br><span class=\"line\">            p_pre = p_cur</span><br><span class=\"line\">            p_cur = p_cur.next </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Duplicates-from-Sorted-List\"><a href=\"#Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List</a></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br>（移除链表中的重复元素（所有元素只出现一次））</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_83.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-指针遍历\"><a href=\"#1-指针遍历\" class=\"headerlink\" title=\"1. 指针遍历\"></a>1. 指针遍历</h3><p>在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">            </span><br><span class=\"line\">        p_pre = new_head   </span><br><span class=\"line\">        p_cur = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p_cur.next <span class=\"keyword\">and</span> p_cur.val == p_cur.next.val:</span><br><span class=\"line\">                p_cur = p_cur.next</span><br><span class=\"line\">            p_pre.next = p_cur</span><br><span class=\"line\">            p_pre = p_cur</span><br><span class=\"line\">            p_cur = p_cur.next </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Element","date":"2018-12-18T08:12:33.000Z","_content":"\n## [Remove Element](https://leetcode.com/problems/remove-element/)\n\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n（删除数组中特定元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_27.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 特定元素个数\n这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        k = 0\n        for i, item in enumerate(nums):\n            if item == val:\n                k += 1\n            else:\n                nums[i-k] = item\n        \n        return len(nums)-k\n```","source":"_posts/leetcode-RemoveElement.md","raw":"---\ntitle: LeetCode_Remove Element\ndate: 2018-12-18 16:12:33\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - two pointers\n---\n\n## [Remove Element](https://leetcode.com/problems/remove-element/)\n\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n（删除数组中特定元素，限制空间复杂度）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_27.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 特定元素个数\n这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：\n\n```python\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        k = 0\n        for i, item in enumerate(nums):\n            if item == val:\n                k += 1\n            else:\n                nums[i-k] = item\n        \n        return len(nums)-k\n```","slug":"leetcode-RemoveElement","published":1,"updated":"2018-12-18T08:20:02.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84d006gkvpxbf61kw88","content":"<h2 id=\"Remove-Element\"><a href=\"#Remove-Element\" class=\"headerlink\" title=\"Remove Element\"></a><a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.<br>（删除数组中特定元素，限制空间复杂度）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_27.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-特定元素个数\"><a href=\"#1-特定元素个数\" class=\"headerlink\" title=\"1. 特定元素个数\"></a>1. 特定元素个数</h3><p>这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElement</span><span class=\"params\">(self, nums, val)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item == val:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[i-k] = item</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Element\"><a href=\"#Remove-Element\" class=\"headerlink\" title=\"Remove Element\"></a><a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.<br>（删除数组中特定元素，限制空间复杂度）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_27.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-特定元素个数\"><a href=\"#1-特定元素个数\" class=\"headerlink\" title=\"1. 特定元素个数\"></a>1. 特定元素个数</h3><p>这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElement</span><span class=\"params\">(self, nums, val)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, item <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item == val:</span><br><span class=\"line\">                k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[i-k] = item</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(nums)-k</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Remove Duplicates from Sorted List II","date":"2019-02-23T08:10:50.000Z","_content":"\n## [Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)\n\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\n（移除链表中的重复元素（删除出现2次以上的元素））\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_82.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 指针遍历\n在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_pre = new_head   \n        p_cur = new_head.next\n        while p_cur != None:\n            while p_cur.next and p_cur.val == p_cur.next.val:\n                p_cur = p_cur.next\n            if p_pre.next == p_cur:\n                p_pre = p_cur   \n            else:\n                p_pre.next = p_cur.next\n            p_cur = p_cur.next \n        \n        return new_head.next\n```\n\n\n","source":"_posts/leetcode-RemoveDuplicatesfromSortedListII.md","raw":"---\ntitle: LeetCode_Remove Duplicates from Sorted List II\ndate: 2019-02-23 16:10:50\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n---\n\n## [Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)\n\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\n（移除链表中的重复元素（删除出现2次以上的元素））\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_82.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 指针遍历\n在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_pre = new_head   \n        p_cur = new_head.next\n        while p_cur != None:\n            while p_cur.next and p_cur.val == p_cur.next.val:\n                p_cur = p_cur.next\n            if p_pre.next == p_cur:\n                p_pre = p_cur   \n            else:\n                p_pre.next = p_cur.next\n            p_cur = p_cur.next \n        \n        return new_head.next\n```\n\n\n","slug":"leetcode-RemoveDuplicatesfromSortedListII","published":1,"updated":"2019-02-23T08:39:24.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84e006kkvpxft6sv3kh","content":"<h2 id=\"Remove-Duplicates-from-Sorted-List-II\"><a href=\"#Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List II\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List II</a></h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.<br>（移除链表中的重复元素（删除出现2次以上的元素））</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_82.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-指针遍历\"><a href=\"#1-指针遍历\" class=\"headerlink\" title=\"1. 指针遍历\"></a>1. 指针遍历</h3><p>在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_pre = new_head   </span><br><span class=\"line\">        p_cur = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p_cur.next <span class=\"keyword\">and</span> p_cur.val == p_cur.next.val:</span><br><span class=\"line\">                p_cur = p_cur.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p_pre.next == p_cur:</span><br><span class=\"line\">                p_pre = p_cur   </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_pre.next = p_cur.next</span><br><span class=\"line\">            p_cur = p_cur.next </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Duplicates-from-Sorted-List-II\"><a href=\"#Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List II\"></a><a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List II</a></h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.<br>（移除链表中的重复元素（删除出现2次以上的元素））</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_82.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-指针遍历\"><a href=\"#1-指针遍历\" class=\"headerlink\" title=\"1. 指针遍历\"></a>1. 指针遍历</h3><p>在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_pre = new_head   </span><br><span class=\"line\">        p_cur = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_cur != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p_cur.next <span class=\"keyword\">and</span> p_cur.val == p_cur.next.val:</span><br><span class=\"line\">                p_cur = p_cur.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p_pre.next == p_cur:</span><br><span class=\"line\">                p_pre = p_cur   </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p_pre.next = p_cur.next</span><br><span class=\"line\">            p_cur = p_cur.next </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Restore IP Addresses","date":"2019-02-26T17:10:07.000Z","_content":"\n## [Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/)\n\nGiven a string containing only digits, restore it by returning all possible valid IP address combinations.\n（IP地址规则化）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_93.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n很自然的使用回溯法来解决这个问题。其中，需要考虑到的问题是：\n1. ip地址为4段，每段在[0,255]区间内；\n2. 每段可以是0，但是其长度大于1时，不能以0开头。\n具体实现过程如下：\n\n```python\nclass Solution:\n    def dfs(self, string, part, count):\n        re = \".\".join(part)\n        if count == 4 and not string and re not in self.results:\n            self.results.append(re)\n        \n        for j in range(len(string)):\n            # count = 4 才满足ip的4段地址，新划分的string[:j+1]不为空，且在0-255之间\n            if count <= 3 and string[:j+1] and int(string[:j+1]) <= 255 \\\n            # string[:j+1]长度为1 或 string[:j+1]长度大于1但不能以0开头\n            and (j+1 < 2 or (j+1 >= 2 and string[0] != '0')):\n                    self.dfs(string[j+1:], part + [string[:j+1]], count + 1)\n\n        # for i in range(1, 4):\n        #     if i <= len(string):\n        #         if i == 1:\n        #             self.dfs(string[i:], part + [string[:i]], count + 1)\n        #         if i==2 and string[0] != '0':\n        #             self.dfs(string[i:], part + [string[:i]], count + 1)\n        #         if i==3 and string[0] != '0' and int(string[:3]) <= 255 :\n        #             self.dfs(string[i:], part + [string[:i]], count + 1)\n    \n    def restoreIpAddresses(self, s: str) -> List[str]:\n        if not s or len(s) > 12:\n            return []\n        self.results = []\n        self.dfs(s, [], 0)\n        \n        return self.results\n```","source":"_posts/leetcode-RestoreIPAddresses.md","raw":"---\ntitle: LeetCode_Restore IP Addresses\ndate: 2019-02-27 01:10:07\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - back tracking\n---\n\n## [Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/)\n\nGiven a string containing only digits, restore it by returning all possible valid IP address combinations.\n（IP地址规则化）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_93.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n很自然的使用回溯法来解决这个问题。其中，需要考虑到的问题是：\n1. ip地址为4段，每段在[0,255]区间内；\n2. 每段可以是0，但是其长度大于1时，不能以0开头。\n具体实现过程如下：\n\n```python\nclass Solution:\n    def dfs(self, string, part, count):\n        re = \".\".join(part)\n        if count == 4 and not string and re not in self.results:\n            self.results.append(re)\n        \n        for j in range(len(string)):\n            # count = 4 才满足ip的4段地址，新划分的string[:j+1]不为空，且在0-255之间\n            if count <= 3 and string[:j+1] and int(string[:j+1]) <= 255 \\\n            # string[:j+1]长度为1 或 string[:j+1]长度大于1但不能以0开头\n            and (j+1 < 2 or (j+1 >= 2 and string[0] != '0')):\n                    self.dfs(string[j+1:], part + [string[:j+1]], count + 1)\n\n        # for i in range(1, 4):\n        #     if i <= len(string):\n        #         if i == 1:\n        #             self.dfs(string[i:], part + [string[:i]], count + 1)\n        #         if i==2 and string[0] != '0':\n        #             self.dfs(string[i:], part + [string[:i]], count + 1)\n        #         if i==3 and string[0] != '0' and int(string[:3]) <= 255 :\n        #             self.dfs(string[i:], part + [string[:i]], count + 1)\n    \n    def restoreIpAddresses(self, s: str) -> List[str]:\n        if not s or len(s) > 12:\n            return []\n        self.results = []\n        self.dfs(s, [], 0)\n        \n        return self.results\n```","slug":"leetcode-RestoreIPAddresses","published":1,"updated":"2019-02-27T04:06:49.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84g006nkvpxqqlh0qm5","content":"<h2 id=\"Restore-IP-Addresses\"><a href=\"#Restore-IP-Addresses\" class=\"headerlink\" title=\"Restore IP Addresses\"></a><a href=\"https://leetcode.com/problems/restore-ip-addresses/\" target=\"_blank\" rel=\"noopener\">Restore IP Addresses</a></h2><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.<br>（IP地址规则化）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_93.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><p>很自然的使用回溯法来解决这个问题。其中，需要考虑到的问题是：</p>\n<ol>\n<li>ip地址为4段，每段在[0,255]区间内；</li>\n<li>每段可以是0，但是其长度大于1时，不能以0开头。<br>具体实现过程如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, string, part, count)</span>:</span></span><br><span class=\"line\">        re = <span class=\"string\">\".\"</span>.join(part)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == <span class=\"number\">4</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> string <span class=\"keyword\">and</span> re <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.results:</span><br><span class=\"line\">            self.results.append(re)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(string)):</span><br><span class=\"line\">            <span class=\"comment\"># count = 4 才满足ip的4段地址，新划分的string[:j+1]不为空，且在0-255之间</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &lt;= <span class=\"number\">3</span> <span class=\"keyword\">and</span> string[:j+<span class=\"number\">1</span>] <span class=\"keyword\">and</span> int(string[:j+<span class=\"number\">1</span>]) &lt;= <span class=\"number\">255</span> \\</span><br><span class=\"line\">            <span class=\"comment\"># string[:j+1]长度为1 或 string[:j+1]长度大于1但不能以0开头</span></span><br><span class=\"line\">            <span class=\"keyword\">and</span> (j+<span class=\"number\">1</span> &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> (j+<span class=\"number\">1</span> &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> string[<span class=\"number\">0</span>] != <span class=\"string\">'0'</span>)):</span><br><span class=\"line\">                    self.dfs(string[j+<span class=\"number\">1</span>:], part + [string[:j+<span class=\"number\">1</span>]], count + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># for i in range(1, 4):</span></span><br><span class=\"line\">        <span class=\"comment\">#     if i &lt;= len(string):</span></span><br><span class=\"line\">        <span class=\"comment\">#         if i == 1:</span></span><br><span class=\"line\">        <span class=\"comment\">#             self.dfs(string[i:], part + [string[:i]], count + 1)</span></span><br><span class=\"line\">        <span class=\"comment\">#         if i==2 and string[0] != '0':</span></span><br><span class=\"line\">        <span class=\"comment\">#             self.dfs(string[i:], part + [string[:i]], count + 1)</span></span><br><span class=\"line\">        <span class=\"comment\">#         if i==3 and string[0] != '0' and int(string[:3]) &lt;= 255 :</span></span><br><span class=\"line\">        <span class=\"comment\">#             self.dfs(string[i:], part + [string[:i]], count + 1)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">restoreIpAddresses</span><span class=\"params\">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">or</span> len(s) &gt; <span class=\"number\">12</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        self.results = []</span><br><span class=\"line\">        self.dfs(s, [], <span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.results</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Restore-IP-Addresses\"><a href=\"#Restore-IP-Addresses\" class=\"headerlink\" title=\"Restore IP Addresses\"></a><a href=\"https://leetcode.com/problems/restore-ip-addresses/\" target=\"_blank\" rel=\"noopener\">Restore IP Addresses</a></h2><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.<br>（IP地址规则化）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_93.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><p>很自然的使用回溯法来解决这个问题。其中，需要考虑到的问题是：</p>\n<ol>\n<li>ip地址为4段，每段在[0,255]区间内；</li>\n<li>每段可以是0，但是其长度大于1时，不能以0开头。<br>具体实现过程如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, string, part, count)</span>:</span></span><br><span class=\"line\">        re = <span class=\"string\">\".\"</span>.join(part)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == <span class=\"number\">4</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> string <span class=\"keyword\">and</span> re <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.results:</span><br><span class=\"line\">            self.results.append(re)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(string)):</span><br><span class=\"line\">            <span class=\"comment\"># count = 4 才满足ip的4段地址，新划分的string[:j+1]不为空，且在0-255之间</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &lt;= <span class=\"number\">3</span> <span class=\"keyword\">and</span> string[:j+<span class=\"number\">1</span>] <span class=\"keyword\">and</span> int(string[:j+<span class=\"number\">1</span>]) &lt;= <span class=\"number\">255</span> \\</span><br><span class=\"line\">            <span class=\"comment\"># string[:j+1]长度为1 或 string[:j+1]长度大于1但不能以0开头</span></span><br><span class=\"line\">            <span class=\"keyword\">and</span> (j+<span class=\"number\">1</span> &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> (j+<span class=\"number\">1</span> &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> string[<span class=\"number\">0</span>] != <span class=\"string\">'0'</span>)):</span><br><span class=\"line\">                    self.dfs(string[j+<span class=\"number\">1</span>:], part + [string[:j+<span class=\"number\">1</span>]], count + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># for i in range(1, 4):</span></span><br><span class=\"line\">        <span class=\"comment\">#     if i &lt;= len(string):</span></span><br><span class=\"line\">        <span class=\"comment\">#         if i == 1:</span></span><br><span class=\"line\">        <span class=\"comment\">#             self.dfs(string[i:], part + [string[:i]], count + 1)</span></span><br><span class=\"line\">        <span class=\"comment\">#         if i==2 and string[0] != '0':</span></span><br><span class=\"line\">        <span class=\"comment\">#             self.dfs(string[i:], part + [string[:i]], count + 1)</span></span><br><span class=\"line\">        <span class=\"comment\">#         if i==3 and string[0] != '0' and int(string[:3]) &lt;= 255 :</span></span><br><span class=\"line\">        <span class=\"comment\">#             self.dfs(string[i:], part + [string[:i]], count + 1)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">restoreIpAddresses</span><span class=\"params\">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">or</span> len(s) &gt; <span class=\"number\">12</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        self.results = []</span><br><span class=\"line\">        self.dfs(s, [], <span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.results</span><br></pre></td></tr></table></figure>"},{"title":"leetcode_Remove Nth Node From End of List","date":"2018-12-06T06:41:28.000Z","_content":"\n## [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\nGiven a linked list, remove the n-th node from the end of list and return its head.\n（删除链表尾开始的第 N 个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_19.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 正向定位\n这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        p = head\n        length = 0\n        while p != None:\n            p = p.next\n            length += 1\n        \n        if n > length:\n            return head\n        elif n == length:\n            return head.next\n        else:\n            p = head\n            k = length - n - 1\n            while k != 0:\n                k -= 1\n                p = p.next\n            p.next = p.next.next\n            return head\n```","source":"_posts/leetcode-RemoveNthNodeFromEndofList.md","raw":"---\ntitle: leetcode_Remove Nth Node From End of List\ndate: 2018-12-06 14:41:28\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n  - two pointers\n---\n\n## [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\nGiven a linked list, remove the n-th node from the end of list and return its head.\n（删除链表尾开始的第 N 个）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_19.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 正向定位\n这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        p = head\n        length = 0\n        while p != None:\n            p = p.next\n            length += 1\n        \n        if n > length:\n            return head\n        elif n == length:\n            return head.next\n        else:\n            p = head\n            k = length - n - 1\n            while k != 0:\n                k -= 1\n                p = p.next\n            p.next = p.next.next\n            return head\n```","slug":"leetcode-RemoveNthNodeFromEndofList","published":1,"updated":"2018-12-06T07:43:15.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84h006rkvpx2h40aylm","content":"<h2 id=\"Remove-Nth-Node-From-End-of-List\"><a href=\"#Remove-Nth-Node-From-End-of-List\" class=\"headerlink\" title=\"Remove Nth Node From End of List\"></a><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">Remove Nth Node From End of List</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.<br>（删除链表尾开始的第 N 个）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_19.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-正向定位\"><a href=\"#1-正向定位\" class=\"headerlink\" title=\"1. 正向定位\"></a>1. 正向定位</h3><p>这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        length = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = head</span><br><span class=\"line\">            k = length - n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            p.next = p.next.next</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Remove-Nth-Node-From-End-of-List\"><a href=\"#Remove-Nth-Node-From-End-of-List\" class=\"headerlink\" title=\"Remove Nth Node From End of List\"></a><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">Remove Nth Node From End of List</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.<br>（删除链表尾开始的第 N 个）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_19.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-正向定位\"><a href=\"#1-正向定位\" class=\"headerlink\" title=\"1. 正向定位\"></a>1. 正向定位</h3><p>这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        length = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == length:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = head</span><br><span class=\"line\">            k = length - n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">                p = p.next</span><br><span class=\"line\">            p.next = p.next.next</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Reverse Integer","date":"2018-11-26T07:26:31.000Z","_content":"\n## [Reverse Integer](https://leetcode.com/problems/reverse-integer/)\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n（翻转一个有符号整形数值字符串）\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_7.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 字符串翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        string = str(x)\n        n = len(string)\n        \n        if string[0] == '-':\n            result = [string[n-i] for i in range(1, n)]\n            result = ['-'] + result\n        else:\n            result = [string[n-i-1] for i in range(n)]\n        \n        re = int(\"\".join(result))\n        \n        if re > pow(2, 31) - 1 or re < - pow(2, 31):\n            re = 0\n        return re\n```\n\n**注**：超过有符号整形的范围时需要返回0。另外`string[::-1]`也可以直接实现字符串的翻转。\n\n\n### 2. 整形翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        abso_x = abs(x)\n        result = 0\n        \n        while abso_x != 0 :\n            a = abso_x % 10\n            abso_x = abso_x // 10\n            result = result * 10  + a\n            \n        if x < 0:\n            result *= -1  \n            \n        if result > (pow(2, 31) - 1) or result < -pow(2, 31):\n            return 0\n        \n        return result\n```\n\n\n\n","source":"_posts/leetcode-ReverseInteger.md","raw":"---\ntitle: LeetCode_Reverse Integer\ndate: 2018-11-26 15:26:31\ncategories: LeetCode\ntags: \n  - easy\n  - math\n---\n\n## [Reverse Integer](https://leetcode.com/problems/reverse-integer/)\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n（翻转一个有符号整形数值字符串）\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_7.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 字符串翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        string = str(x)\n        n = len(string)\n        \n        if string[0] == '-':\n            result = [string[n-i] for i in range(1, n)]\n            result = ['-'] + result\n        else:\n            result = [string[n-i-1] for i in range(n)]\n        \n        re = int(\"\".join(result))\n        \n        if re > pow(2, 31) - 1 or re < - pow(2, 31):\n            re = 0\n        return re\n```\n\n**注**：超过有符号整形的范围时需要返回0。另外`string[::-1]`也可以直接实现字符串的翻转。\n\n\n### 2. 整形翻转 \n```python\nclass Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        abso_x = abs(x)\n        result = 0\n        \n        while abso_x != 0 :\n            a = abso_x % 10\n            abso_x = abso_x // 10\n            result = result * 10  + a\n            \n        if x < 0:\n            result *= -1  \n            \n        if result > (pow(2, 31) - 1) or result < -pow(2, 31):\n            return 0\n        \n        return result\n```\n\n\n\n","slug":"leetcode-ReverseInteger","published":1,"updated":"2018-11-27T06:25:10.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84i006ukvpxuoxxz6dy","content":"<h2 id=\"Reverse-Integer\"><a href=\"#Reverse-Integer\" class=\"headerlink\" title=\"Reverse Integer\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">Reverse Integer</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.<br>（翻转一个有符号整形数值字符串）</p>\n<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_7.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-字符串翻转\"><a href=\"#1-字符串翻转\" class=\"headerlink\" title=\"1. 字符串翻转\"></a>1. 字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str(x)</span><br><span class=\"line\">        n = len(string)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = [string[n-i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n)]</span><br><span class=\"line\">            result = [<span class=\"string\">'-'</span>] + result</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = [string[n-i<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = int(<span class=\"string\">\"\"</span>.join(result))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> re &gt; pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span> <span class=\"keyword\">or</span> re &lt; - pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：超过有符号整形的范围时需要返回0。另外<code>string[::-1]</code>也可以直接实现字符串的翻转。</p>\n<h3 id=\"2-整形翻转\"><a href=\"#2-整形翻转\" class=\"headerlink\" title=\"2. 整形翻转\"></a>2. 整形翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        abso_x = abs(x)</span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> abso_x != <span class=\"number\">0</span> :</span><br><span class=\"line\">            a = abso_x % <span class=\"number\">10</span></span><br><span class=\"line\">            abso_x = abso_x // <span class=\"number\">10</span></span><br><span class=\"line\">            result = result * <span class=\"number\">10</span>  + a</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            result *= <span class=\"number\">-1</span>  </span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; (pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"keyword\">or</span> result &lt; -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Reverse-Integer\"><a href=\"#Reverse-Integer\" class=\"headerlink\" title=\"Reverse Integer\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">Reverse Integer</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.<br>（翻转一个有符号整形数值字符串）</p>\n<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_7.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-字符串翻转\"><a href=\"#1-字符串翻转\" class=\"headerlink\" title=\"1. 字符串翻转\"></a>1. 字符串翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str(x)</span><br><span class=\"line\">        n = len(string)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = [string[n-i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n)]</span><br><span class=\"line\">            result = [<span class=\"string\">'-'</span>] + result</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = [string[n-i<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = int(<span class=\"string\">\"\"</span>.join(result))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> re &gt; pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span> <span class=\"keyword\">or</span> re &lt; - pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            re = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：超过有符号整形的范围时需要返回0。另外<code>string[::-1]</code>也可以直接实现字符串的翻转。</p>\n<h3 id=\"2-整形翻转\"><a href=\"#2-整形翻转\" class=\"headerlink\" title=\"2. 整形翻转\"></a>2. 整形翻转</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type x: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        abso_x = abs(x)</span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> abso_x != <span class=\"number\">0</span> :</span><br><span class=\"line\">            a = abso_x % <span class=\"number\">10</span></span><br><span class=\"line\">            abso_x = abso_x // <span class=\"number\">10</span></span><br><span class=\"line\">            result = result * <span class=\"number\">10</span>  + a</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            result *= <span class=\"number\">-1</span>  </span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; (pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span>) <span class=\"keyword\">or</span> result &lt; -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Reverse Linked List II","date":"2019-02-26T15:55:09.000Z","_content":"\n## [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\n\nReverse a linked list from position m to n. Do it in one-pass.\n（旋转link_list[m:n+1]）\n\n<!--more-->\n\n**Note:** 1 ≤ m ≤ n ≤ length of list.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_92.png\" width = \"500\" align=center/>\n</div>\n\n### 1. In-place\n具体实现方法如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_pre = new_head\n        p_cur = head\n        for i in range(1, m):\n            p_pre = p_pre.next\n            p_cur = p_cur.next\n     \n        for j in range(n-m):\n            p_head = p_pre.next\n            p_pre.next = p_cur.next\n            p_temp =  p_cur.next\n            p_cur.next = p_cur.next.next\n            p_temp.next = p_head\n           \n        return new_head.next\n```","source":"_posts/leetcode-ReverseLinkedListII.md","raw":"---\ntitle: LeetCode_Reverse Linked List II\ndate: 2019-02-26 23:55:09\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n---\n\n## [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\n\nReverse a linked list from position m to n. Do it in one-pass.\n（旋转link_list[m:n+1]）\n\n<!--more-->\n\n**Note:** 1 ≤ m ≤ n ≤ length of list.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_92.png\" width = \"500\" align=center/>\n</div>\n\n### 1. In-place\n具体实现方法如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_pre = new_head\n        p_cur = head\n        for i in range(1, m):\n            p_pre = p_pre.next\n            p_cur = p_cur.next\n     \n        for j in range(n-m):\n            p_head = p_pre.next\n            p_pre.next = p_cur.next\n            p_temp =  p_cur.next\n            p_cur.next = p_cur.next.next\n            p_temp.next = p_head\n           \n        return new_head.next\n```","slug":"leetcode-ReverseLinkedListII","published":1,"updated":"2019-02-26T17:05:54.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84j006xkvpxiuazt88r","content":"<h2 id=\"Reverse-Linked-List-II\"><a href=\"#Reverse-Linked-List-II\" class=\"headerlink\" title=\"Reverse Linked List II\"></a><a href=\"https://leetcode.com/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener\">Reverse Linked List II</a></h2><p>Reverse a linked list from position m to n. Do it in one-pass.<br>（旋转link_list[m:n+1]）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> 1 ≤ m ≤ n ≤ length of list.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_92.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-In-place\"><a href=\"#1-In-place\" class=\"headerlink\" title=\"1. In-place\"></a>1. In-place</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBetween</span><span class=\"params\">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_pre = new_head</span><br><span class=\"line\">        p_cur = head</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">            p_pre = p_pre.next</span><br><span class=\"line\">            p_cur = p_cur.next</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n-m):</span><br><span class=\"line\">            p_head = p_pre.next</span><br><span class=\"line\">            p_pre.next = p_cur.next</span><br><span class=\"line\">            p_temp =  p_cur.next</span><br><span class=\"line\">            p_cur.next = p_cur.next.next</span><br><span class=\"line\">            p_temp.next = p_head</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Reverse-Linked-List-II\"><a href=\"#Reverse-Linked-List-II\" class=\"headerlink\" title=\"Reverse Linked List II\"></a><a href=\"https://leetcode.com/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener\">Reverse Linked List II</a></h2><p>Reverse a linked list from position m to n. Do it in one-pass.<br>（旋转link_list[m:n+1]）</p>","more":"<p><strong>Note:</strong> 1 ≤ m ≤ n ≤ length of list.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_92.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-In-place\"><a href=\"#1-In-place\" class=\"headerlink\" title=\"1. In-place\"></a>1. In-place</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBetween</span><span class=\"params\">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_pre = new_head</span><br><span class=\"line\">        p_cur = head</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">            p_pre = p_pre.next</span><br><span class=\"line\">            p_cur = p_cur.next</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n-m):</span><br><span class=\"line\">            p_head = p_pre.next</span><br><span class=\"line\">            p_pre.next = p_cur.next</span><br><span class=\"line\">            p_temp =  p_cur.next</span><br><span class=\"line\">            p_cur.next = p_cur.next.next</span><br><span class=\"line\">            p_temp.next = p_head</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Reverse Nodes in k-Group","date":"2018-12-18T05:48:13.000Z","_content":"\n## [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n（链表分组倒排）\n\nNote:\n * Only constant extra memory is allowed.\n * You may not alter the values in the list's nodes, only nodes itself may be changed.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_25.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 链表指针问题（头节点）\n遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverse(self, p_prev_head, p_head, p_tail, k):\n        p = p_head\n        new_p = ListNode(0)\n        new_p.next = p_tail.next\n\n        while k != 0:\n            k -= 1\n            tmp = p.next\n            p.next = new_p.next\n            new_p.next = p\n            p = tmp\n        \n        p_prev_head.next = new_p.next\n         \n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if k == 1:\n            return head\n        \n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_prev_head = new_head\n        p_head = head\n        p_tail = head\n        \n        i = 1\n        while p_tail != None:\n            if i == k:\n                i = 1\n                self.reverse(p_prev_head, p_head, p_tail, k)\n                p_prev_head = p_head\n                p_head = p_prev_head.next\n                p_tail = p_head\n            else:\n                i += 1\n                p_tail = p_tail.next\n        \n        return new_head.next\n```\n\n","source":"_posts/leetcode-ReverseNodesink-Group.md","raw":"---\ntitle: LeetCode_Reverse Nodes in k-Group\ndate: 2018-12-18 13:48:13\ncategories: LeetCode\ntags: \n  - hard\n  - linked list\n---\n\n## [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n（链表分组倒排）\n\nNote:\n * Only constant extra memory is allowed.\n * You may not alter the values in the list's nodes, only nodes itself may be changed.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_25.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 链表指针问题（头节点）\n遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverse(self, p_prev_head, p_head, p_tail, k):\n        p = p_head\n        new_p = ListNode(0)\n        new_p.next = p_tail.next\n\n        while k != 0:\n            k -= 1\n            tmp = p.next\n            p.next = new_p.next\n            new_p.next = p\n            p = tmp\n        \n        p_prev_head.next = new_p.next\n         \n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if k == 1:\n            return head\n        \n        new_head = ListNode(0)\n        new_head.next = head\n        \n        p_prev_head = new_head\n        p_head = head\n        p_tail = head\n        \n        i = 1\n        while p_tail != None:\n            if i == k:\n                i = 1\n                self.reverse(p_prev_head, p_head, p_tail, k)\n                p_prev_head = p_head\n                p_head = p_prev_head.next\n                p_tail = p_head\n            else:\n                i += 1\n                p_tail = p_tail.next\n        \n        return new_head.next\n```\n\n","slug":"leetcode-ReverseNodesink-Group","published":1,"updated":"2018-12-18T06:48:30.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84k0071kvpxbendkcp4","content":"<h2 id=\"Reverse-Nodes-in-k-Group\"><a href=\"#Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"Reverse Nodes in k-Group\"></a><a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">Reverse Nodes in k-Group</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.<br>（链表分组倒排）</p>\n<p>Note:</p>\n<ul>\n<li>Only constant extra memory is allowed.</li>\n<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>\n</ul>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_25.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-链表指针问题（头节点）\"><a href=\"#1-链表指针问题（头节点）\" class=\"headerlink\" title=\"1. 链表指针问题（头节点）\"></a>1. 链表指针问题（头节点）</h3><p>遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, p_prev_head, p_head, p_tail, k)</span>:</span></span><br><span class=\"line\">        p = p_head</span><br><span class=\"line\">        new_p = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_p.next = p_tail.next</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">            tmp = p.next</span><br><span class=\"line\">            p.next = new_p.next</span><br><span class=\"line\">            new_p.next = p</span><br><span class=\"line\">            p = tmp</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head.next = new_p.next</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        </span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head = new_head</span><br><span class=\"line\">        p_head = head</span><br><span class=\"line\">        p_tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_tail != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == k:</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">                self.reverse(p_prev_head, p_head, p_tail, k)</span><br><span class=\"line\">                p_prev_head = p_head</span><br><span class=\"line\">                p_head = p_prev_head.next</span><br><span class=\"line\">                p_tail = p_head</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                p_tail = p_tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Reverse-Nodes-in-k-Group\"><a href=\"#Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"Reverse Nodes in k-Group\"></a><a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">Reverse Nodes in k-Group</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.<br>（链表分组倒排）</p>\n<p>Note:</p>\n<ul>\n<li>Only constant extra memory is allowed.</li>\n<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>\n</ul>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_25.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-链表指针问题（头节点）\"><a href=\"#1-链表指针问题（头节点）\" class=\"headerlink\" title=\"1. 链表指针问题（头节点）\"></a>1. 链表指针问题（头节点）</h3><p>遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, p_prev_head, p_head, p_tail, k)</span>:</span></span><br><span class=\"line\">        p = p_head</span><br><span class=\"line\">        new_p = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_p.next = p_tail.next</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> k != <span class=\"number\">0</span>:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">            tmp = p.next</span><br><span class=\"line\">            p.next = new_p.next</span><br><span class=\"line\">            new_p.next = p</span><br><span class=\"line\">            p = tmp</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head.next = new_p.next</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        </span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_prev_head = new_head</span><br><span class=\"line\">        p_head = head</span><br><span class=\"line\">        p_tail = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p_tail != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == k:</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">                self.reverse(p_prev_head, p_head, p_tail, k)</span><br><span class=\"line\">                p_prev_head = p_head</span><br><span class=\"line\">                p_head = p_prev_head.next</span><br><span class=\"line\">                p_tail = p_head</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                p_tail = p_tail.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Roman to Integer","date":"2018-11-29T02:29:41.000Z","_content":"\n# [Roman to Integer](https://leetcode.com/problems/roman-to-integer/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（罗马字符转整数）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_13.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历字符串_1\n遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M': 1000,\n            'CM': 900,\n            'D': 500,\n            'CD': 400,\n            'C': 100,\n            'XC': 90,\n            'L': 50,\n            'XL': 40,\n            'X': 10,\n            'IX': 9,\n            'V': 5,\n            'IV': 4,\n            'I': 1\n        }\n\n        result = 0\n        n = len(s)\n        i = 0\n        while i < n:\n            if i < n-1 and s[i:i+2] in base:\n                result += base[s[i:i+2]]\n                i += 2\n            elif s[i] in base:\n                result += base[s[i]]\n                i += 1\n            \n        return result \n```\n\n### 2. 遍历字符串_2\n直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M':1000,\n            'D':500,\n            'C':100,\n            'L':50,\n            'X':10,\n            'V':5,\n            'I':1\n        }\n        \n        temp = 0\n        result = 0\n        for ch in s:\n            if base[ch] > temp:\n                result -= 2 * temp\n            temp = base[ch]    \n            result += temp\n        \n        return result\n```\n        \n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-RomantoInteger.md","raw":"---\ntitle: LeetCode_Roman to Integer\ndate: 2018-11-29 10:29:41\ncategories: LeetCode\ntags: \n  - easy\n  - math\n  - string\n---\n\n# [Roman to Integer](https://leetcode.com/problems/roman-to-integer/)\n\nRoman numerals are represented by seven different symbols: **I, V, X, L, C, D and M** for **1, 5, 10, 50, 100, 500 and 1000**. \n（罗马字符转整数）\n\n<!--more-->\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number **four is written as IV**. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n  - **I** can be placed before **V** (5) and **X** (10) to make 4 and 9. \n  - **X** can be placed before **L** (50) and **C** (100) to make 40 and 90. \n  - **C** can be placed before **D** (500) and **M** (1000) to make 400 and 900.\n  - Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_13.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 遍历字符串_1\n遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M': 1000,\n            'CM': 900,\n            'D': 500,\n            'CD': 400,\n            'C': 100,\n            'XC': 90,\n            'L': 50,\n            'XL': 40,\n            'X': 10,\n            'IX': 9,\n            'V': 5,\n            'IV': 4,\n            'I': 1\n        }\n\n        result = 0\n        n = len(s)\n        i = 0\n        while i < n:\n            if i < n-1 and s[i:i+2] in base:\n                result += base[s[i:i+2]]\n                i += 2\n            elif s[i] in base:\n                result += base[s[i]]\n                i += 1\n            \n        return result \n```\n\n### 2. 遍历字符串_2\n直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n\n```python\nclass Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        base = {\n            'M':1000,\n            'D':500,\n            'C':100,\n            'L':50,\n            'X':10,\n            'V':5,\n            'I':1\n        }\n        \n        temp = 0\n        result = 0\n        for ch in s:\n            if base[ch] > temp:\n                result -= 2 * temp\n            temp = base[ch]    \n            result += temp\n        \n        return result\n```\n        \n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-RomantoInteger","published":1,"updated":"2018-11-29T02:36:18.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84l0074kvpxb8il6dsm","content":"<h1 id=\"Roman-to-Integer\"><a href=\"#Roman-to-Integer\" class=\"headerlink\" title=\"Roman to Integer\"></a><a href=\"https://leetcode.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">Roman to Integer</a></h1><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（罗马字符转整数）</p>\n<a id=\"more\"></a>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_13.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历字符串-1\"><a href=\"#1-遍历字符串-1\" class=\"headerlink\" title=\"1. 遍历字符串_1\"></a>1. 遍历字符串_1</h3><p>遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'CM'</span>: <span class=\"number\">900</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'CD'</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'XC'</span>: <span class=\"number\">90</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>: <span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'XL'</span>: <span class=\"number\">40</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'IX'</span>: <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'IV'</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> s[i:i+<span class=\"number\">2</span>] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i:i+<span class=\"number\">2</span>]]</span><br><span class=\"line\">                i += <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> s[i] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i]]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-遍历字符串-2\"><a href=\"#2-遍历字符串-2\" class=\"headerlink\" title=\"2. 遍历字符串_2\"></a>2. 遍历字符串_2</h3><p>直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>:<span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>:<span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>:<span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>:<span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>:<span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>:<span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>:<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        temp = <span class=\"number\">0</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> base[ch] &gt; temp:</span><br><span class=\"line\">                result -= <span class=\"number\">2</span> * temp</span><br><span class=\"line\">            temp = base[ch]    </span><br><span class=\"line\">            result += temp</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"Roman-to-Integer\"><a href=\"#Roman-to-Integer\" class=\"headerlink\" title=\"Roman to Integer\"></a><a href=\"https://leetcode.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">Roman to Integer</a></h1><p>Roman numerals are represented by seven different symbols: <strong>I, V, X, L, C, D and M</strong> for <strong>1, 5, 10, 50, 100, 500 and 1000</strong>.<br>（罗马字符转整数）</p>","more":"<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number <strong>four is written as IV</strong>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>\n<ul>\n<li><strong>I</strong> can be placed before <strong>V</strong> (5) and <strong>X</strong> (10) to make 4 and 9. </li>\n<li><strong>X</strong> can be placed before <strong>L</strong> (50) and <strong>C</strong> (100) to make 40 and 90. </li>\n<li><strong>C</strong> can be placed before <strong>D</strong> (500) and <strong>M</strong> (1000) to make 400 and 900.</li>\n<li>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</li>\n</ul>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_13.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-遍历字符串-1\"><a href=\"#1-遍历字符串-1\" class=\"headerlink\" title=\"1. 遍历字符串_1\"></a>1. 遍历字符串_1</h3><p>遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'CM'</span>: <span class=\"number\">900</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'CD'</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'XC'</span>: <span class=\"number\">90</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>: <span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'XL'</span>: <span class=\"number\">40</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'IX'</span>: <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'IV'</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> s[i:i+<span class=\"number\">2</span>] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i:i+<span class=\"number\">2</span>]]</span><br><span class=\"line\">                i += <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> s[i] <span class=\"keyword\">in</span> base:</span><br><span class=\"line\">                result += base[s[i]]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-遍历字符串-2\"><a href=\"#2-遍历字符串-2\" class=\"headerlink\" title=\"2. 遍历字符串_2\"></a>2. 遍历字符串_2</h3><p>直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        base = &#123;</span><br><span class=\"line\">            <span class=\"string\">'M'</span>:<span class=\"number\">1000</span>,</span><br><span class=\"line\">            <span class=\"string\">'D'</span>:<span class=\"number\">500</span>,</span><br><span class=\"line\">            <span class=\"string\">'C'</span>:<span class=\"number\">100</span>,</span><br><span class=\"line\">            <span class=\"string\">'L'</span>:<span class=\"number\">50</span>,</span><br><span class=\"line\">            <span class=\"string\">'X'</span>:<span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">'V'</span>:<span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"string\">'I'</span>:<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        temp = <span class=\"number\">0</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> base[ch] &gt; temp:</span><br><span class=\"line\">                result -= <span class=\"number\">2</span> * temp</span><br><span class=\"line\">            temp = base[ch]    </span><br><span class=\"line\">            result += temp</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Rotate Image","date":"2019-01-09T06:08:24.000Z","_content":"\n## [Rotate Image](https://leetcode.com/problems/rotate-image/)\n\nYou are given an nxn 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).\n(顺时针旋转矩阵90度)\n\n<!--more-->\n\n**Note:** You have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_48.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 矩阵转置 + 翻转行\n为了在不使用额外空间的情况下实现矩阵的顺时针旋转，可将其变化转变为矩阵的转置，然后对每一行进行翻转。具体实现过程如下：\n\n```python\nclass Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]\n            # matrix[i][:] = matrix[i][::-1]\n```","source":"_posts/leetcode-RotateImage.md","raw":"---\ntitle: LeetCode_Rotate Image\ndate: 2019-01-09 14:08:24\ncategories: LeetCode\ntags: \n  - medium\n  - back tracking\n---\n\n## [Rotate Image](https://leetcode.com/problems/rotate-image/)\n\nYou are given an nxn 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).\n(顺时针旋转矩阵90度)\n\n<!--more-->\n\n**Note:** You have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_48.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 矩阵转置 + 翻转行\n为了在不使用额外空间的情况下实现矩阵的顺时针旋转，可将其变化转变为矩阵的转置，然后对每一行进行翻转。具体实现过程如下：\n\n```python\nclass Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]\n            # matrix[i][:] = matrix[i][::-1]\n```","slug":"leetcode-RotateImage","published":1,"updated":"2019-01-14T10:53:29.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84r0078kvpx8h476r3e","content":"<h2 id=\"Rotate-Image\"><a href=\"#Rotate-Image\" class=\"headerlink\" title=\"Rotate Image\"></a><a href=\"https://leetcode.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">Rotate Image</a></h2><p>You are given an nxn 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).<br>(顺时针旋转矩阵90度)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_48.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-矩阵转置-翻转行\"><a href=\"#1-矩阵转置-翻转行\" class=\"headerlink\" title=\"1. 矩阵转置 + 翻转行\"></a>1. 矩阵转置 + 翻转行</h3><p>为了在不使用额外空间的情况下实现矩阵的顺时针旋转，可将其变化转变为矩阵的转置，然后对每一行进行翻转。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type matrix: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify matrix in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(matrix)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">                matrix[i][j], matrix[i][n<span class=\"number\">-1</span>-j] = matrix[i][n<span class=\"number\">-1</span>-j], matrix[i][j]</span><br><span class=\"line\">            <span class=\"comment\"># matrix[i][:] = matrix[i][::-1]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Rotate-Image\"><a href=\"#Rotate-Image\" class=\"headerlink\" title=\"Rotate Image\"></a><a href=\"https://leetcode.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">Rotate Image</a></h2><p>You are given an nxn 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).<br>(顺时针旋转矩阵90度)</p>","more":"<p><strong>Note:</strong> You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_48.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-矩阵转置-翻转行\"><a href=\"#1-矩阵转置-翻转行\" class=\"headerlink\" title=\"1. 矩阵转置 + 翻转行\"></a>1. 矩阵转置 + 翻转行</h3><p>为了在不使用额外空间的情况下实现矩阵的顺时针旋转，可将其变化转变为矩阵的转置，然后对每一行进行翻转。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type matrix: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify matrix in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(matrix)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">                matrix[i][j], matrix[i][n<span class=\"number\">-1</span>-j] = matrix[i][n<span class=\"number\">-1</span>-j], matrix[i][j]</span><br><span class=\"line\">            <span class=\"comment\"># matrix[i][:] = matrix[i][::-1]</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Rotate List","date":"2019-01-14T04:01:43.000Z","_content":"\n## [Rotate Image](https://leetcode.com/problems/rotate-image/)\n\nGiven a linked list, rotate the list to the right by k places, where k is non-negative.\n(k 次旋转链表)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_61.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 旋转 k 次\n首先获得链表的长度，然后每一次旋转链表都将链表的链尾排到链首，如此循环 k 次。具体实现方法如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not (head and head.next) :\n            return head\n    \n        cur = head\n        length = 1\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        k = k % length\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        while k > 0:\n            p_tail_before = new_head\n            p_tail = new_head.next\n            while p_tail.next != None:\n                p_tail_before = p_tail_before.next\n                p_tail = p_tail.next\n            p_tail.next = new_head.next\n            p_tail_before.next = None\n            new_head.next = p_tail\n            k -= 1\n        \n        return new_head.next\n```\n\n### 2. 旋转 1 次\n\n在获取链表的长度的同时，将其转换成一个循环链表，计算出当前应该由谁作为链首，这样将链表分为两部分再重新拼接。具体实现方法如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not (head and head.next) :\n            return head\n    \n        cur = head\n        length = 1\n        while cur.next:\n            cur = cur.next\n            length += 1\n        # Circular list\n        cur.next = head\n        \n        k = k % length\n        index = length - k\n        \n        p_head_before = cur\n        p_head = head\n        # get the new head of the list\n        for i in range(index):\n            p_head_before = p_head_before.next\n            p_head = p_head.next\n        \n        p_head_before.next = None\n        \n        return p_head\n```\n","source":"_posts/leetcode-RotateList.md","raw":"---\ntitle: LeetCode_Rotate List\ndate: 2019-01-14 12:01:43\ncategories: LeetCode\ntags: \n  - medium\n  - back tracking\n---\n\n## [Rotate Image](https://leetcode.com/problems/rotate-image/)\n\nGiven a linked list, rotate the list to the right by k places, where k is non-negative.\n(k 次旋转链表)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_61.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 旋转 k 次\n首先获得链表的长度，然后每一次旋转链表都将链表的链尾排到链首，如此循环 k 次。具体实现方法如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not (head and head.next) :\n            return head\n    \n        cur = head\n        length = 1\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        k = k % length\n        new_head = ListNode(0)\n        new_head.next = head\n        \n        while k > 0:\n            p_tail_before = new_head\n            p_tail = new_head.next\n            while p_tail.next != None:\n                p_tail_before = p_tail_before.next\n                p_tail = p_tail.next\n            p_tail.next = new_head.next\n            p_tail_before.next = None\n            new_head.next = p_tail\n            k -= 1\n        \n        return new_head.next\n```\n\n### 2. 旋转 1 次\n\n在获取链表的长度的同时，将其转换成一个循环链表，计算出当前应该由谁作为链首，这样将链表分为两部分再重新拼接。具体实现方法如下：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not (head and head.next) :\n            return head\n    \n        cur = head\n        length = 1\n        while cur.next:\n            cur = cur.next\n            length += 1\n        # Circular list\n        cur.next = head\n        \n        k = k % length\n        index = length - k\n        \n        p_head_before = cur\n        p_head = head\n        # get the new head of the list\n        for i in range(index):\n            p_head_before = p_head_before.next\n            p_head = p_head.next\n        \n        p_head_before.next = None\n        \n        return p_head\n```\n","slug":"leetcode-RotateList","published":1,"updated":"2019-01-14T10:37:57.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84s007bkvpxsp49kjah","content":"<h2 id=\"Rotate-Image\"><a href=\"#Rotate-Image\" class=\"headerlink\" title=\"Rotate Image\"></a><a href=\"https://leetcode.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">Rotate Image</a></h2><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br>(k 次旋转链表)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_61.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-旋转-k-次\"><a href=\"#1-旋转-k-次\" class=\"headerlink\" title=\"1. 旋转 k 次\"></a>1. 旋转 k 次</h3><p>首先获得链表的长度，然后每一次旋转链表都将链表的链尾排到链首，如此循环 k 次。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateRight</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (head <span class=\"keyword\">and</span> head.next) :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    </span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        length = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur.next:</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        k = k % length</span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> k &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            p_tail_before = new_head</span><br><span class=\"line\">            p_tail = new_head.next</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p_tail.next != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                p_tail_before = p_tail_before.next</span><br><span class=\"line\">                p_tail = p_tail.next</span><br><span class=\"line\">            p_tail.next = new_head.next</span><br><span class=\"line\">            p_tail_before.next = <span class=\"keyword\">None</span></span><br><span class=\"line\">            new_head.next = p_tail</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-旋转-1-次\"><a href=\"#2-旋转-1-次\" class=\"headerlink\" title=\"2. 旋转 1 次\"></a>2. 旋转 1 次</h3><p>在获取链表的长度的同时，将其转换成一个循环链表，计算出当前应该由谁作为链首，这样将链表分为两部分再重新拼接。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateRight</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (head <span class=\"keyword\">and</span> head.next) :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    </span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        length = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur.next:</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># Circular list</span></span><br><span class=\"line\">        cur.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        k = k % length</span><br><span class=\"line\">        index = length - k</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_head_before = cur</span><br><span class=\"line\">        p_head = head</span><br><span class=\"line\">        <span class=\"comment\"># get the new head of the list</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(index):</span><br><span class=\"line\">            p_head_before = p_head_before.next</span><br><span class=\"line\">            p_head = p_head.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_head_before.next = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> p_head</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Rotate-Image\"><a href=\"#Rotate-Image\" class=\"headerlink\" title=\"Rotate Image\"></a><a href=\"https://leetcode.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">Rotate Image</a></h2><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br>(k 次旋转链表)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_61.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-旋转-k-次\"><a href=\"#1-旋转-k-次\" class=\"headerlink\" title=\"1. 旋转 k 次\"></a>1. 旋转 k 次</h3><p>首先获得链表的长度，然后每一次旋转链表都将链表的链尾排到链首，如此循环 k 次。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateRight</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (head <span class=\"keyword\">and</span> head.next) :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    </span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        length = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur.next:</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        k = k % length</span><br><span class=\"line\">        new_head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        new_head.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> k &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            p_tail_before = new_head</span><br><span class=\"line\">            p_tail = new_head.next</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p_tail.next != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                p_tail_before = p_tail_before.next</span><br><span class=\"line\">                p_tail = p_tail.next</span><br><span class=\"line\">            p_tail.next = new_head.next</span><br><span class=\"line\">            p_tail_before.next = <span class=\"keyword\">None</span></span><br><span class=\"line\">            new_head.next = p_tail</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-旋转-1-次\"><a href=\"#2-旋转-1-次\" class=\"headerlink\" title=\"2. 旋转 1 次\"></a>2. 旋转 1 次</h3><p>在获取链表的长度的同时，将其转换成一个循环链表，计算出当前应该由谁作为链首，这样将链表分为两部分再重新拼接。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateRight</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (head <span class=\"keyword\">and</span> head.next) :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    </span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        length = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur.next:</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">            length += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># Circular list</span></span><br><span class=\"line\">        cur.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        k = k % length</span><br><span class=\"line\">        index = length - k</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_head_before = cur</span><br><span class=\"line\">        p_head = head</span><br><span class=\"line\">        <span class=\"comment\"># get the new head of the list</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(index):</span><br><span class=\"line\">            p_head_before = p_head_before.next</span><br><span class=\"line\">            p_head = p_head.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        p_head_before.next = <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> p_head</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Scramble String","date":"2019-02-25T10:53:46.000Z","_content":"\n## [Scramble String](https://leetcode.com/problems/scramble-string/)\n\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\n(判断一个字符串是否为另一个字符串“乱序”得到)\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_87.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n根据题意，加入 s1 和 s2 是 scramble 的话，那么必然存在一个在 s1 上的长度 l1，将 s1 分成 s11 和 s12 两段，同样有 s21 和 s22. 要么 s11 和 s21 是 scramble 的并且 s12 和 s22 是 scramble 的；要么 s11 和 s22 是 scramble 的并且 s12 和 s21 是 scramble 的。就拿题目中的例子 “rgeat” 和 “great” 来说，“rgeat” 可分成 “rg” 和 “eat” 两段，“great” 可分成 “gr” 和 “eat” 两段，“rg” 和 “gr” 是 scrambled 的，“eat” 和 “eat” 当然是 scrambled 。具体实现过程如下：\n\n```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        \n        sort_s1, sort_s2 = sorted(s1), sorted(s2)\n        if sort_s1 != sort_s2:\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:len(s1)-i])):\n                return True\n        return False\n```\n\n### 2. 动态规划\n\n这其实是一道**三维动态规划**的题目，我们提出维护量 res[i][j][n]，其中 i 是 s1 的起始字符，j 是 s2 的起始字符，而 n 是当前的字符串长度，res[i][j][length]表示的是以 i 和 j 分别为 s1 和 s2 起点的长度为 length 的字符串是不是互为scramble。\n其递推表达式为，对于所有的 1<=k<\\length:\n res[i][j][length] =  (res[i][j][k] && res[i+k][j+k][length-k] || res[i][j+length-k][k] && res[i+k][j][length-k])\n也就是对于所有 len-1 种劈法的结果求或运算。具体实现方法如下：\n\n```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        \n        n = len(s1)\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if s1[i] == s2[j]:\n                    dp[i][j][1] = True\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                for j in range(n-length+1):\n                    for k in range(1, length):\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or \\\n                        (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\n                            dp[i][j][length] = True\n                            \n        return dp[0][0][n]\n```\n","source":"_posts/leetcode-ScrambleString.md","raw":"---\ntitle: LeetCode_Scramble String\ndate: 2019-02-25 18:53:46\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - recursion\n  - dynamic programming\n---\n\n## [Scramble String](https://leetcode.com/problems/scramble-string/)\n\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\n(判断一个字符串是否为另一个字符串“乱序”得到)\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_87.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n\n根据题意，加入 s1 和 s2 是 scramble 的话，那么必然存在一个在 s1 上的长度 l1，将 s1 分成 s11 和 s12 两段，同样有 s21 和 s22. 要么 s11 和 s21 是 scramble 的并且 s12 和 s22 是 scramble 的；要么 s11 和 s22 是 scramble 的并且 s12 和 s21 是 scramble 的。就拿题目中的例子 “rgeat” 和 “great” 来说，“rgeat” 可分成 “rg” 和 “eat” 两段，“great” 可分成 “gr” 和 “eat” 两段，“rg” 和 “gr” 是 scrambled 的，“eat” 和 “eat” 当然是 scrambled 。具体实现过程如下：\n\n```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        \n        sort_s1, sort_s2 = sorted(s1), sorted(s2)\n        if sort_s1 != sort_s2:\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:len(s1)-i])):\n                return True\n        return False\n```\n\n### 2. 动态规划\n\n这其实是一道**三维动态规划**的题目，我们提出维护量 res[i][j][n]，其中 i 是 s1 的起始字符，j 是 s2 的起始字符，而 n 是当前的字符串长度，res[i][j][length]表示的是以 i 和 j 分别为 s1 和 s2 起点的长度为 length 的字符串是不是互为scramble。\n其递推表达式为，对于所有的 1<=k<\\length:\n res[i][j][length] =  (res[i][j][k] && res[i+k][j+k][length-k] || res[i][j+length-k][k] && res[i+k][j][length-k])\n也就是对于所有 len-1 种劈法的结果求或运算。具体实现方法如下：\n\n```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        \n        n = len(s1)\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if s1[i] == s2[j]:\n                    dp[i][j][1] = True\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                for j in range(n-length+1):\n                    for k in range(1, length):\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or \\\n                        (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\n                            dp[i][j][length] = True\n                            \n        return dp[0][0][n]\n```\n","slug":"leetcode-ScrambleString","published":1,"updated":"2019-02-25T13:38:07.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84w007fkvpxm46bxvur","content":"<h2 id=\"Scramble-String\"><a href=\"#Scramble-String\" class=\"headerlink\" title=\"Scramble String\"></a><a href=\"https://leetcode.com/problems/scramble-string/\" target=\"_blank\" rel=\"noopener\">Scramble String</a></h2><p>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.<br>(判断一个字符串是否为另一个字符串“乱序”得到)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_87.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>根据题意，加入 s1 和 s2 是 scramble 的话，那么必然存在一个在 s1 上的长度 l1，将 s1 分成 s11 和 s12 两段，同样有 s21 和 s22. 要么 s11 和 s21 是 scramble 的并且 s12 和 s22 是 scramble 的；要么 s11 和 s22 是 scramble 的并且 s12 和 s21 是 scramble 的。就拿题目中的例子 “rgeat” 和 “great” 来说，“rgeat” 可分成 “rg” 和 “eat” 两段，“great” 可分成 “gr” 和 “eat” 两段，“rg” 和 “gr” 是 scrambled 的，“eat” 和 “eat” 当然是 scrambled 。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isScramble</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s1) != len(s2):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1 == s2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sort_s1, sort_s2 = sorted(s1), sorted(s2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sort_s1 != sort_s2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s1)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (self.isScramble(s1[:i], s2[:i]) <span class=\"keyword\">and</span> self.isScramble(s1[i:], s2[i:])) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">            (self.isScramble(s1[:i], s2[-i:]) <span class=\"keyword\">and</span> self.isScramble(s1[i:], s2[:len(s1)-i])):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>这其实是一道<strong>三维动态规划</strong>的题目，我们提出维护量 res[i][j][n]，其中 i 是 s1 的起始字符，j 是 s2 的起始字符，而 n 是当前的字符串长度，res[i][j][length]表示的是以 i 和 j 分别为 s1 和 s2 起点的长度为 length 的字符串是不是互为scramble。<br>其递推表达式为，对于所有的 1&lt;=k&lt;\\length:<br> res[i][j][length] =  (res[i][j][k] &amp;&amp; res[i+k][j+k][length-k] || res[i][j+length-k][k] &amp;&amp; res[i+k][j][length-k])<br>也就是对于所有 len-1 种劈法的结果求或运算。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isScramble</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s1) != len(s2):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1 == s2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(s1)</span><br><span class=\"line\">        dp = [[[<span class=\"keyword\">False</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s1[i] == s2[j]:</span><br><span class=\"line\">                    dp[i][j][<span class=\"number\">1</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> length <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n-length+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n-length+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length):</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (dp[i][j][k] <span class=\"keyword\">and</span> dp[i+k][j+k][length-k]) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">                        (dp[i][j+length-k][k] <span class=\"keyword\">and</span> dp[i+k][j][length-k]):</span><br><span class=\"line\">                            dp[i][j][length] = <span class=\"keyword\">True</span></span><br><span class=\"line\">                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][n]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Scramble-String\"><a href=\"#Scramble-String\" class=\"headerlink\" title=\"Scramble String\"></a><a href=\"https://leetcode.com/problems/scramble-string/\" target=\"_blank\" rel=\"noopener\">Scramble String</a></h2><p>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.<br>(判断一个字符串是否为另一个字符串“乱序”得到)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_87.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>根据题意，加入 s1 和 s2 是 scramble 的话，那么必然存在一个在 s1 上的长度 l1，将 s1 分成 s11 和 s12 两段，同样有 s21 和 s22. 要么 s11 和 s21 是 scramble 的并且 s12 和 s22 是 scramble 的；要么 s11 和 s22 是 scramble 的并且 s12 和 s21 是 scramble 的。就拿题目中的例子 “rgeat” 和 “great” 来说，“rgeat” 可分成 “rg” 和 “eat” 两段，“great” 可分成 “gr” 和 “eat” 两段，“rg” 和 “gr” 是 scrambled 的，“eat” 和 “eat” 当然是 scrambled 。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isScramble</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s1) != len(s2):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1 == s2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sort_s1, sort_s2 = sorted(s1), sorted(s2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sort_s1 != sort_s2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s1)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (self.isScramble(s1[:i], s2[:i]) <span class=\"keyword\">and</span> self.isScramble(s1[i:], s2[i:])) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">            (self.isScramble(s1[:i], s2[-i:]) <span class=\"keyword\">and</span> self.isScramble(s1[i:], s2[:len(s1)-i])):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2. 动态规划\"></a>2. 动态规划</h3><p>这其实是一道<strong>三维动态规划</strong>的题目，我们提出维护量 res[i][j][n]，其中 i 是 s1 的起始字符，j 是 s2 的起始字符，而 n 是当前的字符串长度，res[i][j][length]表示的是以 i 和 j 分别为 s1 和 s2 起点的长度为 length 的字符串是不是互为scramble。<br>其递推表达式为，对于所有的 1&lt;=k&lt;\\length:<br> res[i][j][length] =  (res[i][j][k] &amp;&amp; res[i+k][j+k][length-k] || res[i][j+length-k][k] &amp;&amp; res[i+k][j][length-k])<br>也就是对于所有 len-1 种劈法的结果求或运算。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isScramble</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s1) != len(s2):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1 == s2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(s1)</span><br><span class=\"line\">        dp = [[[<span class=\"keyword\">False</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s1[i] == s2[j]:</span><br><span class=\"line\">                    dp[i][j][<span class=\"number\">1</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> length <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n-length+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n-length+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length):</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (dp[i][j][k] <span class=\"keyword\">and</span> dp[i+k][j+k][length-k]) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">                        (dp[i][j+length-k][k] <span class=\"keyword\">and</span> dp[i+k][j][length-k]):</span><br><span class=\"line\">                            dp[i][j][length] = <span class=\"keyword\">True</span></span><br><span class=\"line\">                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][n]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Same Tree","date":"2019-02-27T15:09:12.000Z","_content":"\n## [Same Tree](hhttps://leetcode.com/problems/same-tree/)\n\nGiven two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n（判断二叉树是否相同）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_100.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n判断节点值，左子树，右子树是否一致，具体实现方法如下：\n\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```","source":"_posts/leetcode-SameTree.md","raw":"---\ntitle: LeetCode_Same Tree\ndate: 2019-02-27 23:09:12\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n  - recursion\n---\n\n## [Same Tree](hhttps://leetcode.com/problems/same-tree/)\n\nGiven two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n（判断二叉树是否相同）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_100.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n判断节点值，左子树，右子树是否一致，具体实现方法如下：\n\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```","slug":"leetcode-SameTree","published":1,"updated":"2019-02-27T15:13:52.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84x007ikvpx9sfhegk4","content":"<h2 id=\"Same-Tree\"><a href=\"#Same-Tree\" class=\"headerlink\" title=\"Same Tree\"></a><a href=\"hhttps://leetcode.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">Same Tree</a></h2><p>Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.<br>（判断二叉树是否相同）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_100.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>判断节点值，左子树，右子树是否一致，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSameTree</span><span class=\"params\">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p.val != q.val:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.isSameTree(p.left, q.left) <span class=\"keyword\">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Same-Tree\"><a href=\"#Same-Tree\" class=\"headerlink\" title=\"Same Tree\"></a><a href=\"hhttps://leetcode.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">Same Tree</a></h2><p>Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.<br>（判断二叉树是否相同）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_100.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>判断节点值，左子树，右子树是否一致，具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSameTree</span><span class=\"params\">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p.val != q.val:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.isSameTree(p.left, q.left) <span class=\"keyword\">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Search A 2D Matrix","date":"2019-02-21T07:28:18.000Z","_content":"\n## [Search A 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)\n\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\n(查找数值是否在有序矩阵中)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_74.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 二分查找\n\n```python\nclass Solution:\n    def searchMatrix(self, matrix: 'List[List[int]]', target: 'int') -> 'bool':\n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n -1\n\n        while left <= right:\n            middle = (left + right) // 2\n\n            row, col = middle // n, middle % n\n\n            if target == matrix[row][col]:\n                return True\n            elif target > matrix[row][col]:\n                left = middle + 1\n            else:\n                right = middle - 1\n\n        return False\n```\n\n**Note:** 注意矩阵为空的情况哦~","source":"_posts/leetcode-SearchA2dMatrix.md","raw":"---\ntitle: LeetCode_Search A 2D Matrix\ndate: 2019-02-21 15:28:18\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - binary search\n---\n\n## [Search A 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)\n\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\n(查找数值是否在有序矩阵中)\n\n<!--more-->\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_74.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 二分查找\n\n```python\nclass Solution:\n    def searchMatrix(self, matrix: 'List[List[int]]', target: 'int') -> 'bool':\n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n -1\n\n        while left <= right:\n            middle = (left + right) // 2\n\n            row, col = middle // n, middle % n\n\n            if target == matrix[row][col]:\n                return True\n            elif target > matrix[row][col]:\n                left = middle + 1\n            else:\n                right = middle - 1\n\n        return False\n```\n\n**Note:** 注意矩阵为空的情况哦~","slug":"leetcode-SearchA2dMatrix","published":1,"updated":"2019-02-21T09:40:53.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht84y007mkvpx9o8o3s6k","content":"<h2 id=\"Search-A-2D-Matrix\"><a href=\"#Search-A-2D-Matrix\" class=\"headerlink\" title=\"Search A 2D Matrix\"></a><a href=\"https://leetcode.com/problems/search-a-2d-matrix/\" target=\"_blank\" rel=\"noopener\">Search A 2D Matrix</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.<br>(查找数值是否在有序矩阵中)</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_74.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[int]]'</span>, target: <span class=\"string\">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, m * n <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">            row, col = middle // n, middle % n</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == matrix[row][col]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; matrix[row][col]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> 注意矩阵为空的情况哦~</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Search-A-2D-Matrix\"><a href=\"#Search-A-2D-Matrix\" class=\"headerlink\" title=\"Search A 2D Matrix\"></a><a href=\"https://leetcode.com/problems/search-a-2d-matrix/\" target=\"_blank\" rel=\"noopener\">Search A 2D Matrix</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.<br>(查找数值是否在有序矩阵中)</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_74.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[int]]'</span>, target: <span class=\"string\">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, m * n <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">            row, col = middle // n, middle % n</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == matrix[row][col]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &gt; matrix[row][col]:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> 注意矩阵为空的情况哦~</p>"},{"title":"LeetCode_Search Insert Position","date":"2018-12-21T06:26:10.000Z","_content":"\n## [Search Insert Position](https://leetcode.com/problems/search-insert-position/)\n\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\n（在有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_35.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        left, right = 0, n-1\n    \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            elif target < nums[middle]:\n                right = middle - 1\n            else:\n                left = middle + 1\n                \n        return left\n```\n\n","source":"_posts/leetcode-SearchInsertPosition.md","raw":"---\ntitle: LeetCode_Search Insert Position\ndate: 2018-12-21 14:26:10\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - binary search\n---\n\n## [Search Insert Position](https://leetcode.com/problems/search-insert-position/)\n\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\n（在有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_35.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        left, right = 0, n-1\n    \n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            elif target < nums[middle]:\n                right = middle - 1\n            else:\n                left = middle + 1\n                \n        return left\n```\n\n","slug":"leetcode-SearchInsertPosition","published":1,"updated":"2018-12-21T06:37:52.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht856007pkvpx7lk75qxw","content":"<h2 id=\"Search-Insert-Position\"><a href=\"#Search-Insert-Position\" class=\"headerlink\" title=\"Search Insert Position\"></a><a href=\"https://leetcode.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">Search Insert Position</a></h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.<br>（在有序数组中检索）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_35.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &lt; nums[middle]:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Search-Insert-Position\"><a href=\"#Search-Insert-Position\" class=\"headerlink\" title=\"Search Insert Position\"></a><a href=\"https://leetcode.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">Search Insert Position</a></h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.<br>（在有序数组中检索）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_35.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> target &lt; nums[middle]:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Search in Rotated Sorted Array","date":"2018-12-21T05:07:49.000Z","_content":"\n## [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\n\nSuppose an **array sorted in ascending order is rotated** at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of **O(log n)**.\n（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_33.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：\n\n```python\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            \n            if nums[left] <= nums[middle]:\n                if target < nums[middle] and target >= nums[left]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n    \n        return -1\n```","source":"_posts/leetcode-SearchinRotatedSortedArray.md","raw":"---\ntitle: LeetCode_Search in Rotated Sorted Array\ndate: 2018-12-21 13:07:49\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - binary search\n---\n\n## [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\n\nSuppose an **array sorted in ascending order is rotated** at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of **O(log n)**.\n（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_33.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：\n\n```python\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return middle\n            \n            if nums[left] <= nums[middle]:\n                if target < nums[middle] and target >= nums[left]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n    \n        return -1\n```","slug":"leetcode-SearchinRotatedSortedArray","published":1,"updated":"2018-12-21T05:57:37.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht859007tkvpxq292tx4b","content":"<h2 id=\"Search-in-Rotated-Sorted-Array\"><a href=\"#Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"Search in Rotated Sorted Array\"></a><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array</a></h2><p>Suppose an <strong>array sorted in ascending order is rotated</strong> at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of <strong>O(log n)</strong>.<br>（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_33.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &lt; nums[middle] <span class=\"keyword\">and</span> target &gt;= nums[left]:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &gt; nums[middle] <span class=\"keyword\">and</span> target &lt;= nums[right]:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Search-in-Rotated-Sorted-Array\"><a href=\"#Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"Search in Rotated Sorted Array\"></a><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array</a></h2><p>Suppose an <strong>array sorted in ascending order is rotated</strong> at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of <strong>O(log n)</strong>.<br>（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_33.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &lt; nums[middle] <span class=\"keyword\">and</span> target &gt;= nums[left]:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &gt; nums[middle] <span class=\"keyword\">and</span> target &lt;= nums[right]:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Search in Rotated Sorted Array II","date":"2019-02-23T07:46:52.000Z","_content":"\n## [Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\n\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false.\n（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索(数组中含有重复元素)）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_81.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。其中由于可能含有重复元素，需要跳过。具体实现如下：\n\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return False\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return True\n            \n            while left < middle and nums[left] == nums[middle]:\n                left += 1\n            while right > middle and nums[right] == nums[middle]:\n                right -= 1\n            \n            if nums[left] <= nums[middle]:\n                if target < nums[middle] and target >= nums[left]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        \n        return False\n```","source":"_posts/leetcode-SearchinRotatedSortedArrayII.md","raw":"---\ntitle: LeetCode_Search in Rotated Sorted Array II\ndate: 2019-02-23 15:46:52\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - binary search\n---\n\n## [Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\n\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false.\n（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索(数组中含有重复元素)）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_81.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。其中由于可能含有重复元素，需要跳过。具体实现如下：\n\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return False\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            middle = (left + right) // 2\n            \n            if target == nums[middle]:\n                return True\n            \n            while left < middle and nums[left] == nums[middle]:\n                left += 1\n            while right > middle and nums[right] == nums[middle]:\n                right -= 1\n            \n            if nums[left] <= nums[middle]:\n                if target < nums[middle] and target >= nums[left]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        \n        return False\n```","slug":"leetcode-SearchinRotatedSortedArrayII","published":1,"updated":"2019-02-23T08:05:03.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85b007wkvpxepp3cwst","content":"<h2 id=\"Search-in-Rotated-Sorted-Array-II\"><a href=\"#Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"Search in Rotated Sorted Array II\"></a><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array II</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false.<br>（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索(数组中含有重复元素)）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_81.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。其中由于可能含有重复元素，需要跳过。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; middle <span class=\"keyword\">and</span> nums[left] == nums[middle]:</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> right &gt; middle <span class=\"keyword\">and</span> nums[right] == nums[middle]:</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &lt; nums[middle] <span class=\"keyword\">and</span> target &gt;= nums[left]:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &gt; nums[middle] <span class=\"keyword\">and</span> target &lt;= nums[right]:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Search-in-Rotated-Sorted-Array-II\"><a href=\"#Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"Search in Rotated Sorted Array II\"></a><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array II</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false.<br>（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索(数组中含有重复元素)）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_81.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><p>定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。其中由于可能含有重复元素，需要跳过。具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> target == nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; middle <span class=\"keyword\">and</span> nums[left] == nums[middle]:</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> right &gt; middle <span class=\"keyword\">and</span> nums[right] == nums[middle]:</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[middle]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &lt; nums[middle] <span class=\"keyword\">and</span> target &gt;= nums[left]:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> target &gt; nums[middle] <span class=\"keyword\">and</span> target &lt;= nums[right]:</span><br><span class=\"line\">                    left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = middle - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Simplify Path","date":"2019-02-16T12:31:52.000Z","_content":"\n## [Simplify Path](https://leetcode.com/problems/simplify-path/)\n\nGiven an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period **.** refers to the current directory. Furthermore, a double period **..** moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) **must not** end with a trailing /. Also, the canonical path must be the **shortest** string representing the absolute path.\n（简化文件路径）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_71.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 堆栈\n\n```python\nclass Solution:\n    def simplifyPath(self, path: 'str') -> 'str':\n        dirs = [x for x in path.split('/') if x and x != '.']\n\n        results = []\n\n        for dir in dirs:\n            if dir == '..':\n                results.pop() if results else None\n            else:\n                results.append(dir)\n\n        return '/' + '/'.join(results)\n```\n","source":"_posts/leetcode-SimplifyPath.md","raw":"---\ntitle: LeetCode_Simplify Path\ndate: 2019-02-16 20:31:52\ncategories: LeetCode\ntags: \n  - medium\n  - string\n  - stack\n---\n\n## [Simplify Path](https://leetcode.com/problems/simplify-path/)\n\nGiven an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period **.** refers to the current directory. Furthermore, a double period **..** moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) **must not** end with a trailing /. Also, the canonical path must be the **shortest** string representing the absolute path.\n（简化文件路径）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_71.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 堆栈\n\n```python\nclass Solution:\n    def simplifyPath(self, path: 'str') -> 'str':\n        dirs = [x for x in path.split('/') if x and x != '.']\n\n        results = []\n\n        for dir in dirs:\n            if dir == '..':\n                results.pop() if results else None\n            else:\n                results.append(dir)\n\n        return '/' + '/'.join(results)\n```\n","slug":"leetcode-SimplifyPath","published":1,"updated":"2019-02-16T12:58:47.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85d0080kvpxkmslmxld","content":"<h2 id=\"Simplify-Path\"><a href=\"#Simplify-Path\" class=\"headerlink\" title=\"Simplify Path\"></a><a href=\"https://leetcode.com/problems/simplify-path/\" target=\"_blank\" rel=\"noopener\">Simplify Path</a></h2><p>Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period <strong>.</strong> refers to the current directory. Furthermore, a double period <strong>..</strong> moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing /. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.<br>（简化文件路径）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_71.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-堆栈\"><a href=\"#1-堆栈\" class=\"headerlink\" title=\"1. 堆栈\"></a>1. 堆栈</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(self, path: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">        dirs = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> path.split(<span class=\"string\">'/'</span>) <span class=\"keyword\">if</span> x <span class=\"keyword\">and</span> x != <span class=\"string\">'.'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        results = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> dir <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dir == <span class=\"string\">'..'</span>:</span><br><span class=\"line\">                results.pop() <span class=\"keyword\">if</span> results <span class=\"keyword\">else</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                results.append(dir)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'/'</span> + <span class=\"string\">'/'</span>.join(results)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Simplify-Path\"><a href=\"#Simplify-Path\" class=\"headerlink\" title=\"Simplify Path\"></a><a href=\"https://leetcode.com/problems/simplify-path/\" target=\"_blank\" rel=\"noopener\">Simplify Path</a></h2><p>Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period <strong>.</strong> refers to the current directory. Furthermore, a double period <strong>..</strong> moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing /. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.<br>（简化文件路径）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_71.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-堆栈\"><a href=\"#1-堆栈\" class=\"headerlink\" title=\"1. 堆栈\"></a>1. 堆栈</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(self, path: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">        dirs = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> path.split(<span class=\"string\">'/'</span>) <span class=\"keyword\">if</span> x <span class=\"keyword\">and</span> x != <span class=\"string\">'.'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        results = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> dir <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dir == <span class=\"string\">'..'</span>:</span><br><span class=\"line\">                results.pop() <span class=\"keyword\">if</span> results <span class=\"keyword\">else</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                results.append(dir)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'/'</span> + <span class=\"string\">'/'</span>.join(results)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Sort Colors","date":"2019-02-21T09:42:37.000Z","_content":"\n## [Sort Colors](https://leetcode.com/problems/sort-colors/)\n\nGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n(in-place 分组排序)\n\n<!--more-->\n\n**Note:** You are not suppose to use the library's sort function for this problem.\n\n**Follow up:** A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_75.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 首尾指针\n\n在一开始，两个指针是指向数组的头和尾的，可以看做是排好序的“0”序列的后一个数和“2”序列的前一个数。遍历数组当遇到“0”时，将其和“0”序列后面一个数交换，然后“0”序列的指针向后移。当遇到“2”时，将其和“2”序列前面一个数交换，然后将“2”序列的指针向前移。遇到“1”时，不做处理。这样，当我们遍历到2序列开头时，实际上我们已经排好序了，因为所有“0”都被交换到了前面，所有“2”都被交换到了后面。 (这里需要注意的是当遇到“2”时并交换数值之后，我们还不能确定换来的就是“0”“1”“2”，需要重新检测一次。) 其时间复杂度为O(N)，空间复杂度为O(1)。\n\n```python\nclass Solution:\n    def sortColors(self, nums: 'List[int]') -> 'None':\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        left, right, i = 0, n - 1, 0\n\n        while i <= right:\n            if nums[i] == 0:\n                nums[i], nums[left] = nums[left], nums[i]\n                left += 1\n                i += 1 \n            elif nums[i] == 2:\n                nums[i], nums[right] = nums[right], nums[i]\n                right -= 1\n            else:\n                i += 1\n```\n\n### 2. 遍历两次\n根据题中的Follow Up, 我们可以在第一次遍历过程中分别记录“0”“1”“2”的个数，在第二次遍历过程中一次替换即可。\n\n","source":"_posts/leetcode-SortColors.md","raw":"---\ntitle: LeetCode_Sort Colors\ndate: 2019-02-21 17:42:37\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - two pointers\n  - sort\n---\n\n## [Sort Colors](https://leetcode.com/problems/sort-colors/)\n\nGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n(in-place 分组排序)\n\n<!--more-->\n\n**Note:** You are not suppose to use the library's sort function for this problem.\n\n**Follow up:** A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_75.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 首尾指针\n\n在一开始，两个指针是指向数组的头和尾的，可以看做是排好序的“0”序列的后一个数和“2”序列的前一个数。遍历数组当遇到“0”时，将其和“0”序列后面一个数交换，然后“0”序列的指针向后移。当遇到“2”时，将其和“2”序列前面一个数交换，然后将“2”序列的指针向前移。遇到“1”时，不做处理。这样，当我们遍历到2序列开头时，实际上我们已经排好序了，因为所有“0”都被交换到了前面，所有“2”都被交换到了后面。 (这里需要注意的是当遇到“2”时并交换数值之后，我们还不能确定换来的就是“0”“1”“2”，需要重新检测一次。) 其时间复杂度为O(N)，空间复杂度为O(1)。\n\n```python\nclass Solution:\n    def sortColors(self, nums: 'List[int]') -> 'None':\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        left, right, i = 0, n - 1, 0\n\n        while i <= right:\n            if nums[i] == 0:\n                nums[i], nums[left] = nums[left], nums[i]\n                left += 1\n                i += 1 \n            elif nums[i] == 2:\n                nums[i], nums[right] = nums[right], nums[i]\n                right -= 1\n            else:\n                i += 1\n```\n\n### 2. 遍历两次\n根据题中的Follow Up, 我们可以在第一次遍历过程中分别记录“0”“1”“2”的个数，在第二次遍历过程中一次替换即可。\n\n","slug":"leetcode-SortColors","published":1,"updated":"2019-02-21T15:04:58.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85e0083kvpxrgzvk3yb","content":"<h2 id=\"Sort-Colors\"><a href=\"#Sort-Colors\" class=\"headerlink\" title=\"Sort Colors\"></a><a href=\"https://leetcode.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">Sort Colors</a></h2><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.<br>(in-place 分组排序)</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>\n<p><strong>Follow up:</strong> A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space?</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_75.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-首尾指针\"><a href=\"#1-首尾指针\" class=\"headerlink\" title=\"1. 首尾指针\"></a>1. 首尾指针</h3><p>在一开始，两个指针是指向数组的头和尾的，可以看做是排好序的“0”序列的后一个数和“2”序列的前一个数。遍历数组当遇到“0”时，将其和“0”序列后面一个数交换，然后“0”序列的指针向后移。当遇到“2”时，将其和“2”序列前面一个数交换，然后将“2”序列的指针向前移。遇到“1”时，不做处理。这样，当我们遍历到2序列开头时，实际上我们已经排好序了，因为所有“0”都被交换到了前面，所有“2”都被交换到了后面。 (这里需要注意的是当遇到“2”时并交换数值之后，我们还不能确定换来的就是“0”“1”“2”，需要重新检测一次。) 其时间复杂度为O(N)，空间复杂度为O(1)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        left, right, i = <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums[i], nums[left] = nums[left], nums[i]</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[i] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                nums[i], nums[right] = nums[right], nums[i]</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-遍历两次\"><a href=\"#2-遍历两次\" class=\"headerlink\" title=\"2. 遍历两次\"></a>2. 遍历两次</h3><p>根据题中的Follow Up, 我们可以在第一次遍历过程中分别记录“0”“1”“2”的个数，在第二次遍历过程中一次替换即可。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Sort-Colors\"><a href=\"#Sort-Colors\" class=\"headerlink\" title=\"Sort Colors\"></a><a href=\"https://leetcode.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">Sort Colors</a></h2><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.<br>(in-place 分组排序)</p>","more":"<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>\n<p><strong>Follow up:</strong> A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space?</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_75.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-首尾指针\"><a href=\"#1-首尾指针\" class=\"headerlink\" title=\"1. 首尾指针\"></a>1. 首尾指针</h3><p>在一开始，两个指针是指向数组的头和尾的，可以看做是排好序的“0”序列的后一个数和“2”序列的前一个数。遍历数组当遇到“0”时，将其和“0”序列后面一个数交换，然后“0”序列的指针向后移。当遇到“2”时，将其和“2”序列前面一个数交换，然后将“2”序列的指针向前移。遇到“1”时，不做处理。这样，当我们遍历到2序列开头时，实际上我们已经排好序了，因为所有“0”都被交换到了前面，所有“2”都被交换到了后面。 (这里需要注意的是当遇到“2”时并交换数值之后，我们还不能确定换来的就是“0”“1”“2”，需要重新检测一次。) 其时间复杂度为O(N)，空间复杂度为O(1)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        left, right, i = <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums[i], nums[left] = nums[left], nums[i]</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[i] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                nums[i], nums[right] = nums[right], nums[i]</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-遍历两次\"><a href=\"#2-遍历两次\" class=\"headerlink\" title=\"2. 遍历两次\"></a>2. 遍历两次</h3><p>根据题中的Follow Up, 我们可以在第一次遍历过程中分别记录“0”“1”“2”的个数，在第二次遍历过程中一次替换即可。</p>"},{"title":"LeetCode_Spiral Matrix","date":"2019-01-10T10:00:36.000Z","_content":"\n## [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)\n\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n（螺旋式遍历矩阵）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_54.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 方向模拟\n事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：\n\n```python\nclass Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n\n        direction = {\n            'right': [0, 1],\n            'down': [1, 0],\n            'left': [0, -1],\n            'up': [-1, 0]\n        }\n\n        answer = []\n        i, j = 0, 0\n        direct = 'right'\n        left_border, right_border, up_border, down_border = 0, n-1, 0, m-1\n\n        while len(answer) < m * n:\n            answer.append(matrix[i][j])\n\n            if i==up_border and j==right_border and direct=='right':\n                direct = 'down'\n                up_border += 1\n            elif i==down_border and j==right_border and direct=='down':\n                direct = 'left'\n                right_border -= 1\n            elif i==down_border and j==left_border and direct=='left':\n                direct = 'up'\n                down_border -= 1\n            elif i==up_border and j==left_border and direct=='up':\n                direct = 'right'\n                left_border += 1 \n            i += direction[direct][0]\n            j += direction[direct][1]\n\n        return answer\n```\n\n### 2. zip函数\n在看别人的简单解法中发现用zip不断地旋转矩阵，每次都获得矩阵的第一行就是螺旋式遍历的结果。具体实现方法如下：\n\n```python\nclass Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        answer = []\n        while matrix:\n            answer += matrix.pop(0)\n            matrix = [*zip(*matrix)][::-1]\n        return answer\n```\n\n\n\n","source":"_posts/leetcode-SpiralMatrix.md","raw":"---\ntitle: LeetCode_Spiral Matrix\ndate: 2019-01-10 18:00:36\ncategories: LeetCode\ntags: \n  - medium\n  - array\n---\n\n## [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)\n\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n（螺旋式遍历矩阵）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_54.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 方向模拟\n事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：\n\n```python\nclass Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n\n        direction = {\n            'right': [0, 1],\n            'down': [1, 0],\n            'left': [0, -1],\n            'up': [-1, 0]\n        }\n\n        answer = []\n        i, j = 0, 0\n        direct = 'right'\n        left_border, right_border, up_border, down_border = 0, n-1, 0, m-1\n\n        while len(answer) < m * n:\n            answer.append(matrix[i][j])\n\n            if i==up_border and j==right_border and direct=='right':\n                direct = 'down'\n                up_border += 1\n            elif i==down_border and j==right_border and direct=='down':\n                direct = 'left'\n                right_border -= 1\n            elif i==down_border and j==left_border and direct=='left':\n                direct = 'up'\n                down_border -= 1\n            elif i==up_border and j==left_border and direct=='up':\n                direct = 'right'\n                left_border += 1 \n            i += direction[direct][0]\n            j += direction[direct][1]\n\n        return answer\n```\n\n### 2. zip函数\n在看别人的简单解法中发现用zip不断地旋转矩阵，每次都获得矩阵的第一行就是螺旋式遍历的结果。具体实现方法如下：\n\n```python\nclass Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        answer = []\n        while matrix:\n            answer += matrix.pop(0)\n            matrix = [*zip(*matrix)][::-1]\n        return answer\n```\n\n\n\n","slug":"leetcode-SpiralMatrix","published":1,"updated":"2019-01-13T07:47:04.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85f0087kvpx2v5itfol","content":"<h2 id=\"Spiral-Matrix\"><a href=\"#Spiral-Matrix\" class=\"headerlink\" title=\"Spiral Matrix\"></a><a href=\"https://leetcode.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">Spiral Matrix</a></h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.<br>（螺旋式遍历矩阵）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_54.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-方向模拟\"><a href=\"#1-方向模拟\" class=\"headerlink\" title=\"1. 方向模拟\"></a>1. 方向模拟</h3><p>事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type matrix: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        m = len(matrix)</span><br><span class=\"line\">        n = len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        direction = &#123;</span><br><span class=\"line\">            <span class=\"string\">'right'</span>: [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">            <span class=\"string\">'down'</span>: [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: [<span class=\"number\">0</span>, <span class=\"number\">-1</span>],</span><br><span class=\"line\">            <span class=\"string\">'up'</span>: [<span class=\"number\">-1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        answer = []</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        direct = <span class=\"string\">'right'</span></span><br><span class=\"line\">        left_border, right_border, up_border, down_border = <span class=\"number\">0</span>, n<span class=\"number\">-1</span>, <span class=\"number\">0</span>, m<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(answer) &lt; m * n:</span><br><span class=\"line\">            answer.append(matrix[i][j])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==up_border <span class=\"keyword\">and</span> j==right_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'right'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'down'</span></span><br><span class=\"line\">                up_border += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i==down_border <span class=\"keyword\">and</span> j==right_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'down'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'left'</span></span><br><span class=\"line\">                right_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i==down_border <span class=\"keyword\">and</span> j==left_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'left'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'up'</span></span><br><span class=\"line\">                down_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i==up_border <span class=\"keyword\">and</span> j==left_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'up'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'right'</span></span><br><span class=\"line\">                left_border += <span class=\"number\">1</span> </span><br><span class=\"line\">            i += direction[direct][<span class=\"number\">0</span>]</span><br><span class=\"line\">            j += direction[direct][<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-zip函数\"><a href=\"#2-zip函数\" class=\"headerlink\" title=\"2. zip函数\"></a>2. zip函数</h3><p>在看别人的简单解法中发现用zip不断地旋转矩阵，每次都获得矩阵的第一行就是螺旋式遍历的结果。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type matrix: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        answer = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> matrix:</span><br><span class=\"line\">            answer += matrix.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">            matrix = [*zip(*matrix)][::<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Spiral-Matrix\"><a href=\"#Spiral-Matrix\" class=\"headerlink\" title=\"Spiral Matrix\"></a><a href=\"https://leetcode.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">Spiral Matrix</a></h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.<br>（螺旋式遍历矩阵）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_54.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-方向模拟\"><a href=\"#1-方向模拟\" class=\"headerlink\" title=\"1. 方向模拟\"></a>1. 方向模拟</h3><p>事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type matrix: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        m = len(matrix)</span><br><span class=\"line\">        n = len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        direction = &#123;</span><br><span class=\"line\">            <span class=\"string\">'right'</span>: [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">            <span class=\"string\">'down'</span>: [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: [<span class=\"number\">0</span>, <span class=\"number\">-1</span>],</span><br><span class=\"line\">            <span class=\"string\">'up'</span>: [<span class=\"number\">-1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        answer = []</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        direct = <span class=\"string\">'right'</span></span><br><span class=\"line\">        left_border, right_border, up_border, down_border = <span class=\"number\">0</span>, n<span class=\"number\">-1</span>, <span class=\"number\">0</span>, m<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(answer) &lt; m * n:</span><br><span class=\"line\">            answer.append(matrix[i][j])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==up_border <span class=\"keyword\">and</span> j==right_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'right'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'down'</span></span><br><span class=\"line\">                up_border += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i==down_border <span class=\"keyword\">and</span> j==right_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'down'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'left'</span></span><br><span class=\"line\">                right_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i==down_border <span class=\"keyword\">and</span> j==left_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'left'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'up'</span></span><br><span class=\"line\">                down_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i==up_border <span class=\"keyword\">and</span> j==left_border <span class=\"keyword\">and</span> direct==<span class=\"string\">'up'</span>:</span><br><span class=\"line\">                direct = <span class=\"string\">'right'</span></span><br><span class=\"line\">                left_border += <span class=\"number\">1</span> </span><br><span class=\"line\">            i += direction[direct][<span class=\"number\">0</span>]</span><br><span class=\"line\">            j += direction[direct][<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-zip函数\"><a href=\"#2-zip函数\" class=\"headerlink\" title=\"2. zip函数\"></a>2. zip函数</h3><p>在看别人的简单解法中发现用zip不断地旋转矩阵，每次都获得矩阵的第一行就是螺旋式遍历的结果。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type matrix: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        answer = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> matrix:</span><br><span class=\"line\">            answer += matrix.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">            matrix = [*zip(*matrix)][::<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_String to Integer","date":"2018-11-26T08:23:21.000Z","_content":"\n## [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)\n\nImplement atoi which converts a string to an integer.\n（字符串转32位整形）\n\n<!--more-->\n\nNote:\n\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_8.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串过滤-正则表达式\n首先删除字符串首尾的空格，通过正则表达式过滤剩下以 \"+-0123456789\" 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）\n\n```python\nimport re\n\nclass Solution:\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        string = str.strip()\n        if not re.match(r'^(\\-|\\+)?\\d+', string):\n            return 0\n       \n        INT_MIN = -pow(2, 31)\n        INT_MAX = pow(2, 31) - 1\n        char_string = '+-0123456789'\n        \n        num_string = ''\n        for i, char in enumerate(string):\n            if char not in char_string:\n                break\n            if i != 0 and (char == '+' or char == '-'):\n                break\n            num_string += char\n       \n        if num_string[0] == '-':\n            result = int(num_string[1:])\n            result = max(result * - 1, INT_MIN)\n            return result\n        elif num_string[0] == '+': \n            result = int(num_string[1:])\n        else:\n            result = int(num_string)\n        result = min(result, INT_MAX)  \n        return result\n```\n**注**：需要考虑 \\\\(+/- \\\\) 出现在数字字符串中间的部分，因此 '0-1' 需要通过`if i != 0 and (char == '+' or char == '-')`过滤掉。当然，也可以直接通过match的group()函数，其返回值为匹配的字符串，进而获取开始的数值字符串。\n\n```python\nnum_string = re.match(r'^(\\-|\\+)?\\d+', string).group()\n```","source":"_posts/leetcode-StringtoInteger.md","raw":"---\ntitle: LeetCode_String to Integer\ndate: 2018-11-26 16:23:21\ncategories: LeetCode\ntags: \n  - medium\n  - math\n  - string\n  - regular expression\n---\n\n## [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)\n\nImplement atoi which converts a string to an integer.\n（字符串转32位整形）\n\n<!--more-->\n\nNote:\n\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\\\([−2^{31},  2^{31} − 1]\\\\). For the purpose of this problem, assume that your function **returns 0 when the reversed integer overflows**.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_8.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串过滤-正则表达式\n首先删除字符串首尾的空格，通过正则表达式过滤剩下以 \"+-0123456789\" 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）\n\n```python\nimport re\n\nclass Solution:\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        string = str.strip()\n        if not re.match(r'^(\\-|\\+)?\\d+', string):\n            return 0\n       \n        INT_MIN = -pow(2, 31)\n        INT_MAX = pow(2, 31) - 1\n        char_string = '+-0123456789'\n        \n        num_string = ''\n        for i, char in enumerate(string):\n            if char not in char_string:\n                break\n            if i != 0 and (char == '+' or char == '-'):\n                break\n            num_string += char\n       \n        if num_string[0] == '-':\n            result = int(num_string[1:])\n            result = max(result * - 1, INT_MIN)\n            return result\n        elif num_string[0] == '+': \n            result = int(num_string[1:])\n        else:\n            result = int(num_string)\n        result = min(result, INT_MAX)  \n        return result\n```\n**注**：需要考虑 \\\\(+/- \\\\) 出现在数字字符串中间的部分，因此 '0-1' 需要通过`if i != 0 and (char == '+' or char == '-')`过滤掉。当然，也可以直接通过match的group()函数，其返回值为匹配的字符串，进而获取开始的数值字符串。\n\n```python\nnum_string = re.match(r'^(\\-|\\+)?\\d+', string).group()\n```","slug":"leetcode-StringtoInteger","published":1,"updated":"2019-01-10T14:46:31.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85h008akvpxdkz864m2","content":"<h2 id=\"String-to-Integer-atoi\"><a href=\"#String-to-Integer-atoi\" class=\"headerlink\" title=\"String to Integer (atoi)\"></a><a href=\"https://leetcode.com/problems/string-to-integer-atoi/\" target=\"_blank\" rel=\"noopener\">String to Integer (atoi)</a></h2><p>Implement atoi which converts a string to an integer.<br>（字符串转32位整形）</p>\n<a id=\"more\"></a>\n<p>Note:</p>\n<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_8.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串过滤-正则表达式\"><a href=\"#字符串过滤-正则表达式\" class=\"headerlink\" title=\"字符串过滤-正则表达式\"></a>字符串过滤-正则表达式</h3><p>首先删除字符串首尾的空格，通过正则表达式过滤剩下以 “+-0123456789” 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myAtoi</span><span class=\"params\">(self, str)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type str: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str.strip()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re.match(<span class=\"string\">r'^(\\-|\\+)?\\d+'</span>, string):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        INT_MIN = -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\">        INT_MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        char_string = <span class=\"string\">'+-0123456789'</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        num_string = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, char <span class=\"keyword\">in</span> enumerate(string):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> char_string:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> (char == <span class=\"string\">'+'</span> <span class=\"keyword\">or</span> char == <span class=\"string\">'-'</span>):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            num_string += char</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">            result = max(result * - <span class=\"number\">1</span>, INT_MIN)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'+'</span>: </span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = int(num_string)</span><br><span class=\"line\">        result = min(result, INT_MAX)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：需要考虑 \\(+/- \\) 出现在数字字符串中间的部分，因此 ‘0-1’ 需要通过<code>if i != 0 and (char == &#39;+&#39; or char == &#39;-&#39;)</code>过滤掉。当然，也可以直接通过match的group()函数，其返回值为匹配的字符串，进而获取开始的数值字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_string = re.match(<span class=\"string\">r'^(\\-|\\+)?\\d+'</span>, string).group()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"String-to-Integer-atoi\"><a href=\"#String-to-Integer-atoi\" class=\"headerlink\" title=\"String to Integer (atoi)\"></a><a href=\"https://leetcode.com/problems/string-to-integer-atoi/\" target=\"_blank\" rel=\"noopener\">String to Integer (atoi)</a></h2><p>Implement atoi which converts a string to an integer.<br>（字符串转32位整形）</p>","more":"<p>Note:</p>\n<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \\([−2^{31},  2^{31} − 1]\\). For the purpose of this problem, assume that your function <strong>returns 0 when the reversed integer overflows</strong>.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_8.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串过滤-正则表达式\"><a href=\"#字符串过滤-正则表达式\" class=\"headerlink\" title=\"字符串过滤-正则表达式\"></a>字符串过滤-正则表达式</h3><p>首先删除字符串首尾的空格，通过正则表达式过滤剩下以 “+-0123456789” 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myAtoi</span><span class=\"params\">(self, str)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type str: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        string = str.strip()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re.match(<span class=\"string\">r'^(\\-|\\+)?\\d+'</span>, string):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        INT_MIN = -pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\">        INT_MAX = pow(<span class=\"number\">2</span>, <span class=\"number\">31</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        char_string = <span class=\"string\">'+-0123456789'</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        num_string = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, char <span class=\"keyword\">in</span> enumerate(string):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> char_string:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> (char == <span class=\"string\">'+'</span> <span class=\"keyword\">or</span> char == <span class=\"string\">'-'</span>):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            num_string += char</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>:</span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">            result = max(result * - <span class=\"number\">1</span>, INT_MIN)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num_string[<span class=\"number\">0</span>] == <span class=\"string\">'+'</span>: </span><br><span class=\"line\">            result = int(num_string[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result = int(num_string)</span><br><span class=\"line\">        result = min(result, INT_MAX)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：需要考虑 \\(+/- \\) 出现在数字字符串中间的部分，因此 ‘0-1’ 需要通过<code>if i != 0 and (char == &#39;+&#39; or char == &#39;-&#39;)</code>过滤掉。当然，也可以直接通过match的group()函数，其返回值为匹配的字符串，进而获取开始的数值字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_string = re.match(<span class=\"string\">r'^(\\-|\\+)?\\d+'</span>, string).group()</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Spiral Matrix II","date":"2019-01-13T07:31:44.000Z","_content":"\n## [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)\n\nGiven a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.\n（螺旋式生成矩阵）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_59.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 方向模拟\n事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：\n（与Spiral Matrix类似）\n\n```python\nclass Solution:\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if n == 0:\n            return []\n\n        direct_map = {\n            'right': [0, 1],\n            'down': [1, 0],\n            'left': [0, -1],\n            'up': [-1, 0]\n        }\n\n        result = [[0]*n for _ in range(n)]\n        left_border, right_border, up_border, down_border=0, n-1, 0, n-1\n        fill = 1\n        direction = 'right'\n        i, j = 0, 0\n        while fill <= n*n:\n            result[i][j] = fill\n            fill += 1\n            if direction=='right' and j==right_border:\n                direction = 'down'\n                up_border += 1\n            elif direction=='down' and i==down_border:\n                direction='left'\n                right_border -= 1\n            elif direction=='left' and j==left_border:\n                direction='up'\n                down_border -= 1\n            elif direction=='up' and i==up_border:\n                direction='right'\n                left_border += 1\n            i += direct_map[direction][0]\n            j += direct_map[direction][1]\n        return result\n```","source":"_posts/leetcode-SpiralMatrixII.md","raw":"---\ntitle: LeetCode_Spiral Matrix II\ndate: 2019-01-13 15:31:44\ncategories: LeetCode\ntags: \n  - medium\n  - array\n---\n\n## [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)\n\nGiven a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.\n（螺旋式生成矩阵）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_59.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 方向模拟\n事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：\n（与Spiral Matrix类似）\n\n```python\nclass Solution:\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if n == 0:\n            return []\n\n        direct_map = {\n            'right': [0, 1],\n            'down': [1, 0],\n            'left': [0, -1],\n            'up': [-1, 0]\n        }\n\n        result = [[0]*n for _ in range(n)]\n        left_border, right_border, up_border, down_border=0, n-1, 0, n-1\n        fill = 1\n        direction = 'right'\n        i, j = 0, 0\n        while fill <= n*n:\n            result[i][j] = fill\n            fill += 1\n            if direction=='right' and j==right_border:\n                direction = 'down'\n                up_border += 1\n            elif direction=='down' and i==down_border:\n                direction='left'\n                right_border -= 1\n            elif direction=='left' and j==left_border:\n                direction='up'\n                down_border -= 1\n            elif direction=='up' and i==up_border:\n                direction='right'\n                left_border += 1\n            i += direct_map[direction][0]\n            j += direct_map[direction][1]\n        return result\n```","slug":"leetcode-SpiralMatrixII","published":1,"updated":"2019-01-13T07:47:21.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85i008ekvpx91rhp1ei","content":"<h2 id=\"Spiral-Matrix-II\"><a href=\"#Spiral-Matrix-II\" class=\"headerlink\" title=\"Spiral Matrix II\"></a><a href=\"https://leetcode.com/problems/spiral-matrix-ii/\" target=\"_blank\" rel=\"noopener\">Spiral Matrix II</a></h2><p>Given a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.<br>（螺旋式生成矩阵）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_59.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-方向模拟\"><a href=\"#1-方向模拟\" class=\"headerlink\" title=\"1. 方向模拟\"></a>1. 方向模拟</h3><p>事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：<br>（与Spiral Matrix类似）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateMatrix</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\"></span><br><span class=\"line\">        direct_map = &#123;</span><br><span class=\"line\">            <span class=\"string\">'right'</span>: [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">            <span class=\"string\">'down'</span>: [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: [<span class=\"number\">0</span>, <span class=\"number\">-1</span>],</span><br><span class=\"line\">            <span class=\"string\">'up'</span>: [<span class=\"number\">-1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        left_border, right_border, up_border, down_border=<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        fill = <span class=\"number\">1</span></span><br><span class=\"line\">        direction = <span class=\"string\">'right'</span></span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> fill &lt;= n*n:</span><br><span class=\"line\">            result[i][j] = fill</span><br><span class=\"line\">            fill += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> direction==<span class=\"string\">'right'</span> <span class=\"keyword\">and</span> j==right_border:</span><br><span class=\"line\">                direction = <span class=\"string\">'down'</span></span><br><span class=\"line\">                up_border += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> direction==<span class=\"string\">'down'</span> <span class=\"keyword\">and</span> i==down_border:</span><br><span class=\"line\">                direction=<span class=\"string\">'left'</span></span><br><span class=\"line\">                right_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> direction==<span class=\"string\">'left'</span> <span class=\"keyword\">and</span> j==left_border:</span><br><span class=\"line\">                direction=<span class=\"string\">'up'</span></span><br><span class=\"line\">                down_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> direction==<span class=\"string\">'up'</span> <span class=\"keyword\">and</span> i==up_border:</span><br><span class=\"line\">                direction=<span class=\"string\">'right'</span></span><br><span class=\"line\">                left_border += <span class=\"number\">1</span></span><br><span class=\"line\">            i += direct_map[direction][<span class=\"number\">0</span>]</span><br><span class=\"line\">            j += direct_map[direction][<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Spiral-Matrix-II\"><a href=\"#Spiral-Matrix-II\" class=\"headerlink\" title=\"Spiral Matrix II\"></a><a href=\"https://leetcode.com/problems/spiral-matrix-ii/\" target=\"_blank\" rel=\"noopener\">Spiral Matrix II</a></h2><p>Given a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.<br>（螺旋式生成矩阵）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_59.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-方向模拟\"><a href=\"#1-方向模拟\" class=\"headerlink\" title=\"1. 方向模拟\"></a>1. 方向模拟</h3><p>事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：<br>（与Spiral Matrix类似）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateMatrix</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\"></span><br><span class=\"line\">        direct_map = &#123;</span><br><span class=\"line\">            <span class=\"string\">'right'</span>: [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">            <span class=\"string\">'down'</span>: [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: [<span class=\"number\">0</span>, <span class=\"number\">-1</span>],</span><br><span class=\"line\">            <span class=\"string\">'up'</span>: [<span class=\"number\">-1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        left_border, right_border, up_border, down_border=<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, <span class=\"number\">0</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        fill = <span class=\"number\">1</span></span><br><span class=\"line\">        direction = <span class=\"string\">'right'</span></span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> fill &lt;= n*n:</span><br><span class=\"line\">            result[i][j] = fill</span><br><span class=\"line\">            fill += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> direction==<span class=\"string\">'right'</span> <span class=\"keyword\">and</span> j==right_border:</span><br><span class=\"line\">                direction = <span class=\"string\">'down'</span></span><br><span class=\"line\">                up_border += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> direction==<span class=\"string\">'down'</span> <span class=\"keyword\">and</span> i==down_border:</span><br><span class=\"line\">                direction=<span class=\"string\">'left'</span></span><br><span class=\"line\">                right_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> direction==<span class=\"string\">'left'</span> <span class=\"keyword\">and</span> j==left_border:</span><br><span class=\"line\">                direction=<span class=\"string\">'up'</span></span><br><span class=\"line\">                down_border -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> direction==<span class=\"string\">'up'</span> <span class=\"keyword\">and</span> i==up_border:</span><br><span class=\"line\">                direction=<span class=\"string\">'right'</span></span><br><span class=\"line\">                left_border += <span class=\"number\">1</span></span><br><span class=\"line\">            i += direct_map[direction][<span class=\"number\">0</span>]</span><br><span class=\"line\">            j += direct_map[direction][<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Subsets","date":"2019-02-23T06:29:21.000Z","_content":"\n## [Subsets](https://leetcode.com/problems/subsets/)\n\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\n（列举所有子集）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_78.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n具体实现方法如下：\n\n```python\nclass Solution:\n    def dfs(self, i, re):\n        if re not in self.result:\n            self.result.append(re)\n        \n        for j in range(i, self.n):\n            self.dfs(j+1, re + [self.nums[j]])\n            self.dfs(j+1, re)\n        \n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \n        self.nums = nums\n        self.n = len(nums)\n        self.result = []\n        \n        self.dfs(0, [])\n        \n        return self.result\n```\n\n### 2. 递归\n求子集的过程中，list 中的每一个元素要么出现，要么不出现。可以通过递归的方法，增加一个元素，即是原来的子集 + 子集中的每一个集合加上这个新元素的组合。具体实现过程如下：\n\n```python\nclass Solution:\n    def subsets(self, nums: 'List[int]') -> 'List[List[int]]':\n        \n        res = [[]]\n        for num in sorted(nums):\n            res += [item+[num] for item in res]\n        return res\n```\n","source":"_posts/leetcode-Subsets.md","raw":"---\ntitle: LeetCode_Subsets\ndate: 2019-02-23 14:29:21\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n  - bit manipulation\n---\n\n## [Subsets](https://leetcode.com/problems/subsets/)\n\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\n（列举所有子集）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_78.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n具体实现方法如下：\n\n```python\nclass Solution:\n    def dfs(self, i, re):\n        if re not in self.result:\n            self.result.append(re)\n        \n        for j in range(i, self.n):\n            self.dfs(j+1, re + [self.nums[j]])\n            self.dfs(j+1, re)\n        \n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \n        self.nums = nums\n        self.n = len(nums)\n        self.result = []\n        \n        self.dfs(0, [])\n        \n        return self.result\n```\n\n### 2. 递归\n求子集的过程中，list 中的每一个元素要么出现，要么不出现。可以通过递归的方法，增加一个元素，即是原来的子集 + 子集中的每一个集合加上这个新元素的组合。具体实现过程如下：\n\n```python\nclass Solution:\n    def subsets(self, nums: 'List[int]') -> 'List[List[int]]':\n        \n        res = [[]]\n        for num in sorted(nums):\n            res += [item+[num] for item in res]\n        return res\n```\n","slug":"leetcode-Subsets","published":1,"updated":"2019-02-23T06:49:17.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85k008hkvpxosomlnhe","content":"<h2 id=\"Subsets\"><a href=\"#Subsets\" class=\"headerlink\" title=\"Subsets\"></a><a href=\"https://leetcode.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">Subsets</a></h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br>（列举所有子集）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_78.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, re)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> re <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.result:</span><br><span class=\"line\">            self.result.append(re)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, self.n):</span><br><span class=\"line\">            self.dfs(j+<span class=\"number\">1</span>, re + [self.nums[j]])</span><br><span class=\"line\">            self.dfs(j+<span class=\"number\">1</span>, re)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        self.n = len(nums)</span><br><span class=\"line\">        self.result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.dfs(<span class=\"number\">0</span>, [])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-递归\"><a href=\"#2-递归\" class=\"headerlink\" title=\"2. 递归\"></a>2. 递归</h3><p>求子集的过程中，list 中的每一个元素要么出现，要么不出现。可以通过递归的方法，增加一个元素，即是原来的子集 + 子集中的每一个集合加上这个新元素的组合。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        res = [[]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> sorted(nums):</span><br><span class=\"line\">            res += [item+[num] <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> res]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Subsets\"><a href=\"#Subsets\" class=\"headerlink\" title=\"Subsets\"></a><a href=\"https://leetcode.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">Subsets</a></h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br>（列举所有子集）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_78.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><p>具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, re)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> re <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.result:</span><br><span class=\"line\">            self.result.append(re)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, self.n):</span><br><span class=\"line\">            self.dfs(j+<span class=\"number\">1</span>, re + [self.nums[j]])</span><br><span class=\"line\">            self.dfs(j+<span class=\"number\">1</span>, re)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        self.n = len(nums)</span><br><span class=\"line\">        self.result = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.dfs(<span class=\"number\">0</span>, [])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-递归\"><a href=\"#2-递归\" class=\"headerlink\" title=\"2. 递归\"></a>2. 递归</h3><p>求子集的过程中，list 中的每一个元素要么出现，要么不出现。可以通过递归的方法，增加一个元素，即是原来的子集 + 子集中的每一个集合加上这个新元素的组合。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        res = [[]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> sorted(nums):</span><br><span class=\"line\">            res += [item+[num] <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> res]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Subsets II","date":"2019-02-26T10:45:47.000Z","_content":"\n## [Subsets II](https://leetcode.com/problems/subsets-ii/)\n\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n（列举所有子集）\n\n**Note:** The solution set must not contain duplicate subsets.\n\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_90.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n\n```python\nclass Solution:\n    def dfs(self, index, re):\n        if sorted(re) not in self.results:\n            self.results.append(sorted(re))\n\n        for i in range(index, len(self.nums)):\n            self.dfs(i+1, re)\n            self.dfs(i+1, re + [self.nums[i]])\n            \n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        self.results = []\n        self.nums = nums\n        self.dfs(0, [])\n        \n        return self.results\n```","source":"_posts/leetcode-SubsetsII.md","raw":"---\ntitle: LeetCode_Subsets II\ndate: 2019-02-26 18:45:47\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n---\n\n## [Subsets II](https://leetcode.com/problems/subsets-ii/)\n\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n（列举所有子集）\n\n**Note:** The solution set must not contain duplicate subsets.\n\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_90.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n\n```python\nclass Solution:\n    def dfs(self, index, re):\n        if sorted(re) not in self.results:\n            self.results.append(sorted(re))\n\n        for i in range(index, len(self.nums)):\n            self.dfs(i+1, re)\n            self.dfs(i+1, re + [self.nums[i]])\n            \n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        self.results = []\n        self.nums = nums\n        self.dfs(0, [])\n        \n        return self.results\n```","slug":"leetcode-SubsetsII","published":1,"updated":"2019-02-26T12:22:33.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85m008lkvpxlv8gmfri","content":"<h2 id=\"Subsets-II\"><a href=\"#Subsets-II\" class=\"headerlink\" title=\"Subsets II\"></a><a href=\"https://leetcode.com/problems/subsets-ii/\" target=\"_blank\" rel=\"noopener\">Subsets II</a></h2><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).<br>（列举所有子集）</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_90.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, index, re)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sorted(re) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.results:</span><br><span class=\"line\">            self.results.append(sorted(re))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(index, len(self.nums)):</span><br><span class=\"line\">            self.dfs(i+<span class=\"number\">1</span>, re)</span><br><span class=\"line\">            self.dfs(i+<span class=\"number\">1</span>, re + [self.nums[i]])</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsetsWithDup</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        self.results = []</span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        self.dfs(<span class=\"number\">0</span>, [])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.results</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Subsets-II\"><a href=\"#Subsets-II\" class=\"headerlink\" title=\"Subsets II\"></a><a href=\"https://leetcode.com/problems/subsets-ii/\" target=\"_blank\" rel=\"noopener\">Subsets II</a></h2><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).<br>（列举所有子集）</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_90.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, index, re)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sorted(re) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.results:</span><br><span class=\"line\">            self.results.append(sorted(re))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(index, len(self.nums)):</span><br><span class=\"line\">            self.dfs(i+<span class=\"number\">1</span>, re)</span><br><span class=\"line\">            self.dfs(i+<span class=\"number\">1</span>, re + [self.nums[i]])</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsetsWithDup</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        self.results = []</span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        self.dfs(<span class=\"number\">0</span>, [])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.results</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Symmetric Tree","date":"2019-03-04T02:34:09.000Z","_content":"\n## [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)\n\nGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n（对称二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_101.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归很常见，具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        def mirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            \n            return left.val == right.val and mirror(left.left, right.right) and mirror(right.left, left.right)\n        \n        if not root:\n            return True\n       \n        return mirror(root.left, root.right)\n```\n\n### 2. 迭代\n维护两个队列或者栈，把左子树放入第一个队列（先放左子树），右子树放入第二个队列（先放右子树），每次取队首（栈顶）元素进行判断。（使用队列表示BFS，使用栈表示DFS）具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# BFS\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n       \n        left_queue, right_queue = [root.left], [root.right]\n        \n        while len(left_queue) and len(right_queue):\n            left_top = left_queue.pop()\n            right_top = right_queue.pop()\n            \n            if not left_top and not right_top:\n                continue\n            if not left_top or not right_top:\n                return False\n            if left_top.val != right_top.val:\n                return False\n            \n            left_queue.insert(0, left_top.left)\n            left_queue.insert(0, left_top.right)\n            right_queue.insert(0, right_top.right)\n            right_queue.insert(0, right_top.left)\n            \n        return len(left_queue) == 0 and len(right_queue) == 0\n```\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# DFS\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n       \n        left_stack, right_stack = [root.left], [root.right]\n        \n        while len(left_stack) and len(right_stack):\n            left_top = left_stack.pop()\n            right_top = right_stack.pop()\n            \n            if not left_top and not right_top:\n                continue\n            if not left_top or not right_top:\n                return False\n            if left_top.val != right_top.val:\n                return False\n            \n            left_stack.append(left_top.left)\n            left_stack.append(left_top.right)\n            right_stack.append(right_top.right)\n            right_stack.append(right_top.left)\n               \n        return len(left_stack) == 0 and len(right_stack) == 0\n```\n\n","source":"_posts/leetcode-SymmetricTree.md","raw":"---\ntitle: LeetCode_Symmetric Tree\ndate: 2019-03-04 10:34:09\ncategories: LeetCode\ntags: \n  - easy\n  - tree\n  - dfs\n  - bfs\n---\n\n## [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)\n\nGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n（对称二叉树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_101.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归很常见，具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        def mirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            \n            return left.val == right.val and mirror(left.left, right.right) and mirror(right.left, left.right)\n        \n        if not root:\n            return True\n       \n        return mirror(root.left, root.right)\n```\n\n### 2. 迭代\n维护两个队列或者栈，把左子树放入第一个队列（先放左子树），右子树放入第二个队列（先放右子树），每次取队首（栈顶）元素进行判断。（使用队列表示BFS，使用栈表示DFS）具体实现过程如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# BFS\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n       \n        left_queue, right_queue = [root.left], [root.right]\n        \n        while len(left_queue) and len(right_queue):\n            left_top = left_queue.pop()\n            right_top = right_queue.pop()\n            \n            if not left_top and not right_top:\n                continue\n            if not left_top or not right_top:\n                return False\n            if left_top.val != right_top.val:\n                return False\n            \n            left_queue.insert(0, left_top.left)\n            left_queue.insert(0, left_top.right)\n            right_queue.insert(0, right_top.right)\n            right_queue.insert(0, right_top.left)\n            \n        return len(left_queue) == 0 and len(right_queue) == 0\n```\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# DFS\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n       \n        left_stack, right_stack = [root.left], [root.right]\n        \n        while len(left_stack) and len(right_stack):\n            left_top = left_stack.pop()\n            right_top = right_stack.pop()\n            \n            if not left_top and not right_top:\n                continue\n            if not left_top or not right_top:\n                return False\n            if left_top.val != right_top.val:\n                return False\n            \n            left_stack.append(left_top.left)\n            left_stack.append(left_top.right)\n            right_stack.append(right_top.right)\n            right_stack.append(right_top.left)\n               \n        return len(left_stack) == 0 and len(right_stack) == 0\n```\n\n","slug":"leetcode-SymmetricTree","published":1,"updated":"2019-03-04T06:08:40.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85p008okvpx3jn5xgql","content":"<h2 id=\"Symmetric-Tree\"><a href=\"#Symmetric-Tree\" class=\"headerlink\" title=\"Symmetric Tree\"></a><a href=\"https://leetcode.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">Symmetric Tree</a></h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).<br>（对称二叉树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_101.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归很常见，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mirror</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> right:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> right:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> left.val == right.val <span class=\"keyword\">and</span> mirror(left.left, right.right) <span class=\"keyword\">and</span> mirror(right.left, left.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> mirror(root.left, root.right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-迭代\"><a href=\"#2-迭代\" class=\"headerlink\" title=\"2. 迭代\"></a>2. 迭代</h3><p>维护两个队列或者栈，把左子树放入第一个队列（先放左子树），右子树放入第二个队列（先放右子树），每次取队首（栈顶）元素进行判断。（使用队列表示BFS，使用栈表示DFS）具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># BFS</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        left_queue, right_queue = [root.left], [root.right]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(left_queue) <span class=\"keyword\">and</span> len(right_queue):</span><br><span class=\"line\">            left_top = left_queue.pop()</span><br><span class=\"line\">            right_top = right_queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_top.val != right_top.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            left_queue.insert(<span class=\"number\">0</span>, left_top.left)</span><br><span class=\"line\">            left_queue.insert(<span class=\"number\">0</span>, left_top.right)</span><br><span class=\"line\">            right_queue.insert(<span class=\"number\">0</span>, right_top.right)</span><br><span class=\"line\">            right_queue.insert(<span class=\"number\">0</span>, right_top.left)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(left_queue) == <span class=\"number\">0</span> <span class=\"keyword\">and</span> len(right_queue) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># DFS</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        left_stack, right_stack = [root.left], [root.right]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(left_stack) <span class=\"keyword\">and</span> len(right_stack):</span><br><span class=\"line\">            left_top = left_stack.pop()</span><br><span class=\"line\">            right_top = right_stack.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_top.val != right_top.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            left_stack.append(left_top.left)</span><br><span class=\"line\">            left_stack.append(left_top.right)</span><br><span class=\"line\">            right_stack.append(right_top.right)</span><br><span class=\"line\">            right_stack.append(right_top.left)</span><br><span class=\"line\">               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(left_stack) == <span class=\"number\">0</span> <span class=\"keyword\">and</span> len(right_stack) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Symmetric-Tree\"><a href=\"#Symmetric-Tree\" class=\"headerlink\" title=\"Symmetric Tree\"></a><a href=\"https://leetcode.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">Symmetric Tree</a></h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).<br>（对称二叉树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_101.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归很常见，具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mirror</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> right:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> right:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> left.val == right.val <span class=\"keyword\">and</span> mirror(left.left, right.right) <span class=\"keyword\">and</span> mirror(right.left, left.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> mirror(root.left, root.right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-迭代\"><a href=\"#2-迭代\" class=\"headerlink\" title=\"2. 迭代\"></a>2. 迭代</h3><p>维护两个队列或者栈，把左子树放入第一个队列（先放左子树），右子树放入第二个队列（先放右子树），每次取队首（栈顶）元素进行判断。（使用队列表示BFS，使用栈表示DFS）具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># BFS</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        left_queue, right_queue = [root.left], [root.right]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(left_queue) <span class=\"keyword\">and</span> len(right_queue):</span><br><span class=\"line\">            left_top = left_queue.pop()</span><br><span class=\"line\">            right_top = right_queue.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_top.val != right_top.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            left_queue.insert(<span class=\"number\">0</span>, left_top.left)</span><br><span class=\"line\">            left_queue.insert(<span class=\"number\">0</span>, left_top.right)</span><br><span class=\"line\">            right_queue.insert(<span class=\"number\">0</span>, right_top.right)</span><br><span class=\"line\">            right_queue.insert(<span class=\"number\">0</span>, right_top.left)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(left_queue) == <span class=\"number\">0</span> <span class=\"keyword\">and</span> len(right_queue) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># DFS</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        left_stack, right_stack = [root.left], [root.right]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(left_stack) <span class=\"keyword\">and</span> len(right_stack):</span><br><span class=\"line\">            left_top = left_stack.pop()</span><br><span class=\"line\">            right_top = right_stack.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left_top <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> right_top:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left_top.val != right_top.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            left_stack.append(left_top.left)</span><br><span class=\"line\">            left_stack.append(left_top.right)</span><br><span class=\"line\">            right_stack.append(right_top.right)</span><br><span class=\"line\">            right_stack.append(right_top.left)</span><br><span class=\"line\">               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(left_stack) == <span class=\"number\">0</span> <span class=\"keyword\">and</span> len(right_stack) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Substring with Concatenation of All Words","date":"2018-12-18T10:21:13.000Z","_content":"\n## [Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)\n\nYou are given a string **s**, and a list of words **words**, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n（找到字符串中所有的子串，其为字符串数组全排列形成）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_30.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 定长取字符串子串\n这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\\\(O(n!)\\\\)算法；而应该从另一个角度出发，遍历字符串。\n\n由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 **words** 是否一致，这里的判断就借用了dict / hash map 实现。\n\n**Note**：\n 1. 边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。\n 2. 边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 \n 3. 字符串切分为等长的字符子串：subs = re.findall('.{'+str(sub_length)+'}', sub)\n\n```python\nimport re\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0 or s == '':\n            return []\n        \n        dict = {}\n        for word in words:\n            if word in dict:\n                dict[word] += 1\n            else:\n                dict[word] = 1\n        \n        sub_length = len(words[0])\n        whole_length = len(words) * sub_length\n        \n        result = []\n        for i in range(len(s) - whole_length + 1):\n            sub = s[i:i + whole_length]\n            subs = re.findall('.{'+str(sub_length)+'}', sub)\n    \n            d = {}\n            flag = 1\n            for word in subs:\n                if word not in dict:\n                    flag = 0\n                    break\n                if word in d:\n                    d[word] += 1\n                else:\n                    d[word] = 1\n            if flag == 1:\n                for item in d:\n                    if d[item] != dict[item]:\n                        flag = 0\n                        break\n            if flag == 1:\n                result.append(i)\n            \n        return result \n```","source":"_posts/leetcode-SubstringwithConcatenationofAllWords.md","raw":"---\ntitle: LeetCode_Substring with Concatenation of All Words\ndate: 2018-12-18 18:21:13\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - hash table\n  - two pointers\n---\n\n## [Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)\n\nYou are given a string **s**, and a list of words **words**, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n（找到字符串中所有的子串，其为字符串数组全排列形成）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_30.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 定长取字符串子串\n这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\\\(O(n!)\\\\)算法；而应该从另一个角度出发，遍历字符串。\n\n由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 **words** 是否一致，这里的判断就借用了dict / hash map 实现。\n\n**Note**：\n 1. 边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。\n 2. 边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 \n 3. 字符串切分为等长的字符子串：subs = re.findall('.{'+str(sub_length)+'}', sub)\n\n```python\nimport re\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0 or s == '':\n            return []\n        \n        dict = {}\n        for word in words:\n            if word in dict:\n                dict[word] += 1\n            else:\n                dict[word] = 1\n        \n        sub_length = len(words[0])\n        whole_length = len(words) * sub_length\n        \n        result = []\n        for i in range(len(s) - whole_length + 1):\n            sub = s[i:i + whole_length]\n            subs = re.findall('.{'+str(sub_length)+'}', sub)\n    \n            d = {}\n            flag = 1\n            for word in subs:\n                if word not in dict:\n                    flag = 0\n                    break\n                if word in d:\n                    d[word] += 1\n                else:\n                    d[word] = 1\n            if flag == 1:\n                for item in d:\n                    if d[item] != dict[item]:\n                        flag = 0\n                        break\n            if flag == 1:\n                result.append(i)\n            \n        return result \n```","slug":"leetcode-SubstringwithConcatenationofAllWords","published":1,"updated":"2018-12-18T13:30:53.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85s008skvpxd9avk1s6","content":"<h2 id=\"Substring-with-Concatenation-of-All-Words\"><a href=\"#Substring-with-Concatenation-of-All-Words\" class=\"headerlink\" title=\"Substring with Concatenation of All Words\"></a><a href=\"https://leetcode.com/problems/substring-with-concatenation-of-all-words/\" target=\"_blank\" rel=\"noopener\">Substring with Concatenation of All Words</a></h2><p>You are given a string <strong>s</strong>, and a list of words <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.<br>（找到字符串中所有的子串，其为字符串数组全排列形成）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_30.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-定长取字符串子串\"><a href=\"#1-定长取字符串子串\" class=\"headerlink\" title=\"1. 定长取字符串子串\"></a>1. 定长取字符串子串</h3><p>这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\(O(n!)\\)算法；而应该从另一个角度出发，遍历字符串。</p>\n<p>由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 <strong>words</strong> 是否一致，这里的判断就借用了dict / hash map 实现。</p>\n<p><strong>Note</strong>：</p>\n<ol>\n<li>边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。</li>\n<li>边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 </li>\n<li>字符串切分为等长的字符子串：subs = re.findall(‘.{‘+str(sub_length)+’}’, sub)</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubstring</span><span class=\"params\">(self, s, words)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type words: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(words) == <span class=\"number\">0</span> <span class=\"keyword\">or</span> s == <span class=\"string\">''</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                dict[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dict[word] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sub_length = len(words[<span class=\"number\">0</span>])</span><br><span class=\"line\">        whole_length = len(words) * sub_length</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s) - whole_length + <span class=\"number\">1</span>):</span><br><span class=\"line\">            sub = s[i:i + whole_length]</span><br><span class=\"line\">            subs = re.findall(<span class=\"string\">'.&#123;'</span>+str(sub_length)+<span class=\"string\">'&#125;'</span>, sub)</span><br><span class=\"line\">    </span><br><span class=\"line\">            d = &#123;&#125;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> subs:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    d[word] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    d[word] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> d[item] != dict[item]:</span><br><span class=\"line\">                        flag = <span class=\"number\">0</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                result.append(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Substring-with-Concatenation-of-All-Words\"><a href=\"#Substring-with-Concatenation-of-All-Words\" class=\"headerlink\" title=\"Substring with Concatenation of All Words\"></a><a href=\"https://leetcode.com/problems/substring-with-concatenation-of-all-words/\" target=\"_blank\" rel=\"noopener\">Substring with Concatenation of All Words</a></h2><p>You are given a string <strong>s</strong>, and a list of words <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.<br>（找到字符串中所有的子串，其为字符串数组全排列形成）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_30.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-定长取字符串子串\"><a href=\"#1-定长取字符串子串\" class=\"headerlink\" title=\"1. 定长取字符串子串\"></a>1. 定长取字符串子串</h3><p>这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \\(O(n!)\\)算法；而应该从另一个角度出发，遍历字符串。</p>\n<p>由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length  的子串集合，判断这个子串集合和题中的 <strong>words</strong> 是否一致，这里的判断就借用了dict / hash map 实现。</p>\n<p><strong>Note</strong>：</p>\n<ol>\n<li>边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。</li>\n<li>边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 </li>\n<li>字符串切分为等长的字符子串：subs = re.findall(‘.{‘+str(sub_length)+’}’, sub)</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubstring</span><span class=\"params\">(self, s, words)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type words: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(words) == <span class=\"number\">0</span> <span class=\"keyword\">or</span> s == <span class=\"string\">''</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                dict[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dict[word] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sub_length = len(words[<span class=\"number\">0</span>])</span><br><span class=\"line\">        whole_length = len(words) * sub_length</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s) - whole_length + <span class=\"number\">1</span>):</span><br><span class=\"line\">            sub = s[i:i + whole_length]</span><br><span class=\"line\">            subs = re.findall(<span class=\"string\">'.&#123;'</span>+str(sub_length)+<span class=\"string\">'&#125;'</span>, sub)</span><br><span class=\"line\">    </span><br><span class=\"line\">            d = &#123;&#125;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> subs:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> word <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    d[word] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    d[word] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> d[item] != dict[item]:</span><br><span class=\"line\">                        flag = <span class=\"number\">0</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                result.append(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Sudoku Solver","date":"2018-12-21T13:42:03.000Z","_content":"\n## [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n（求解数独盘）\n\n<!--more-->\n\nA sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits 1-9 must occur exactly once in each row.\n2. Each of the digits 1-9 must occur exactly once in each column.\n3. Each of the the digits 1-9 must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n4. Empty cells are indicated by the character '.'.\n\n**Note:**\n1. The given board contain only digits 1-9 and the character '.'.\n2. You may assume that the given Sudoku puzzle will have a single unique solution.\n3. The given board size is always 9x9.\n\n**Example:** \n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n<div align=center>\n\t<img src=\"/images/leetcode_37.png\" width = \"300\" align=center/>\n</div>\n\n\n### 1. 回溯法 Back Tracking\n求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：\n1. 寻找下一层节点，此处为find_next_empty()。\n2. 判断限制条件，此处为check_constraint()。\n3. 针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。\n\n```python\nclass Solution:\n\t# find the next entry need to fill\n\tdef find_next_empty(self):\n\t\tfor row in range(0, 9):\n\t\t\tfor col in range(0, 9):\n\t\t\t\tif self.board[row][col] == '.':\n\t\t\t\t\treturn [row, col]\n\t\treturn False\n\n\t# check the constraint \n\tdef check_constraint(self, x, y, num):\n\t\t# check row\n\t\tfor data in self.board[x]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check col\n\t\tfor data in list(zip(*self.board))[y]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check square\n\t\tsquare_row = x // 3 * 3\n\t\tsquare_col = y // 3 * 3\n\t\tdatas = []\n\t\tfor i in range(3):\n\t\t\tdatas += self.board[square_row + i][square_col: square_col + 3]\n\t\tfor data in datas:\n\t\t\tif data  == num:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef back_track(self):\n\t\tentry = self.find_next_empty()\n\t\tif entry == False:\n\t\t\treturn True\n\t\telse:\n\t\t\t[row, col] = entry\n\t\t\t# DFS\n\t\t\tfor i in range(1, 10):\n\t\t\t\tcheck = self.check_constraint(row, col, str(i))\n\t\t\t\t# pruning\n\t\t\t\tif check:\n\t\t\t\t\tself.board[row][col] = str(i)\n\t\t\t\t\tre = self.back_track()\n\t\t\t\t\t# back tracking\n\t\t\t\t\tif not re:\n\t\t\t\t\t\tself.board[row][col] = '.'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn True\n\t\t\t\t\t\t\n\t\t\treturn False\t\n\t\t\t\t\t\t\n\tdef solveSudoku(self, board):\n\t\t\"\"\"\n\t\t:type board: List[List[str]]\n\t\t:rtype: void Do not return anything, modify board in-place instead.\n\t\t\"\"\"\n\t\tself.board = board\n\t\tself.back_track()\n```","source":"_posts/leetcode-SudokuSolver.md","raw":"---\ntitle: LeetCode_Sudoku Solver\ndate: 2018-12-21 21:42:03\ncategories: LeetCode\ntags: \n  - hard\n  - hash table\n  - back tracking\n---\n\n## [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n（求解数独盘）\n\n<!--more-->\n\nA sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits 1-9 must occur exactly once in each row.\n2. Each of the digits 1-9 must occur exactly once in each column.\n3. Each of the the digits 1-9 must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n4. Empty cells are indicated by the character '.'.\n\n**Note:**\n1. The given board contain only digits 1-9 and the character '.'.\n2. You may assume that the given Sudoku puzzle will have a single unique solution.\n3. The given board size is always 9x9.\n\n**Example:** \n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n<div align=center>\n\t<img src=\"/images/leetcode_37.png\" width = \"300\" align=center/>\n</div>\n\n\n### 1. 回溯法 Back Tracking\n求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：\n1. 寻找下一层节点，此处为find_next_empty()。\n2. 判断限制条件，此处为check_constraint()。\n3. 针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。\n\n```python\nclass Solution:\n\t# find the next entry need to fill\n\tdef find_next_empty(self):\n\t\tfor row in range(0, 9):\n\t\t\tfor col in range(0, 9):\n\t\t\t\tif self.board[row][col] == '.':\n\t\t\t\t\treturn [row, col]\n\t\treturn False\n\n\t# check the constraint \n\tdef check_constraint(self, x, y, num):\n\t\t# check row\n\t\tfor data in self.board[x]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check col\n\t\tfor data in list(zip(*self.board))[y]:\n\t\t\tif data == num:\n\t\t\t\treturn False\n\t\t# check square\n\t\tsquare_row = x // 3 * 3\n\t\tsquare_col = y // 3 * 3\n\t\tdatas = []\n\t\tfor i in range(3):\n\t\t\tdatas += self.board[square_row + i][square_col: square_col + 3]\n\t\tfor data in datas:\n\t\t\tif data  == num:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef back_track(self):\n\t\tentry = self.find_next_empty()\n\t\tif entry == False:\n\t\t\treturn True\n\t\telse:\n\t\t\t[row, col] = entry\n\t\t\t# DFS\n\t\t\tfor i in range(1, 10):\n\t\t\t\tcheck = self.check_constraint(row, col, str(i))\n\t\t\t\t# pruning\n\t\t\t\tif check:\n\t\t\t\t\tself.board[row][col] = str(i)\n\t\t\t\t\tre = self.back_track()\n\t\t\t\t\t# back tracking\n\t\t\t\t\tif not re:\n\t\t\t\t\t\tself.board[row][col] = '.'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn True\n\t\t\t\t\t\t\n\t\t\treturn False\t\n\t\t\t\t\t\t\n\tdef solveSudoku(self, board):\n\t\t\"\"\"\n\t\t:type board: List[List[str]]\n\t\t:rtype: void Do not return anything, modify board in-place instead.\n\t\t\"\"\"\n\t\tself.board = board\n\t\tself.back_track()\n```","slug":"leetcode-SudokuSolver","published":1,"updated":"2019-02-25T12:51:33.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85t008vkvpx55s4jr3c","content":"<h2 id=\"Sudoku-Solver\"><a href=\"#Sudoku-Solver\" class=\"headerlink\" title=\"Sudoku Solver\"></a><a href=\"https://leetcode.com/problems/sudoku-solver/\" target=\"_blank\" rel=\"noopener\">Sudoku Solver</a></h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br>（求解数独盘）</p>\n<a id=\"more\"></a>\n<p>A sudoku solution must satisfy all of the following rules:</p>\n<ol>\n<li>Each of the digits 1-9 must occur exactly once in each row.</li>\n<li>Each of the digits 1-9 must occur exactly once in each column.</li>\n<li>Each of the the digits 1-9 must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n<li>Empty cells are indicated by the character ‘.’.</li>\n</ol>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<div align=\"center\"><br>    <img src=\"/images/leetcode_37.png\" width=\"300\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法-Back-Tracking\"><a href=\"#1-回溯法-Back-Tracking\" class=\"headerlink\" title=\"1. 回溯法 Back Tracking\"></a>1. 回溯法 Back Tracking</h3><p>求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：</p>\n<ol>\n<li>寻找下一层节点，此处为find_next_empty()。</li>\n<li>判断限制条件，此处为check_constraint()。</li>\n<li>针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"comment\"># find the next entry need to fill</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_next_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.board[row][col] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> [row, col]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\"># check the constraint </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_constraint</span><span class=\"params\">(self, x, y, num)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check row</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> self.board[x]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check col</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> list(zip(*self.board))[y]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check square</span></span><br><span class=\"line\">\t\tsquare_row = x // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tsquare_col = y // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tdatas = []</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">\t\t\tdatas += self.board[square_row + i][square_col: square_col + <span class=\"number\">3</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> datas:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data  == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">back_track</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\tentry = self.find_next_empty()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> entry == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t[row, col] = entry</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># DFS</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">\t\t\t\tcheck = self.check_constraint(row, col, str(i))</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\"># pruning</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> check:</span><br><span class=\"line\">\t\t\t\t\tself.board[row][col] = str(i)</span><br><span class=\"line\">\t\t\t\t\tre = self.back_track()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># back tracking</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re:</span><br><span class=\"line\">\t\t\t\t\t\tself.board[row][col] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span>\t</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.board = board</span><br><span class=\"line\">\t\tself.back_track()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Sudoku-Solver\"><a href=\"#Sudoku-Solver\" class=\"headerlink\" title=\"Sudoku Solver\"></a><a href=\"https://leetcode.com/problems/sudoku-solver/\" target=\"_blank\" rel=\"noopener\">Sudoku Solver</a></h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br>（求解数独盘）</p>","more":"<p>A sudoku solution must satisfy all of the following rules:</p>\n<ol>\n<li>Each of the digits 1-9 must occur exactly once in each row.</li>\n<li>Each of the digits 1-9 must occur exactly once in each column.</li>\n<li>Each of the the digits 1-9 must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n<li>Empty cells are indicated by the character ‘.’.</li>\n</ol>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<div align=\"center\"><br>    <img src=\"/images/leetcode_37.png\" width=\"300\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-回溯法-Back-Tracking\"><a href=\"#1-回溯法-Back-Tracking\" class=\"headerlink\" title=\"1. 回溯法 Back Tracking\"></a>1. 回溯法 Back Tracking</h3><p>求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分：</p>\n<ol>\n<li>寻找下一层节点，此处为find_next_empty()。</li>\n<li>判断限制条件，此处为check_constraint()。</li>\n<li>针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"comment\"># find the next entry need to fill</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_next_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> self.board[row][col] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> [row, col]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\"># check the constraint </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_constraint</span><span class=\"params\">(self, x, y, num)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check row</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> self.board[x]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check col</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> list(zip(*self.board))[y]:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># check square</span></span><br><span class=\"line\">\t\tsquare_row = x // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tsquare_col = y // <span class=\"number\">3</span> * <span class=\"number\">3</span></span><br><span class=\"line\">\t\tdatas = []</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">\t\t\tdatas += self.board[square_row + i][square_col: square_col + <span class=\"number\">3</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> datas:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> data  == num:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">back_track</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\tentry = self.find_next_empty()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> entry == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t[row, col] = entry</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># DFS</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">\t\t\t\tcheck = self.check_constraint(row, col, str(i))</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\"># pruning</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> check:</span><br><span class=\"line\">\t\t\t\t\tself.board[row][col] = str(i)</span><br><span class=\"line\">\t\t\t\t\tre = self.back_track()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># back tracking</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> re:</span><br><span class=\"line\">\t\t\t\t\t\tself.board[row][col] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">False</span>\t</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">\t\t:type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">\t\t:rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">\t\t\"\"\"</span></span><br><span class=\"line\">\t\tself.board = board</span><br><span class=\"line\">\t\tself.back_track()</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Text Justification","date":"2019-02-19T06:46:55.000Z","_content":"\n## [Text Justification](https://leetcode.com/problems/text-justification/)\n\n（文本左右对齐）\n\n<!--more-->\n\n**Note:**\n1. A word is defined as a character sequence consisting of non-space characters only.\n2. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n3. The input array words contains at least one word.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_68.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串遍历\n具体考虑分析需要分为以下几步：\n1. 计算每行最多显示单词的数量，记录起始单词位置（结束指针单词不包含在内），这里要注意，单词与单词之间的都要求有空格，所以除了开始的单词，每个单词的长度还要加1 \n2. 计算显示每句话需要的空格的数量 \n3. 计算每句话中单词之间需要均匀填充的空格数量。这里要注意最后一行不需要进行均匀填充，不能均匀填充的空格数量要记录下来，优先分给左边的单词间空格 \n4. 按照之前计算好的空格数量将单词连接成语句。 \n5. 要考虑到最后一句是在最右端填充所有的空格\n\n```python\nclass Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        i = 0\n        while i < len(words):\n            size = 0\n            begin = i\n\n            # 确定每行的单词数\n            while i < len(words):\n                newsize = len(words[i]) if size == 0 else size + len(words[i]) + 1\n                if newsize <= maxWidth: \n                    size = newsize\n                    i += 1\n                else:\n                    break\n\n            # 计算需要的剩余的空格数\n            spaceCount = maxWidth - size\n\n            # 计算每个单词需要的分配的单词数\n            if i - 1 - begin > 0 and i < len(words):\n            \t# 不是最后一行\n                everyCount = spaceCount // (i - 1 - begin)\n                spaceCount %= (i - 1 - begin)\n            else:\n            \t# 最后一行\n                everyCount = 0\n\n            # 根据空格数重新构建输出\n            j = begin\n            s = ''\n            while j < i:\n                if j > begin:\n                    s += ' ' * (everyCount + 1)\n                    # 无法均匀分配的空格优先分配给左边\n                    if spaceCount > 0 and i < len(words):\n                        s += ' '\n                        spaceCount -= 1\n                s += words[j]\n                j += 1\n            s += ' ' * spaceCount\n            \n            ans.append(s)\n        return ans\n```","source":"_posts/leetcode-TextJustification.md","raw":"---\ntitle: LeetCode_Text Justification\ndate: 2019-02-19 14:46:55\ncategories: LeetCode\ntags: \n  - hard\n  - string\n---\n\n## [Text Justification](https://leetcode.com/problems/text-justification/)\n\n（文本左右对齐）\n\n<!--more-->\n\n**Note:**\n1. A word is defined as a character sequence consisting of non-space characters only.\n2. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n3. The input array words contains at least one word.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_68.png\" width = \"500\" align=center/>\n</div>\n\n\n### 字符串遍历\n具体考虑分析需要分为以下几步：\n1. 计算每行最多显示单词的数量，记录起始单词位置（结束指针单词不包含在内），这里要注意，单词与单词之间的都要求有空格，所以除了开始的单词，每个单词的长度还要加1 \n2. 计算显示每句话需要的空格的数量 \n3. 计算每句话中单词之间需要均匀填充的空格数量。这里要注意最后一行不需要进行均匀填充，不能均匀填充的空格数量要记录下来，优先分给左边的单词间空格 \n4. 按照之前计算好的空格数量将单词连接成语句。 \n5. 要考虑到最后一句是在最右端填充所有的空格\n\n```python\nclass Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        i = 0\n        while i < len(words):\n            size = 0\n            begin = i\n\n            # 确定每行的单词数\n            while i < len(words):\n                newsize = len(words[i]) if size == 0 else size + len(words[i]) + 1\n                if newsize <= maxWidth: \n                    size = newsize\n                    i += 1\n                else:\n                    break\n\n            # 计算需要的剩余的空格数\n            spaceCount = maxWidth - size\n\n            # 计算每个单词需要的分配的单词数\n            if i - 1 - begin > 0 and i < len(words):\n            \t# 不是最后一行\n                everyCount = spaceCount // (i - 1 - begin)\n                spaceCount %= (i - 1 - begin)\n            else:\n            \t# 最后一行\n                everyCount = 0\n\n            # 根据空格数重新构建输出\n            j = begin\n            s = ''\n            while j < i:\n                if j > begin:\n                    s += ' ' * (everyCount + 1)\n                    # 无法均匀分配的空格优先分配给左边\n                    if spaceCount > 0 and i < len(words):\n                        s += ' '\n                        spaceCount -= 1\n                s += words[j]\n                j += 1\n            s += ' ' * spaceCount\n            \n            ans.append(s)\n        return ans\n```","slug":"leetcode-TextJustification","published":1,"updated":"2019-02-19T09:33:13.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85u008zkvpxkqlx16bd","content":"<h2 id=\"Text-Justification\"><a href=\"#Text-Justification\" class=\"headerlink\" title=\"Text Justification\"></a><a href=\"https://leetcode.com/problems/text-justification/\" target=\"_blank\" rel=\"noopener\">Text Justification</a></h2><p>（文本左右对齐）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong></p>\n<ol>\n<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n<li>Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.</li>\n<li>The input array words contains at least one word.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_68.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串遍历\"><a href=\"#字符串遍历\" class=\"headerlink\" title=\"字符串遍历\"></a>字符串遍历</h3><p>具体考虑分析需要分为以下几步：</p>\n<ol>\n<li>计算每行最多显示单词的数量，记录起始单词位置（结束指针单词不包含在内），这里要注意，单词与单词之间的都要求有空格，所以除了开始的单词，每个单词的长度还要加1 </li>\n<li>计算显示每句话需要的空格的数量 </li>\n<li>计算每句话中单词之间需要均匀填充的空格数量。这里要注意最后一行不需要进行均匀填充，不能均匀填充的空格数量要记录下来，优先分给左边的单词间空格 </li>\n<li>按照之前计算好的空格数量将单词连接成语句。 </li>\n<li>要考虑到最后一句是在最右端填充所有的空格</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fullJustify</span><span class=\"params\">(self, words, maxWidth)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type words: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :type maxWidth: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(words):</span><br><span class=\"line\">            size = <span class=\"number\">0</span></span><br><span class=\"line\">            begin = i</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 确定每行的单词数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; len(words):</span><br><span class=\"line\">                newsize = len(words[i]) <span class=\"keyword\">if</span> size == <span class=\"number\">0</span> <span class=\"keyword\">else</span> size + len(words[i]) + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> newsize &lt;= maxWidth: </span><br><span class=\"line\">                    size = newsize</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 计算需要的剩余的空格数</span></span><br><span class=\"line\">            spaceCount = maxWidth - size</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 计算每个单词需要的分配的单词数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i - <span class=\"number\">1</span> - begin &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> i &lt; len(words):</span><br><span class=\"line\">            \t<span class=\"comment\"># 不是最后一行</span></span><br><span class=\"line\">                everyCount = spaceCount // (i - <span class=\"number\">1</span> - begin)</span><br><span class=\"line\">                spaceCount %= (i - <span class=\"number\">1</span> - begin)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            \t<span class=\"comment\"># 最后一行</span></span><br><span class=\"line\">                everyCount = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 根据空格数重新构建输出</span></span><br><span class=\"line\">            j = begin</span><br><span class=\"line\">            s = <span class=\"string\">''</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; i:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j &gt; begin:</span><br><span class=\"line\">                    s += <span class=\"string\">' '</span> * (everyCount + <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"comment\"># 无法均匀分配的空格优先分配给左边</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> spaceCount &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> i &lt; len(words):</span><br><span class=\"line\">                        s += <span class=\"string\">' '</span></span><br><span class=\"line\">                        spaceCount -= <span class=\"number\">1</span></span><br><span class=\"line\">                s += words[j]</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            s += <span class=\"string\">' '</span> * spaceCount</span><br><span class=\"line\">            </span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Text-Justification\"><a href=\"#Text-Justification\" class=\"headerlink\" title=\"Text Justification\"></a><a href=\"https://leetcode.com/problems/text-justification/\" target=\"_blank\" rel=\"noopener\">Text Justification</a></h2><p>（文本左右对齐）</p>","more":"<p><strong>Note:</strong></p>\n<ol>\n<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n<li>Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.</li>\n<li>The input array words contains at least one word.</li>\n</ol>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_68.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"字符串遍历\"><a href=\"#字符串遍历\" class=\"headerlink\" title=\"字符串遍历\"></a>字符串遍历</h3><p>具体考虑分析需要分为以下几步：</p>\n<ol>\n<li>计算每行最多显示单词的数量，记录起始单词位置（结束指针单词不包含在内），这里要注意，单词与单词之间的都要求有空格，所以除了开始的单词，每个单词的长度还要加1 </li>\n<li>计算显示每句话需要的空格的数量 </li>\n<li>计算每句话中单词之间需要均匀填充的空格数量。这里要注意最后一行不需要进行均匀填充，不能均匀填充的空格数量要记录下来，优先分给左边的单词间空格 </li>\n<li>按照之前计算好的空格数量将单词连接成语句。 </li>\n<li>要考虑到最后一句是在最右端填充所有的空格</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fullJustify</span><span class=\"params\">(self, words, maxWidth)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type words: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        :type maxWidth: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(words):</span><br><span class=\"line\">            size = <span class=\"number\">0</span></span><br><span class=\"line\">            begin = i</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 确定每行的单词数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; len(words):</span><br><span class=\"line\">                newsize = len(words[i]) <span class=\"keyword\">if</span> size == <span class=\"number\">0</span> <span class=\"keyword\">else</span> size + len(words[i]) + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> newsize &lt;= maxWidth: </span><br><span class=\"line\">                    size = newsize</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 计算需要的剩余的空格数</span></span><br><span class=\"line\">            spaceCount = maxWidth - size</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 计算每个单词需要的分配的单词数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i - <span class=\"number\">1</span> - begin &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> i &lt; len(words):</span><br><span class=\"line\">            \t<span class=\"comment\"># 不是最后一行</span></span><br><span class=\"line\">                everyCount = spaceCount // (i - <span class=\"number\">1</span> - begin)</span><br><span class=\"line\">                spaceCount %= (i - <span class=\"number\">1</span> - begin)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            \t<span class=\"comment\"># 最后一行</span></span><br><span class=\"line\">                everyCount = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 根据空格数重新构建输出</span></span><br><span class=\"line\">            j = begin</span><br><span class=\"line\">            s = <span class=\"string\">''</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; i:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j &gt; begin:</span><br><span class=\"line\">                    s += <span class=\"string\">' '</span> * (everyCount + <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"comment\"># 无法均匀分配的空格优先分配给左边</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> spaceCount &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> i &lt; len(words):</span><br><span class=\"line\">                        s += <span class=\"string\">' '</span></span><br><span class=\"line\">                        spaceCount -= <span class=\"number\">1</span></span><br><span class=\"line\">                s += words[j]</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            s += <span class=\"string\">' '</span> * spaceCount</span><br><span class=\"line\">            </span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Swap Nodes in Pairs","date":"2018-12-13T13:47:54.000Z","_content":"\n## [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\nGiven a linked list, swap every two adjacent nodes and return its head.\n（交换链表中相邻的两个值）\n\n<!--more-->\n\nNote:\n\nYour algorithm should use only **constant** extra space.\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_24.png\" width = \"500\" align=center/>\n</div>\n\n\n### 链表指针\n这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：\n**（引入头指针是一个链表中常用的方法）**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode = ListNode(0)\n        newNode.next = head\n        \n        p = newNode\n        while p.next and p.next.next:\n            q = p.next\n            p.next = q.next\n            q.next = p.next.next\n            p.next.next = q\n            p = q\n               \n        return newNode.next\n```\n\n","source":"_posts/leetcode-SwapNodesinPairs.md","raw":"---\ntitle: LeetCode_Swap Nodes in Pairs\ndate: 2018-12-13 21:47:54\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n---\n\n## [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\nGiven a linked list, swap every two adjacent nodes and return its head.\n（交换链表中相邻的两个值）\n\n<!--more-->\n\nNote:\n\nYour algorithm should use only **constant** extra space.\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_24.png\" width = \"500\" align=center/>\n</div>\n\n\n### 链表指针\n这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：\n**（引入头指针是一个链表中常用的方法）**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode = ListNode(0)\n        newNode.next = head\n        \n        p = newNode\n        while p.next and p.next.next:\n            q = p.next\n            p.next = q.next\n            q.next = p.next.next\n            p.next.next = q\n            p = q\n               \n        return newNode.next\n```\n\n","slug":"leetcode-SwapNodesinPairs","published":1,"updated":"2018-12-26T03:39:34.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85v0092kvpx499v4kpk","content":"<h2 id=\"Swap-Nodes-in-Pairs\"><a href=\"#Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"Swap Nodes in Pairs\"></a><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">Swap Nodes in Pairs</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.<br>（交换链表中相邻的两个值）</p>\n<a id=\"more\"></a>\n<p>Note:</p>\n<p>Your algorithm should use only <strong>constant</strong> extra space.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_24.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"链表指针\"><a href=\"#链表指针\" class=\"headerlink\" title=\"链表指针\"></a>链表指针</h3><p>这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：<br><strong>（引入头指针是一个链表中常用的方法）</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        newNode = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        newNode.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = newNode</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p.next <span class=\"keyword\">and</span> p.next.next:</span><br><span class=\"line\">            q = p.next</span><br><span class=\"line\">            p.next = q.next</span><br><span class=\"line\">            q.next = p.next.next</span><br><span class=\"line\">            p.next.next = q</span><br><span class=\"line\">            p = q</span><br><span class=\"line\">               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode.next</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Swap-Nodes-in-Pairs\"><a href=\"#Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"Swap Nodes in Pairs\"></a><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">Swap Nodes in Pairs</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.<br>（交换链表中相邻的两个值）</p>","more":"<p>Note:</p>\n<p>Your algorithm should use only <strong>constant</strong> extra space.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_24.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"链表指针\"><a href=\"#链表指针\" class=\"headerlink\" title=\"链表指针\"></a>链表指针</h3><p>这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：<br><strong>（引入头指针是一个链表中常用的方法）</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        newNode = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        newNode.next = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = newNode</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p.next <span class=\"keyword\">and</span> p.next.next:</span><br><span class=\"line\">            q = p.next</span><br><span class=\"line\">            p.next = q.next</span><br><span class=\"line\">            q.next = p.next.next</span><br><span class=\"line\">            p.next.next = q</span><br><span class=\"line\">            p = q</span><br><span class=\"line\">               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode.next</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Trapping Rain Water","date":"2018-12-26T03:00:07.000Z","_content":"\n## [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n（收集雨水）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_42.png\" width = \"500\" align=center/>\n</div>\n\n根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。\n\n### 两个指针\n蓄水实质上是找从左到右或者从右到左高度下降的地方：\n设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。\n1. 假设 max_left <= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；\n2. 在 max_left > max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；\n\n最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：\n\n```python\nclass Solution:\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n       \n        result = 0\n\n        max_left, max_right = 0, 0\n        left, right = 0, len(height)-1\n        while left < right:\n            max_left = max(height[left], max_left)\n            max_right = max(height[right], max_right)\n            \n            if max_left <= max_right:\n                result += (max_left - height[left])\n                left += 1\n            else:\n                result += (max_right - height[right])\n                right -= 1\n                \n        return result\n```","source":"_posts/leetcode-TrappingRainWater.md","raw":"---\ntitle: LeetCode_Trapping Rain Water\ndate: 2018-12-26 11:00:07\ncategories: LeetCode\ntags: \n  - hard\n  - array\n  - two pointers\n  - stack\n---\n\n## [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n（收集雨水）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_42.png\" width = \"500\" align=center/>\n</div>\n\n根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。\n\n### 两个指针\n蓄水实质上是找从左到右或者从右到左高度下降的地方：\n设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。\n1. 假设 max_left <= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；\n2. 在 max_left > max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；\n\n最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：\n\n```python\nclass Solution:\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n       \n        result = 0\n\n        max_left, max_right = 0, 0\n        left, right = 0, len(height)-1\n        while left < right:\n            max_left = max(height[left], max_left)\n            max_right = max(height[right], max_right)\n            \n            if max_left <= max_right:\n                result += (max_left - height[left])\n                left += 1\n            else:\n                result += (max_right - height[right])\n                right -= 1\n                \n        return result\n```","slug":"leetcode-TrappingRainWater","published":1,"updated":"2019-01-02T12:37:25.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85x0096kvpxdy5f7hi5","content":"<h2 id=\"Trapping-Rain-Water\"><a href=\"#Trapping-Rain-Water\" class=\"headerlink\" title=\"Trapping Rain Water\"></a><a href=\"https://leetcode.com/problems/trapping-rain-water/\" target=\"_blank\" rel=\"noopener\">Trapping Rain Water</a></h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>（收集雨水）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_42.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。</p>\n<h3 id=\"两个指针\"><a href=\"#两个指针\" class=\"headerlink\" title=\"两个指针\"></a>两个指针</h3><p>蓄水实质上是找从左到右或者从右到左高度下降的地方：<br>设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。</p>\n<ol>\n<li>假设 max_left &lt;= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；</li>\n<li>在 max_left &gt; max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；</li>\n</ol>\n<p>最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        max_left, max_right = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, len(height)<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            max_left = max(height[left], max_left)</span><br><span class=\"line\">            max_right = max(height[right], max_right)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_left &lt;= max_right:</span><br><span class=\"line\">                result += (max_left - height[left])</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result += (max_right - height[right])</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Trapping-Rain-Water\"><a href=\"#Trapping-Rain-Water\" class=\"headerlink\" title=\"Trapping Rain Water\"></a><a href=\"https://leetcode.com/problems/trapping-rain-water/\" target=\"_blank\" rel=\"noopener\">Trapping Rain Water</a></h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>（收集雨水）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_42.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。</p>\n<h3 id=\"两个指针\"><a href=\"#两个指针\" class=\"headerlink\" title=\"两个指针\"></a>两个指针</h3><p>蓄水实质上是找从左到右或者从右到左高度下降的地方：<br>设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。</p>\n<ol>\n<li>假设 max_left &lt;= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针；</li>\n<li>在 max_left &gt; max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针；</li>\n</ol>\n<p>最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type height: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        max_left, max_right = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, len(height)<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            max_left = max(height[left], max_left)</span><br><span class=\"line\">            max_right = max(height[right], max_right)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_left &lt;= max_right:</span><br><span class=\"line\">                result += (max_left - height[left])</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result += (max_right - height[right])</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Unique Binary Search Trees","date":"2019-02-27T08:44:58.000Z","_content":"\n## [Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)\n\nGiven an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.\n（有效二叉查找(排序)树个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_96.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n这道题实质上是 **卡塔兰数** 的一个实例。具体递推过程如下：\n\n```c++\n                           1                    n = 1\n        \n                        2      1                n = 2\n                       /        \\\n                   \t  1          2\n\n            1          3     3      2      1    n = 3\n              \\       /     /      / \\      \\\n               3     2     1      1   3      2\n              /     /       \\                 \\\n            2      1         2                 3\n```\n1. n=0 时，dp[0] = 1\n2. n=1 时，dp[1] = 1\n3. n=2 时，dp[2] = dp[0]\\*dp[1] + dp[1]\\*dp[0] （以1为根 + 以2为根）\n4. n>=2 时，dp[n] = dp[0]\\*dp[n-1] + dp[1]\\*dp[n-2] + ... + dp[n-1]\\*dp[0] \n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0 for _ in range(n+1)]\n        dp[0], dp[1] = 1, 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n        \n        return dp[n]\n```\n\n","source":"_posts/leetcode-UniqueBinarySearchTrees.md","raw":"---\ntitle: LeetCode_Unique Binary Search Trees\ndate: 2019-02-27 16:44:58\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - dynamic programming\n---\n\n## [Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)\n\nGiven an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.\n（有效二叉查找(排序)树个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_96.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n这道题实质上是 **卡塔兰数** 的一个实例。具体递推过程如下：\n\n```c++\n                           1                    n = 1\n        \n                        2      1                n = 2\n                       /        \\\n                   \t  1          2\n\n            1          3     3      2      1    n = 3\n              \\       /     /      / \\      \\\n               3     2     1      1   3      2\n              /     /       \\                 \\\n            2      1         2                 3\n```\n1. n=0 时，dp[0] = 1\n2. n=1 时，dp[1] = 1\n3. n=2 时，dp[2] = dp[0]\\*dp[1] + dp[1]\\*dp[0] （以1为根 + 以2为根）\n4. n>=2 时，dp[n] = dp[0]\\*dp[n-1] + dp[1]\\*dp[n-2] + ... + dp[n-1]\\*dp[0] \n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0 for _ in range(n+1)]\n        dp[0], dp[1] = 1, 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n        \n        return dp[n]\n```\n\n","slug":"leetcode-UniqueBinarySearchTrees","published":1,"updated":"2019-02-27T09:05:34.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85y0099kvpx7e0j5yr1","content":"<h2 id=\"Unique-Binary-Search-Trees\"><a href=\"#Unique-Binary-Search-Trees\" class=\"headerlink\" title=\"Unique Binary Search Trees\"></a><a href=\"https://leetcode.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">Unique Binary Search Trees</a></h2><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br>（有效二叉查找(排序)树个数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_96.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这道题实质上是 <strong>卡塔兰数</strong> 的一个实例。具体递推过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">               <span class=\"number\">1</span>                    n = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"number\">2</span>      <span class=\"number\">1</span>                n = <span class=\"number\">2</span></span><br><span class=\"line\">           /        \\</span><br><span class=\"line\">       \t  <span class=\"number\">1</span>          <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>          <span class=\"number\">3</span>     <span class=\"number\">3</span>      <span class=\"number\">2</span>      <span class=\"number\">1</span>    n = <span class=\"number\">3</span></span><br><span class=\"line\">  \\       /     /      / \\      \\</span><br><span class=\"line\">   <span class=\"number\">3</span>     <span class=\"number\">2</span>     <span class=\"number\">1</span>      <span class=\"number\">1</span>   <span class=\"number\">3</span>      <span class=\"number\">2</span></span><br><span class=\"line\">  /     /       \\                 \\</span><br><span class=\"line\"><span class=\"number\">2</span>      <span class=\"number\">1</span>         <span class=\"number\">2</span>                 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>n=0 时，dp[0] = 1</li>\n<li>n=1 时，dp[1] = 1</li>\n<li>n=2 时，dp[2] = dp[0]*dp[1] + dp[1]*dp[0] （以1为根 + 以2为根）</li>\n<li>n&gt;=2 时，dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + … + dp[n-1]*dp[0] </li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>], dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                dp[i] += dp[j] * dp[i-j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Unique-Binary-Search-Trees\"><a href=\"#Unique-Binary-Search-Trees\" class=\"headerlink\" title=\"Unique Binary Search Trees\"></a><a href=\"https://leetcode.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">Unique Binary Search Trees</a></h2><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br>（有效二叉查找(排序)树个数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_96.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这道题实质上是 <strong>卡塔兰数</strong> 的一个实例。具体递推过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">               <span class=\"number\">1</span>                    n = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"number\">2</span>      <span class=\"number\">1</span>                n = <span class=\"number\">2</span></span><br><span class=\"line\">           /        \\</span><br><span class=\"line\">       \t  <span class=\"number\">1</span>          <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>          <span class=\"number\">3</span>     <span class=\"number\">3</span>      <span class=\"number\">2</span>      <span class=\"number\">1</span>    n = <span class=\"number\">3</span></span><br><span class=\"line\">  \\       /     /      / \\      \\</span><br><span class=\"line\">   <span class=\"number\">3</span>     <span class=\"number\">2</span>     <span class=\"number\">1</span>      <span class=\"number\">1</span>   <span class=\"number\">3</span>      <span class=\"number\">2</span></span><br><span class=\"line\">  /     /       \\                 \\</span><br><span class=\"line\"><span class=\"number\">2</span>      <span class=\"number\">1</span>         <span class=\"number\">2</span>                 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>n=0 时，dp[0] = 1</li>\n<li>n=1 时，dp[1] = 1</li>\n<li>n=2 时，dp[2] = dp[0]*dp[1] + dp[1]*dp[0] （以1为根 + 以2为根）</li>\n<li>n&gt;=2 时，dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + … + dp[n-1]*dp[0] </li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>], dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                dp[i] += dp[j] * dp[i-j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Unique Binary Search Trees II","date":"2019-02-27T07:55:13.000Z","_content":"\n## [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)\n\nGiven an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.\n（构建二叉查找(排序)树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_95.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归的构建左子树 和 右子树，具体实现方法如下：\n\n**Note:** 在start > end 的时候，不存在这样的子树。\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def gen(start, end):\n            if start > end:\n                return [None]\n            \n            results = []\n            for i in range(start, end+1):\n                for l in gen(start, i-1):\n                     for r in gen(i+1, end):\n                            t = TreeNode(i)\n                            t.left = l\n                            t.right = r   \n                            results.append(t)\n            return results\n        \n        if n < 1:\n            return []\n       \n        return gen(1, n)\n```\n","source":"_posts/leetcode-UniqueBinarySearchTreesII.md","raw":"---\ntitle: LeetCode_Unique Binary Search Trees II\ndate: 2019-02-27 15:55:13\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - recursion\n  - dynamic programming\n---\n\n## [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)\n\nGiven an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.\n（构建二叉查找(排序)树）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_95.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 递归\n递归的构建左子树 和 右子树，具体实现方法如下：\n\n**Note:** 在start > end 的时候，不存在这样的子树。\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def gen(start, end):\n            if start > end:\n                return [None]\n            \n            results = []\n            for i in range(start, end+1):\n                for l in gen(start, i-1):\n                     for r in gen(i+1, end):\n                            t = TreeNode(i)\n                            t.left = l\n                            t.right = r   \n                            results.append(t)\n            return results\n        \n        if n < 1:\n            return []\n       \n        return gen(1, n)\n```\n","slug":"leetcode-UniqueBinarySearchTreesII","published":1,"updated":"2019-02-27T12:43:59.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht85z009dkvpxq0zyr66f","content":"<h2 id=\"Unique-Binary-Search-Trees-II\"><a href=\"#Unique-Binary-Search-Trees-II\" class=\"headerlink\" title=\"Unique Binary Search Trees II\"></a><a href=\"https://leetcode.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">Unique Binary Search Trees II</a></h2><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br>（构建二叉查找(排序)树）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_95.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归的构建左子树 和 右子树，具体实现方法如下：</p>\n<p><strong>Note:</strong> 在start &gt; end 的时候，不存在这样的子树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateTrees</span><span class=\"params\">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen</span><span class=\"params\">(start, end)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> start &gt; end:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [<span class=\"keyword\">None</span>]</span><br><span class=\"line\">            </span><br><span class=\"line\">            results = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(start, end+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> gen(start, i<span class=\"number\">-1</span>):</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> gen(i+<span class=\"number\">1</span>, end):</span><br><span class=\"line\">                            t = TreeNode(i)</span><br><span class=\"line\">                            t.left = l</span><br><span class=\"line\">                            t.right = r   </span><br><span class=\"line\">                            results.append(t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> gen(<span class=\"number\">1</span>, n)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Unique-Binary-Search-Trees-II\"><a href=\"#Unique-Binary-Search-Trees-II\" class=\"headerlink\" title=\"Unique Binary Search Trees II\"></a><a href=\"https://leetcode.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">Unique Binary Search Trees II</a></h2><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br>（构建二叉查找(排序)树）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_95.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>递归的构建左子树 和 右子树，具体实现方法如下：</p>\n<p><strong>Note:</strong> 在start &gt; end 的时候，不存在这样的子树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateTrees</span><span class=\"params\">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen</span><span class=\"params\">(start, end)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> start &gt; end:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [<span class=\"keyword\">None</span>]</span><br><span class=\"line\">            </span><br><span class=\"line\">            results = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(start, end+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> gen(start, i<span class=\"number\">-1</span>):</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> gen(i+<span class=\"number\">1</span>, end):</span><br><span class=\"line\">                            t = TreeNode(i)</span><br><span class=\"line\">                            t.left = l</span><br><span class=\"line\">                            t.right = r   </span><br><span class=\"line\">                            results.append(t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> gen(<span class=\"number\">1</span>, n)</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Unique Paths II","date":"2019-01-15T03:26:34.000Z","_content":"\n## [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)\n\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some **obstacles** are added to the grids. How many unique paths would there be?\n（不同的路径II，只能向右或者向下移动在有路障的情况下从左上角移动到右下角的路径个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_63.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。但是需要另外考虑：\n1. 遇到路障时，dp[i][j] = 0，继续扫描。\n2. 由于从左上角开始扫描，在扫描第一行时：dp[i][j] = dp[i][j-1]。\n3. 在扫描第一列时：dp[i][j] = dp[i-1][j] 。\n\n具体实现形式如下：\n\n```python\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        dp = [[1]*n for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                    continue\n                if i == 0 and j > 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0 and i > 0:\n       \t\t        dp[i][j] = dp[i-1][j]\n                elif i > 0 and j > 0:\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j]\n                    \n        return dp[m-1][n-1]\n```","source":"_posts/leetcode-UniquePathsII.md","raw":"---\ntitle: LeetCode_Unique Paths II\ndate: 2019-01-15 11:26:34\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - dynamic programming\n---\n\n## [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)\n\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some **obstacles** are added to the grids. How many unique paths would there be?\n（不同的路径II，只能向右或者向下移动在有路障的情况下从左上角移动到右下角的路径个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_63.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。但是需要另外考虑：\n1. 遇到路障时，dp[i][j] = 0，继续扫描。\n2. 由于从左上角开始扫描，在扫描第一行时：dp[i][j] = dp[i][j-1]。\n3. 在扫描第一列时：dp[i][j] = dp[i-1][j] 。\n\n具体实现形式如下：\n\n```python\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        dp = [[1]*n for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                    continue\n                if i == 0 and j > 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0 and i > 0:\n       \t\t        dp[i][j] = dp[i-1][j]\n                elif i > 0 and j > 0:\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j]\n                    \n        return dp[m-1][n-1]\n```","slug":"leetcode-UniquePathsII","published":1,"updated":"2019-01-15T06:10:05.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht861009gkvpx71uzrkze","content":"<h2 id=\"Unique-Paths-II\"><a href=\"#Unique-Paths-II\" class=\"headerlink\" title=\"Unique Paths II\"></a><a href=\"https://leetcode.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">Unique Paths II</a></h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some <strong>obstacles</strong> are added to the grids. How many unique paths would there be?<br>（不同的路径II，只能向右或者向下移动在有路障的情况下从左上角移动到右下角的路径个数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_63.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。但是需要另外考虑：</p>\n<ol>\n<li>遇到路障时，dp[i][j] = 0，继续扫描。</li>\n<li>由于从左上角开始扫描，在扫描第一行时：dp[i][j] = dp[i][j-1]。</li>\n<li>在扫描第一列时：dp[i][j] = dp[i-1][j] 。</li>\n</ol>\n<p>具体实现形式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(self, obstacleGrid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type obstacleGrid: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        m, n = len(obstacleGrid), len(obstacleGrid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        dp = [[<span class=\"number\">1</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> obstacleGrid[i][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j == <span class=\"number\">0</span> <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">       \t\t        dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Unique-Paths-II\"><a href=\"#Unique-Paths-II\" class=\"headerlink\" title=\"Unique Paths II\"></a><a href=\"https://leetcode.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">Unique Paths II</a></h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some <strong>obstacles</strong> are added to the grids. How many unique paths would there be?<br>（不同的路径II，只能向右或者向下移动在有路障的情况下从左上角移动到右下角的路径个数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_63.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。但是需要另外考虑：</p>\n<ol>\n<li>遇到路障时，dp[i][j] = 0，继续扫描。</li>\n<li>由于从左上角开始扫描，在扫描第一行时：dp[i][j] = dp[i][j-1]。</li>\n<li>在扫描第一列时：dp[i][j] = dp[i-1][j] 。</li>\n</ol>\n<p>具体实现形式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(self, obstacleGrid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type obstacleGrid: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        m, n = len(obstacleGrid), len(obstacleGrid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        dp = [[<span class=\"number\">1</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> obstacleGrid[i][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j == <span class=\"number\">0</span> <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">       \t\t        dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Unique Paths","date":"2019-01-15T02:51:52.000Z","_content":"\n## [Unique Paths](https://leetcode.com/problems/unique-paths/)\n\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?\n（不同的路径，只能向右或者向下移动从左上角移动到右下角的路径个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_62.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 即可，具体实现形式如下：\n\n```python\nclass Solution:\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[1]*n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n        return dp[m-1][n-1]\n```","source":"_posts/leetcode-UniquePaths.md","raw":"---\ntitle: LeetCode_Unique Paths\ndate: 2019-01-15 10:51:52\ncategories: LeetCode\ntags: \n  - medium\n  - array\n  - dynamic programming\n---\n\n## [Unique Paths](https://leetcode.com/problems/unique-paths/)\n\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?\n（不同的路径，只能向右或者向下移动从左上角移动到右下角的路径个数）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_62.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 即可，具体实现形式如下：\n\n```python\nclass Solution:\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[1]*n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n        return dp[m-1][n-1]\n```","slug":"leetcode-UniquePaths","published":1,"updated":"2019-01-15T03:40:01.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht862009kkvpxiukanypd","content":"<h2 id=\"Unique-Paths\"><a href=\"#Unique-Paths\" class=\"headerlink\" title=\"Unique Paths\"></a><a href=\"https://leetcode.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">Unique Paths</a></h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?<br>（不同的路径，只能向右或者向下移动从左上角移动到右下角的路径个数）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_62.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 即可，具体实现形式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(self, m, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type m: int</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        dp = [[<span class=\"number\">1</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j] + dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Unique-Paths\"><a href=\"#Unique-Paths\" class=\"headerlink\" title=\"Unique Paths\"></a><a href=\"https://leetcode.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">Unique Paths</a></h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?<br>（不同的路径，只能向右或者向下移动从左上角移动到右下角的路径个数）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_62.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 即可，具体实现形式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(self, m, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type m: int</span></span><br><span class=\"line\"><span class=\"string\">        :type n: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        dp = [[<span class=\"number\">1</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j] + dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Valid Number","date":"2019-01-15T06:25:07.000Z","_content":"\n## [Valid Number](https://leetcode.com/problems/valid-number/)\n\nValidate if a given string can be interpreted as a decimal number.\n（字符串是否为有效数字）\n\n<!--more-->\n\n**Note:** It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:\n\n  - Numbers 0-9\n  - Exponent - \"e\"\n  - Positive/negative sign - \"+\"/\"-\"\n  - Decimal point - \".\"\n\nOf course, the context of these characters also matters in the input.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_65.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 有限状态机（Deterministic Finite Automaton, DFA）\n\n所谓“确定有穷状态”，必然需要我们自己动手构造出所有状态来，如下所示：\n\n0 初始无输入或者只有space的状态\n1 输入了数字之后的状态\n2 前面无数字，只输入了dot的状态\n3 输入了+/-状态\n4 前面有数字和有dot的状态\n5 'e' or 'E'输入后的状态\n6 输入e之后输入+/-的状态\n7 输入e后输入数字的状态\n8 前面有有效数输入之后，输入space的状态\n\n<div align=center>\n\t<img src=\"/images/leetcode_65_2.png\" width = \"500\" align=center/>\n</div>\n\n```python\nclass Solution:\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # 0invalid, 1space, 2sign, 3digit, 4dot, 5exponent, 6num_inputs\n        INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT = 0, 1, 2, 3, 4, 5\n\n        transitionTable=[[-1,  0,  3,  1,  2, -1],    #0 no input or just spaces \n                         [-1,  8, -1,  1,  4,  5],    #1 input is digits \n                         [-1, -1, -1,  4, -1, -1],    #2 no digits in front just Dot \n                         [-1, -1, -1,  1,  2, -1],    #3 sign \n                         [-1,  8, -1,  4, -1,  5],    #4 digits and dot in front \n                         [-1, -1,  6,  7, -1, -1],    #5 input 'e' or 'E' \n                         [-1, -1, -1,  7, -1, -1],    #6 after 'e' input sign \n                         [-1,  8, -1,  7, -1, -1],    #7 after 'e' input digits \n                         [-1,  8, -1, -1, -1, -1]]    #8 after valid input input space\n        state = 0\n        for c in s:\n            inputtype = INVALID\n            if c == ' ': \n                inputtype = SPACE\n            elif c == '-' or c == '+': \n                inputtype = SIGN\n            elif c.isdigit(): \n                inputtype = DIGIT\n            elif c == '.': \n                inputtype = DOT\n            elif c.lower() == 'e': \n                inputtype = EXPONENT\n            state = transitionTable[state][inputtype]\n            if state == -1: \n                return False\n\n        return state == 1 or state == 4 or state == 7 or state == 8\n```\n\n### 2. 正则表达式\n考察正则表达式的书写：\n1. 前后的空格 “(\\\\s\\*)”\n2. 整个数字的符号 “[+-]?”\n3. 纯小数或者带小数 ((\\\\.[0-9]+)|([0-9]+(\\\\.[0-9]\\*)?))，这部分可以单独出现，也可以是科学计数法的前部分。\n4. 科学计数法，(e[+-]?[0-9]+)?\n（**\\***表示匹配0至多次，**+**表示匹配1至多次，**?**表示匹配0至1次。）\n\n```python\nimport re \n\nclass Solution:\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        pattern = \"(\\\\s*)[+-]?((\\\\.[0-9]+)|([0-9]+(\\\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\\\s*)\"\n        \n        return bool(re.fullmatch(pattern, s))\n```\n\n### 3. 搞笑版\n直接调用 python 的类型转换函数`float()`，出现异常则不是有效的数字。\n\n```python\nclass Solution:\n    def isNumber(self, s):\n\t\t\"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        try:\n            float(s)\n        except:\n            return False\n\n        return True\n```\n","source":"_posts/leetcode-ValidNumber.md","raw":"---\ntitle: LeetCode_Valid Number\ndate: 2019-01-15 14:25:07\ncategories: LeetCode\ntags: \n  - hard\n  - math\n  - string\n---\n\n## [Valid Number](https://leetcode.com/problems/valid-number/)\n\nValidate if a given string can be interpreted as a decimal number.\n（字符串是否为有效数字）\n\n<!--more-->\n\n**Note:** It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:\n\n  - Numbers 0-9\n  - Exponent - \"e\"\n  - Positive/negative sign - \"+\"/\"-\"\n  - Decimal point - \".\"\n\nOf course, the context of these characters also matters in the input.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_65.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 有限状态机（Deterministic Finite Automaton, DFA）\n\n所谓“确定有穷状态”，必然需要我们自己动手构造出所有状态来，如下所示：\n\n0 初始无输入或者只有space的状态\n1 输入了数字之后的状态\n2 前面无数字，只输入了dot的状态\n3 输入了+/-状态\n4 前面有数字和有dot的状态\n5 'e' or 'E'输入后的状态\n6 输入e之后输入+/-的状态\n7 输入e后输入数字的状态\n8 前面有有效数输入之后，输入space的状态\n\n<div align=center>\n\t<img src=\"/images/leetcode_65_2.png\" width = \"500\" align=center/>\n</div>\n\n```python\nclass Solution:\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # 0invalid, 1space, 2sign, 3digit, 4dot, 5exponent, 6num_inputs\n        INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT = 0, 1, 2, 3, 4, 5\n\n        transitionTable=[[-1,  0,  3,  1,  2, -1],    #0 no input or just spaces \n                         [-1,  8, -1,  1,  4,  5],    #1 input is digits \n                         [-1, -1, -1,  4, -1, -1],    #2 no digits in front just Dot \n                         [-1, -1, -1,  1,  2, -1],    #3 sign \n                         [-1,  8, -1,  4, -1,  5],    #4 digits and dot in front \n                         [-1, -1,  6,  7, -1, -1],    #5 input 'e' or 'E' \n                         [-1, -1, -1,  7, -1, -1],    #6 after 'e' input sign \n                         [-1,  8, -1,  7, -1, -1],    #7 after 'e' input digits \n                         [-1,  8, -1, -1, -1, -1]]    #8 after valid input input space\n        state = 0\n        for c in s:\n            inputtype = INVALID\n            if c == ' ': \n                inputtype = SPACE\n            elif c == '-' or c == '+': \n                inputtype = SIGN\n            elif c.isdigit(): \n                inputtype = DIGIT\n            elif c == '.': \n                inputtype = DOT\n            elif c.lower() == 'e': \n                inputtype = EXPONENT\n            state = transitionTable[state][inputtype]\n            if state == -1: \n                return False\n\n        return state == 1 or state == 4 or state == 7 or state == 8\n```\n\n### 2. 正则表达式\n考察正则表达式的书写：\n1. 前后的空格 “(\\\\s\\*)”\n2. 整个数字的符号 “[+-]?”\n3. 纯小数或者带小数 ((\\\\.[0-9]+)|([0-9]+(\\\\.[0-9]\\*)?))，这部分可以单独出现，也可以是科学计数法的前部分。\n4. 科学计数法，(e[+-]?[0-9]+)?\n（**\\***表示匹配0至多次，**+**表示匹配1至多次，**?**表示匹配0至1次。）\n\n```python\nimport re \n\nclass Solution:\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        pattern = \"(\\\\s*)[+-]?((\\\\.[0-9]+)|([0-9]+(\\\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\\\s*)\"\n        \n        return bool(re.fullmatch(pattern, s))\n```\n\n### 3. 搞笑版\n直接调用 python 的类型转换函数`float()`，出现异常则不是有效的数字。\n\n```python\nclass Solution:\n    def isNumber(self, s):\n\t\t\"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        try:\n            float(s)\n        except:\n            return False\n\n        return True\n```\n","slug":"leetcode-ValidNumber","published":1,"updated":"2019-01-15T07:29:36.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht864009nkvpx06d704ji","content":"<h2 id=\"Valid-Number\"><a href=\"#Valid-Number\" class=\"headerlink\" title=\"Valid Number\"></a><a href=\"https://leetcode.com/problems/valid-number/\" target=\"_blank\" rel=\"noopener\">Valid Number</a></h2><p>Validate if a given string can be interpreted as a decimal number.<br>（字符串是否为有效数字）</p>\n<a id=\"more\"></a>\n<p><strong>Note:</strong> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</p>\n<ul>\n<li>Numbers 0-9</li>\n<li>Exponent - “e”</li>\n<li>Positive/negative sign - “+”/“-“</li>\n<li>Decimal point - “.”</li>\n</ul>\n<p>Of course, the context of these characters also matters in the input.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_65.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-有限状态机（Deterministic-Finite-Automaton-DFA）\"><a href=\"#1-有限状态机（Deterministic-Finite-Automaton-DFA）\" class=\"headerlink\" title=\"1. 有限状态机（Deterministic Finite Automaton, DFA）\"></a>1. 有限状态机（Deterministic Finite Automaton, DFA）</h3><p>所谓“确定有穷状态”，必然需要我们自己动手构造出所有状态来，如下所示：</p>\n<p>0 初始无输入或者只有space的状态<br>1 输入了数字之后的状态<br>2 前面无数字，只输入了dot的状态<br>3 输入了+/-状态<br>4 前面有数字和有dot的状态<br>5 ‘e’ or ‘E’输入后的状态<br>6 输入e之后输入+/-的状态<br>7 输入e后输入数字的状态<br>8 前面有有效数输入之后，输入space的状态</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_65_2.png\" width=\"500\" align=\"center/\"><br></div>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNumber</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># 0invalid, 1space, 2sign, 3digit, 4dot, 5exponent, 6num_inputs</span></span><br><span class=\"line\">        INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">        transitionTable=[[<span class=\"number\">-1</span>,  <span class=\"number\">0</span>,  <span class=\"number\">3</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#0 no input or just spaces </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">4</span>,  <span class=\"number\">5</span>],    <span class=\"comment\">#1 input is digits </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">4</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#2 no digits in front just Dot </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#3 sign </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>,  <span class=\"number\">4</span>, <span class=\"number\">-1</span>,  <span class=\"number\">5</span>],    <span class=\"comment\">#4 digits and dot in front </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">6</span>,  <span class=\"number\">7</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#5 input 'e' or 'E' </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">7</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#6 after 'e' input sign </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>,  <span class=\"number\">7</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#7 after 'e' input digits </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>]]    <span class=\"comment\">#8 after valid input input space</span></span><br><span class=\"line\">        state = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            inputtype = INVALID</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == <span class=\"string\">' '</span>: </span><br><span class=\"line\">                inputtype = SPACE</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'-'</span> <span class=\"keyword\">or</span> c == <span class=\"string\">'+'</span>: </span><br><span class=\"line\">                inputtype = SIGN</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c.isdigit(): </span><br><span class=\"line\">                inputtype = DIGIT</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'.'</span>: </span><br><span class=\"line\">                inputtype = DOT</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c.lower() == <span class=\"string\">'e'</span>: </span><br><span class=\"line\">                inputtype = EXPONENT</span><br><span class=\"line\">            state = transitionTable[state][inputtype]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> state == <span class=\"number\">-1</span>: </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> state == <span class=\"number\">1</span> <span class=\"keyword\">or</span> state == <span class=\"number\">4</span> <span class=\"keyword\">or</span> state == <span class=\"number\">7</span> <span class=\"keyword\">or</span> state == <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-正则表达式\"><a href=\"#2-正则表达式\" class=\"headerlink\" title=\"2. 正则表达式\"></a>2. 正则表达式</h3><p>考察正则表达式的书写：</p>\n<ol>\n<li>前后的空格 “(\\s*)”</li>\n<li>整个数字的符号 “[+-]?”</li>\n<li>纯小数或者带小数 ((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))，这部分可以单独出现，也可以是科学计数法的前部分。</li>\n<li>科学计数法，(e[+-]?[0-9]+)?<br>（<strong>*</strong>表示匹配0至多次，<strong>+</strong>表示匹配1至多次，<strong>?</strong>表示匹配0至1次。）</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNumber</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        pattern = <span class=\"string\">\"(\\\\s*)[+-]?((\\\\.[0-9]+)|([0-9]+(\\\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\\\s*)\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bool(re.fullmatch(pattern, s))</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-搞笑版\"><a href=\"#3-搞笑版\" class=\"headerlink\" title=\"3. 搞笑版\"></a>3. 搞笑版</h3><p>直接调用 python 的类型转换函数<code>float()</code>，出现异常则不是有效的数字。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNumber</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            float(s)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Valid-Number\"><a href=\"#Valid-Number\" class=\"headerlink\" title=\"Valid Number\"></a><a href=\"https://leetcode.com/problems/valid-number/\" target=\"_blank\" rel=\"noopener\">Valid Number</a></h2><p>Validate if a given string can be interpreted as a decimal number.<br>（字符串是否为有效数字）</p>","more":"<p><strong>Note:</strong> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</p>\n<ul>\n<li>Numbers 0-9</li>\n<li>Exponent - “e”</li>\n<li>Positive/negative sign - “+”/“-“</li>\n<li>Decimal point - “.”</li>\n</ul>\n<p>Of course, the context of these characters also matters in the input.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_65.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-有限状态机（Deterministic-Finite-Automaton-DFA）\"><a href=\"#1-有限状态机（Deterministic-Finite-Automaton-DFA）\" class=\"headerlink\" title=\"1. 有限状态机（Deterministic Finite Automaton, DFA）\"></a>1. 有限状态机（Deterministic Finite Automaton, DFA）</h3><p>所谓“确定有穷状态”，必然需要我们自己动手构造出所有状态来，如下所示：</p>\n<p>0 初始无输入或者只有space的状态<br>1 输入了数字之后的状态<br>2 前面无数字，只输入了dot的状态<br>3 输入了+/-状态<br>4 前面有数字和有dot的状态<br>5 ‘e’ or ‘E’输入后的状态<br>6 输入e之后输入+/-的状态<br>7 输入e后输入数字的状态<br>8 前面有有效数输入之后，输入space的状态</p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_65_2.png\" width=\"500\" align=\"center/\"><br></div>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNumber</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># 0invalid, 1space, 2sign, 3digit, 4dot, 5exponent, 6num_inputs</span></span><br><span class=\"line\">        INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">        transitionTable=[[<span class=\"number\">-1</span>,  <span class=\"number\">0</span>,  <span class=\"number\">3</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#0 no input or just spaces </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">4</span>,  <span class=\"number\">5</span>],    <span class=\"comment\">#1 input is digits </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">4</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#2 no digits in front just Dot </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#3 sign </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>,  <span class=\"number\">4</span>, <span class=\"number\">-1</span>,  <span class=\"number\">5</span>],    <span class=\"comment\">#4 digits and dot in front </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">6</span>,  <span class=\"number\">7</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#5 input 'e' or 'E' </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>,  <span class=\"number\">7</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#6 after 'e' input sign </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>,  <span class=\"number\">7</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>],    <span class=\"comment\">#7 after 'e' input digits </span></span><br><span class=\"line\">                         [<span class=\"number\">-1</span>,  <span class=\"number\">8</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>]]    <span class=\"comment\">#8 after valid input input space</span></span><br><span class=\"line\">        state = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            inputtype = INVALID</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == <span class=\"string\">' '</span>: </span><br><span class=\"line\">                inputtype = SPACE</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'-'</span> <span class=\"keyword\">or</span> c == <span class=\"string\">'+'</span>: </span><br><span class=\"line\">                inputtype = SIGN</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c.isdigit(): </span><br><span class=\"line\">                inputtype = DIGIT</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'.'</span>: </span><br><span class=\"line\">                inputtype = DOT</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c.lower() == <span class=\"string\">'e'</span>: </span><br><span class=\"line\">                inputtype = EXPONENT</span><br><span class=\"line\">            state = transitionTable[state][inputtype]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> state == <span class=\"number\">-1</span>: </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> state == <span class=\"number\">1</span> <span class=\"keyword\">or</span> state == <span class=\"number\">4</span> <span class=\"keyword\">or</span> state == <span class=\"number\">7</span> <span class=\"keyword\">or</span> state == <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-正则表达式\"><a href=\"#2-正则表达式\" class=\"headerlink\" title=\"2. 正则表达式\"></a>2. 正则表达式</h3><p>考察正则表达式的书写：</p>\n<ol>\n<li>前后的空格 “(\\s*)”</li>\n<li>整个数字的符号 “[+-]?”</li>\n<li>纯小数或者带小数 ((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))，这部分可以单独出现，也可以是科学计数法的前部分。</li>\n<li>科学计数法，(e[+-]?[0-9]+)?<br>（<strong>*</strong>表示匹配0至多次，<strong>+</strong>表示匹配1至多次，<strong>?</strong>表示匹配0至1次。）</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNumber</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        pattern = <span class=\"string\">\"(\\\\s*)[+-]?((\\\\.[0-9]+)|([0-9]+(\\\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\\\s*)\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bool(re.fullmatch(pattern, s))</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-搞笑版\"><a href=\"#3-搞笑版\" class=\"headerlink\" title=\"3. 搞笑版\"></a>3. 搞笑版</h3><p>直接调用 python 的类型转换函数<code>float()</code>，出现异常则不是有效的数字。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNumber</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            float(s)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Valid Parentheses","date":"2018-12-06T07:44:13.000Z","_content":"\n## [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n（判断有效的括号对）\n\n<!--more-->\n\nAn input string is valid if:\n - Open brackets must be closed by the same type of brackets.\n - Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_20.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 栈匹配\n括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {')': '(', ']': '[', '}': '{'}\n        \n        for ch in s:\n            if ch in mapping:\n                top = stack.pop() if stack else '#'\n                if top != mapping[ch]:\n                    return False\n            else:\n                stack.append(ch)\n                \n        return not stack\n```\n\n### 2. 栈匹配\n后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for c in s:\n            if c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif c == '(':\n                stack.append(')')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack\n```","source":"_posts/leetcode-ValidParentheses.md","raw":"---\ntitle: LeetCode_Valid Parentheses\ndate: 2018-12-06 15:44:13\ncategories: LeetCode\ntags: \n  - easy\n  - string\n  - stack\n---\n\n## [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n（判断有效的括号对）\n\n<!--more-->\n\nAn input string is valid if:\n - Open brackets must be closed by the same type of brackets.\n - Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_20.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 栈匹配\n括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {')': '(', ']': '[', '}': '{'}\n        \n        for ch in s:\n            if ch in mapping:\n                top = stack.pop() if stack else '#'\n                if top != mapping[ch]:\n                    return False\n            else:\n                stack.append(ch)\n                \n        return not stack\n```\n\n### 2. 栈匹配\n后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for c in s:\n            if c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif c == '(':\n                stack.append(')')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack\n```","slug":"leetcode-ValidParentheses","published":1,"updated":"2018-12-06T07:58:38.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht866009rkvpxtcn79u5s","content":"<h2 id=\"Valid-Parentheses\"><a href=\"#Valid-Parentheses\" class=\"headerlink\" title=\"Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>（判断有效的括号对）</p>\n<a id=\"more\"></a>\n<p>An input string is valid if:</p>\n<ul>\n<li>Open brackets must be closed by the same type of brackets.</li>\n<li>Open brackets must be closed in the correct order.</li>\n</ul>\n<p>Note that an empty string is also considered valid.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_20.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-栈匹配\"><a href=\"#1-栈匹配\" class=\"headerlink\" title=\"1. 栈匹配\"></a>1. 栈匹配</h3><p>括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        mapping = &#123;<span class=\"string\">')'</span>: <span class=\"string\">'('</span>, <span class=\"string\">']'</span>: <span class=\"string\">'['</span>, <span class=\"string\">'&#125;'</span>: <span class=\"string\">'&#123;'</span>&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> mapping:</span><br><span class=\"line\">                top = stack.pop() <span class=\"keyword\">if</span> stack <span class=\"keyword\">else</span> <span class=\"string\">'#'</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> top != mapping[ch]:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.append(ch)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈匹配\"><a href=\"#2-栈匹配\" class=\"headerlink\" title=\"2. 栈匹配\"></a>2. 栈匹配</h3><p>后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == <span class=\"string\">'['</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">']'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">'&#125;'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">')'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> c != stack.pop():</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Valid-Parentheses\"><a href=\"#Valid-Parentheses\" class=\"headerlink\" title=\"Valid Parentheses\"></a><a href=\"https://leetcode.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">Valid Parentheses</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>（判断有效的括号对）</p>","more":"<p>An input string is valid if:</p>\n<ul>\n<li>Open brackets must be closed by the same type of brackets.</li>\n<li>Open brackets must be closed in the correct order.</li>\n</ul>\n<p>Note that an empty string is also considered valid.</p>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_20.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-栈匹配\"><a href=\"#1-栈匹配\" class=\"headerlink\" title=\"1. 栈匹配\"></a>1. 栈匹配</h3><p>括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        mapping = &#123;<span class=\"string\">')'</span>: <span class=\"string\">'('</span>, <span class=\"string\">']'</span>: <span class=\"string\">'['</span>, <span class=\"string\">'&#125;'</span>: <span class=\"string\">'&#123;'</span>&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> mapping:</span><br><span class=\"line\">                top = stack.pop() <span class=\"keyword\">if</span> stack <span class=\"keyword\">else</span> <span class=\"string\">'#'</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> top != mapping[ch]:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.append(ch)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-栈匹配\"><a href=\"#2-栈匹配\" class=\"headerlink\" title=\"2. 栈匹配\"></a>2. 栈匹配</h3><p>后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == <span class=\"string\">'['</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">']'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">'&#125;'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.append(<span class=\"string\">')'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> c != stack.pop():</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Validate Binary Search Tree","date":"2019-02-27T13:10:27.000Z","_content":"\n## [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\n\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n（判断是否为二叉排序树）\n\nAssume a BST is defined as follows:\n1. The left subtree of a node contains only nodes with keys less than the node's key.\n2. The right subtree of a node contains only nodes with keys greater than the node's key.\n3. Both the left and right subtrees must also be binary search trees.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_98.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n需要注意的是，在判断子树是否为二叉排序树时，我们需要考虑子树上的节点都小于（或大于）根节点，因此需要传入阈值。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        def _isValidBST(root, _min=float('-inf'), _max=float('inf')):\n            if not root:\n                return True\n\n            if root.val <= _min or root.val >= _max:\n                return False\n\n            return _isValidBST(root.left, _min, root.val) and \\\n                    _isValidBST(root.right, root.val, _max)\n\n        return _isValidBST(root)\n```\n\n### 2. DFS & Inorder（中序遍历）\n首先对二叉树进行中序遍历，然后对遍历的结果判断是否是一个完全递增的序列（不可相等），具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution: \n    def isValidBST(self, root: TreeNode) -> bool:\n        def dfs(root):\n            if not root:\n                return\n            dfs(root.left)\n            self.travel.append(root.val)\n            dfs(root.right)\n                \n        self.travel = []\n        dfs(root)\n\n        for i in range(len(self.travel) - 1):\n            if self.travel[i+1] <= self.travel[i]:\n                return False\n        \n        return True\n```\n","source":"_posts/leetcode-ValidateBinarySearchTree.md","raw":"---\ntitle: LeetCode_Validate Binary Search Tree\ndate: 2019-02-27 21:10:27\ncategories: LeetCode\ntags: \n  - medium\n  - tree\n  - dfs\n---\n\n## [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\n\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n（判断是否为二叉排序树）\n\nAssume a BST is defined as follows:\n1. The left subtree of a node contains only nodes with keys less than the node's key.\n2. The right subtree of a node contains only nodes with keys greater than the node's key.\n3. Both the left and right subtrees must also be binary search trees.\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_98.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 递归\n需要注意的是，在判断子树是否为二叉排序树时，我们需要考虑子树上的节点都小于（或大于）根节点，因此需要传入阈值。具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        def _isValidBST(root, _min=float('-inf'), _max=float('inf')):\n            if not root:\n                return True\n\n            if root.val <= _min or root.val >= _max:\n                return False\n\n            return _isValidBST(root.left, _min, root.val) and \\\n                    _isValidBST(root.right, root.val, _max)\n\n        return _isValidBST(root)\n```\n\n### 2. DFS & Inorder（中序遍历）\n首先对二叉树进行中序遍历，然后对遍历的结果判断是否是一个完全递增的序列（不可相等），具体实现方法如下：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution: \n    def isValidBST(self, root: TreeNode) -> bool:\n        def dfs(root):\n            if not root:\n                return\n            dfs(root.left)\n            self.travel.append(root.val)\n            dfs(root.right)\n                \n        self.travel = []\n        dfs(root)\n\n        for i in range(len(self.travel) - 1):\n            if self.travel[i+1] <= self.travel[i]:\n                return False\n        \n        return True\n```\n","slug":"leetcode-ValidateBinarySearchTree","published":1,"updated":"2019-02-27T14:20:30.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht868009ukvpxgy60arvn","content":"<h2 id=\"Validate-Binary-Search-Tree\"><a href=\"#Validate-Binary-Search-Tree\" class=\"headerlink\" title=\"Validate Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Validate Binary Search Tree</a></h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>（判断是否为二叉排序树）</p>\n<p>Assume a BST is defined as follows:</p>\n<ol>\n<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ol>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_98.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>需要注意的是，在判断子树是否为二叉排序树时，我们需要考虑子树上的节点都小于（或大于）根节点，因此需要传入阈值。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_isValidBST</span><span class=\"params\">(root, _min=float<span class=\"params\">(<span class=\"string\">'-inf'</span>)</span>, _max=float<span class=\"params\">(<span class=\"string\">'inf'</span>)</span>)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.val &lt;= _min <span class=\"keyword\">or</span> root.val &gt;= _max:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> _isValidBST(root.left, _min, root.val) <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">                    _isValidBST(root.right, root.val, _max)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _isValidBST(root)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-DFS-amp-Inorder（中序遍历）\"><a href=\"#2-DFS-amp-Inorder（中序遍历）\" class=\"headerlink\" title=\"2. DFS &amp; Inorder（中序遍历）\"></a>2. DFS &amp; Inorder（中序遍历）</h3><p>首先对二叉树进行中序遍历，然后对遍历的结果判断是否是一个完全递增的序列（不可相等），具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            dfs(root.left)</span><br><span class=\"line\">            self.travel.append(root.val)</span><br><span class=\"line\">            dfs(root.right)</span><br><span class=\"line\">                </span><br><span class=\"line\">        self.travel = []</span><br><span class=\"line\">        dfs(root)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(self.travel) - <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.travel[i+<span class=\"number\">1</span>] &lt;= self.travel[i]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Validate-Binary-Search-Tree\"><a href=\"#Validate-Binary-Search-Tree\" class=\"headerlink\" title=\"Validate Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">Validate Binary Search Tree</a></h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>（判断是否为二叉排序树）</p>\n<p>Assume a BST is defined as follows:</p>\n<ol>\n<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ol>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_98.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h3><p>需要注意的是，在判断子树是否为二叉排序树时，我们需要考虑子树上的节点都小于（或大于）根节点，因此需要传入阈值。具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_isValidBST</span><span class=\"params\">(root, _min=float<span class=\"params\">(<span class=\"string\">'-inf'</span>)</span>, _max=float<span class=\"params\">(<span class=\"string\">'inf'</span>)</span>)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.val &lt;= _min <span class=\"keyword\">or</span> root.val &gt;= _max:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> _isValidBST(root.left, _min, root.val) <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">                    _isValidBST(root.right, root.val, _max)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _isValidBST(root)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-DFS-amp-Inorder（中序遍历）\"><a href=\"#2-DFS-amp-Inorder（中序遍历）\" class=\"headerlink\" title=\"2. DFS &amp; Inorder（中序遍历）\"></a>2. DFS &amp; Inorder（中序遍历）</h3><p>首先对二叉树进行中序遍历，然后对遍历的结果判断是否是一个完全递增的序列（不可相等），具体实现方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            dfs(root.left)</span><br><span class=\"line\">            self.travel.append(root.val)</span><br><span class=\"line\">            dfs(root.right)</span><br><span class=\"line\">                </span><br><span class=\"line\">        self.travel = []</span><br><span class=\"line\">        dfs(root)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(self.travel) - <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.travel[i+<span class=\"number\">1</span>] &lt;= self.travel[i]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Valid Sudoku","date":"2018-12-21T12:56:51.000Z","_content":"\n## [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)\n\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.\n（数独盘有效性判断）\n<!--more-->\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n**Note:**\n1. A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n2. Only the filled cells need to be validated according to the mentioned rules.\n3. The given board contain only digits 1-9 and the character '.'.\n4. The given board size is always 9x9.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_36.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 依次check\n根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。\n\n```python\nclass Solution:\n    def isListValid(self, list):\n        clean = [i for i in list if i != '.']\n        s = set(clean)\n        return len(s) == len(clean)\n    \n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # row check \n        for list in board:\n            if self.isListValid(list) == False:\n                return False\n        \n        # column check\n        for list in zip(*board):\n            if self.isListValid(list) == False:\n                return False\n            \n        # square check\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                list = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if self.isListValid(list) == False:\n                    return False\n        return True\n```\n\n\n### 2. 使用Hash Map\n只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        dict = {}\n        \n        for i, row in enumerate(board):\n            for j, ch in enumerate(row):\n                if ch == '.':\n                    continue\n                if ch in dict:\n                    result_index = dict[ch]\n                    for index in result_index:\n                        if index[0] == i or index[1] == j or index[2] == (i//3, j//3):\n                            return False\n                    dict[ch].append([i, j, (i//3, j//3)])\n                else:\n                    dict[ch] = [[i, j, (i//3, j//3)]]\n\n        return True\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-ValidSudoku.md","raw":"---\ntitle: LeetCode_Valid Sudoku\ndate: 2018-12-21 20:56:51\ncategories: LeetCode\ntags: \n  - medium\n  - hash table\n---\n\n## [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)\n\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.\n（数独盘有效性判断）\n<!--more-->\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n<div align=center>\n\t<img src=\"/images/leetcode_36_1.png\" width = \"300\" align=center/>\n</div>\n\n**Note:**\n1. A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n2. Only the filled cells need to be validated according to the mentioned rules.\n3. The given board contain only digits 1-9 and the character '.'.\n4. The given board size is always 9x9.\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_36.png\" width = \"500\" align=center/>\n</div>\n\n\n### 1. 依次check\n根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。\n\n```python\nclass Solution:\n    def isListValid(self, list):\n        clean = [i for i in list if i != '.']\n        s = set(clean)\n        return len(s) == len(clean)\n    \n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # row check \n        for list in board:\n            if self.isListValid(list) == False:\n                return False\n        \n        # column check\n        for list in zip(*board):\n            if self.isListValid(list) == False:\n                return False\n            \n        # square check\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                list = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if self.isListValid(list) == False:\n                    return False\n        return True\n```\n\n\n### 2. 使用Hash Map\n只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：\n\n```python\nclass Solution:\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        dict = {}\n        \n        for i, row in enumerate(board):\n            for j, ch in enumerate(row):\n                if ch == '.':\n                    continue\n                if ch in dict:\n                    result_index = dict[ch]\n                    for index in result_index:\n                        if index[0] == i or index[1] == j or index[2] == (i//3, j//3):\n                            return False\n                    dict[ch].append([i, j, (i//3, j//3)])\n                else:\n                    dict[ch] = [[i, j, (i//3, j//3)]]\n\n        return True\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-ValidSudoku","published":1,"updated":"2019-02-25T12:51:41.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht869009ykvpxxewyzxhn","content":"<h2 id=\"Valid-Sudoku\"><a href=\"#Valid-Sudoku\" class=\"headerlink\" title=\"Valid Sudoku\"></a><a href=\"https://leetcode.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">Valid Sudoku</a></h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.<br>（数独盘有效性判断）<br><a id=\"more\"></a></p>\n<ol>\n<li>Each row must contain the digits 1-9 without repetition.</li>\n<li>Each column must contain the digits 1-9 without repetition.</li>\n<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits 1-9 without repetition.</li>\n</ol>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n<li>Only the filled cells need to be validated according to the mentioned rules.</li>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-依次check\"><a href=\"#1-依次check\" class=\"headerlink\" title=\"1. 依次check\"></a>1. 依次check</h3><p>根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isListValid</span><span class=\"params\">(self, list)</span>:</span></span><br><span class=\"line\">        clean = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list <span class=\"keyword\">if</span> i != <span class=\"string\">'.'</span>]</span><br><span class=\"line\">        s = set(clean)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(s) == len(clean)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># row check </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> board:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># column check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> zip(*board):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># square check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                list = [board[x][y] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(i, i + <span class=\"number\">3</span>) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(j, j + <span class=\"number\">3</span>)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用Hash-Map\"><a href=\"#2-使用Hash-Map\" class=\"headerlink\" title=\"2. 使用Hash Map\"></a>2. 使用Hash Map</h3><p>只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j, ch <span class=\"keyword\">in</span> enumerate(row):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result_index = dict[ch]</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> result_index:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> index[<span class=\"number\">0</span>] == i <span class=\"keyword\">or</span> index[<span class=\"number\">1</span>] == j <span class=\"keyword\">or</span> index[<span class=\"number\">2</span>] == (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>):</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">                    dict[ch].append([i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[ch] = [[i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)]]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Valid-Sudoku\"><a href=\"#Valid-Sudoku\" class=\"headerlink\" title=\"Valid Sudoku\"></a><a href=\"https://leetcode.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">Valid Sudoku</a></h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.<br>（数独盘有效性判断）<br>","more":"</p>\n<ol>\n<li>Each row must contain the digits 1-9 without repetition.</li>\n<li>Each column must contain the digits 1-9 without repetition.</li>\n<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits 1-9 without repetition.</li>\n</ol>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36_1.png\" width=\"300\" align=\"center/\"><br></div>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n<li>Only the filled cells need to be validated according to the mentioned rules.</li>\n<li>The given board contain only digits 1-9 and the character ‘.’.</li>\n<li>The given board size is always 9x9.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_36.png\" width=\"500\" align=\"center/\"><br></div>\n\n\n<h3 id=\"1-依次check\"><a href=\"#1-依次check\" class=\"headerlink\" title=\"1. 依次check\"></a>1. 依次check</h3><p>根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isListValid</span><span class=\"params\">(self, list)</span>:</span></span><br><span class=\"line\">        clean = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list <span class=\"keyword\">if</span> i != <span class=\"string\">'.'</span>]</span><br><span class=\"line\">        s = set(clean)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(s) == len(clean)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># row check </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> board:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># column check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> zip(*board):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># square check</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                list = [board[x][y] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(i, i + <span class=\"number\">3</span>) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(j, j + <span class=\"number\">3</span>)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.isListValid(list) == <span class=\"keyword\">False</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用Hash-Map\"><a href=\"#2-使用Hash-Map\" class=\"headerlink\" title=\"2. 使用Hash Map\"></a>2. 使用Hash Map</h3><p>只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type board: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dict = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j, ch <span class=\"keyword\">in</span> enumerate(row):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ch <span class=\"keyword\">in</span> dict:</span><br><span class=\"line\">                    result_index = dict[ch]</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> result_index:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> index[<span class=\"number\">0</span>] == i <span class=\"keyword\">or</span> index[<span class=\"number\">1</span>] == j <span class=\"keyword\">or</span> index[<span class=\"number\">2</span>] == (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>):</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">                    dict[ch].append([i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dict[ch] = [[i, j, (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>)]]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Wildcard Matching","date":"2019-01-06T07:49:16.000Z","_content":"\n## [Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)\n\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for “?” and “\\*”.\n(通配符匹配)\n\n<!--more-->\n\n“?” Matches any single character.\n“\\*” Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n**Note:**\n s could be empty and contains only lowercase letters a-z.\n p could be empty and contains only lowercase letters a-z, and characters like “?” or “\\*”.\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_44.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n这个题跟之前的字符串匹配类似，不同点在于之前 “\\*” 可以匹配的是零个至多个**连续的字符**，而这道题目中的 “\\*” 是可以匹配**任意的字符串**。我们还是可以基于动态规划的思想来解决这道题目，具体解法如下。其中在 pattern 中第 j 个元素为 “\\*” 时，分为两种情况：\n1. 当前 “\\*” 表示为空串，则 dp[i][j] = dp[i-1][j]\n2. 当前 “\\*” 匹配当前的第 i 个字符 s[i-1], 则 dp[i][j] = dp[i][j-1] \n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s = len(s)\n        len_p = len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n\n        dp[0][0] = True\n        for i in range(len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                else:\n                    dp[i][j] = i>=1 and dp[i-1][j-1] and (p[j-1] in {s[i-1], '?'})\n\n        return dp[len_s][len_p]\n```","source":"_posts/leetcode-WildcardMatching.md","raw":"---\ntitle: LeetCode_Wildcard Matching\ndate: 2019-01-06 15:49:16\ncategories: LeetCode\ntags: \n  - hard\n  - string\n  - dynamic programming\n  - back tracking\n  - greedy\n---\n\n## [Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)\n\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for “?” and “\\*”.\n(通配符匹配)\n\n<!--more-->\n\n“?” Matches any single character.\n“\\*” Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n**Note:**\n s could be empty and contains only lowercase letters a-z.\n p could be empty and contains only lowercase letters a-z, and characters like “?” or “\\*”.\n\n**Example:**\n<div align=center>\n\t<img src=\"/images/leetcode_44.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 动态规划\n\n这个题跟之前的字符串匹配类似，不同点在于之前 “\\*” 可以匹配的是零个至多个**连续的字符**，而这道题目中的 “\\*” 是可以匹配**任意的字符串**。我们还是可以基于动态规划的思想来解决这道题目，具体解法如下。其中在 pattern 中第 j 个元素为 “\\*” 时，分为两种情况：\n1. 当前 “\\*” 表示为空串，则 dp[i][j] = dp[i-1][j]\n2. 当前 “\\*” 匹配当前的第 i 个字符 s[i-1], 则 dp[i][j] = dp[i][j-1] \n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s = len(s)\n        len_p = len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n\n        dp[0][0] = True\n        for i in range(len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                else:\n                    dp[i][j] = i>=1 and dp[i-1][j-1] and (p[j-1] in {s[i-1], '?'})\n\n        return dp[len_s][len_p]\n```","slug":"leetcode-WildcardMatching","published":1,"updated":"2019-01-09T04:05:37.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86b00a1kvpx4kr7239k","content":"<h2 id=\"Wildcard-Matching\"><a href=\"#Wildcard-Matching\" class=\"headerlink\" title=\"Wildcard Matching\"></a><a href=\"https://leetcode.com/problems/wildcard-matching/\" target=\"_blank\" rel=\"noopener\">Wildcard Matching</a></h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for “?” and “*”.<br>(通配符匹配)</p>\n<a id=\"more\"></a>\n<p>“?” Matches any single character.<br>“*” Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>\n<p><strong>Note:</strong><br> s could be empty and contains only lowercase letters a-z.<br> p could be empty and contains only lowercase letters a-z, and characters like “?” or “*”.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_44.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这个题跟之前的字符串匹配类似，不同点在于之前 “*” 可以匹配的是零个至多个<strong>连续的字符</strong>，而这道题目中的 “*” 是可以匹配<strong>任意的字符串</strong>。我们还是可以基于动态规划的思想来解决这道题目，具体解法如下。其中在 pattern 中第 j 个元素为 “*” 时，分为两种情况：</p>\n<ol>\n<li>当前 “*” 表示为空串，则 dp[i][j] = dp[i-1][j]</li>\n<li>当前 “*” 匹配当前的第 i 个字符 s[i-1], 则 dp[i][j] = dp[i][j-1] </li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        len_p = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len_p + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len_p + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">or</span> dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = i&gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> (p[j<span class=\"number\">-1</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'?'</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_s][len_p]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Wildcard-Matching\"><a href=\"#Wildcard-Matching\" class=\"headerlink\" title=\"Wildcard Matching\"></a><a href=\"https://leetcode.com/problems/wildcard-matching/\" target=\"_blank\" rel=\"noopener\">Wildcard Matching</a></h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for “?” and “*”.<br>(通配符匹配)</p>","more":"<p>“?” Matches any single character.<br>“*” Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>\n<p><strong>Note:</strong><br> s could be empty and contains only lowercase letters a-z.<br> p could be empty and contains only lowercase letters a-z, and characters like “?” or “*”.</p>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_44.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><p>这个题跟之前的字符串匹配类似，不同点在于之前 “*” 可以匹配的是零个至多个<strong>连续的字符</strong>，而这道题目中的 “*” 是可以匹配<strong>任意的字符串</strong>。我们还是可以基于动态规划的思想来解决这道题目，具体解法如下。其中在 pattern 中第 j 个元素为 “*” 时，分为两种情况：</p>\n<ol>\n<li>当前 “*” 表示为空串，则 dp[i][j] = dp[i-1][j]</li>\n<li>当前 “*” 匹配当前的第 i 个字符 s[i-1], 则 dp[i][j] = dp[i][j-1] </li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type p: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        len_s = len(s)</span><br><span class=\"line\">        len_p = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"keyword\">False</span>] * (len_p + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len_p + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">or</span> dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = i&gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> (p[j<span class=\"number\">-1</span>] <span class=\"keyword\">in</span> &#123;s[i<span class=\"number\">-1</span>], <span class=\"string\">'?'</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_s][len_p]</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Zig Zag Conversion","date":"2018-11-26T06:49:30.000Z","_content":"\n## [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\nAnd then read line by line: \"PAHNAPLSIIGYIR\".\n（字符串ZIGZAG之后按行输出）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_6.png\" width = \"500\" align=center/>\n</div>\n\n### 规律\n根据ZigZag的规律，当行数为 numRows 时：\n  - ZigZag的第 i 行字符的序号为 \\\\(k \\* (2 \\* numRows - 2) + i \\\\) ；\n  - ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\\\((k + 1) \\* (2 \\* numRows - 2) - i \\\\)；\n其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n       \n        if numRows == 1:\n            return s\n        \n        result = \"\"\n        n = len(s)\n        add = 2 * numRows - 2 \n        \n        for i in range(numRows):\n            for j in range(0, n-i, add):\n                result += s[i+j]\n                if (i != 0 and i != numRows-1 and j+add-i<n):\n                    result += s[j+add-i]\n        return result\n```\n\n**注**：这里需要特别注意的是保证 \\\\(add = 2 * numRows - 2\\\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。\n\n\n### 变步长遍历字符串\n这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        if numRows == 1 or numRows >= n:\n            return s\n        \n        group_list = [\"\"] * numRows\n\n        index = 0\n        step = 1\n        for char in s:\n            group_list[index] += char\n            \n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n           \n        return \"\".join(group_list)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/leetcode-ZigZagConversion.md","raw":"---\ntitle: LeetCode_Zig Zag Conversion\ndate: 2018-11-26 14:49:30\ncategories: LeetCode\ntags: \n  - medium\n  - string\n---\n\n## [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\nAnd then read line by line: \"PAHNAPLSIIGYIR\".\n（字符串ZIGZAG之后按行输出）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_6.png\" width = \"500\" align=center/>\n</div>\n\n### 规律\n根据ZigZag的规律，当行数为 numRows 时：\n  - ZigZag的第 i 行字符的序号为 \\\\(k \\* (2 \\* numRows - 2) + i \\\\) ；\n  - ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\\\((k + 1) \\* (2 \\* numRows - 2) - i \\\\)；\n其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n       \n        if numRows == 1:\n            return s\n        \n        result = \"\"\n        n = len(s)\n        add = 2 * numRows - 2 \n        \n        for i in range(numRows):\n            for j in range(0, n-i, add):\n                result += s[i+j]\n                if (i != 0 and i != numRows-1 and j+add-i<n):\n                    result += s[j+add-i]\n        return result\n```\n\n**注**：这里需要特别注意的是保证 \\\\(add = 2 * numRows - 2\\\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。\n\n\n### 变步长遍历字符串\n这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\\\(O(n)\\\\)，具体实现过程如下：\n```python\nclass Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        if numRows == 1 or numRows >= n:\n            return s\n        \n        group_list = [\"\"] * numRows\n\n        index = 0\n        step = 1\n        for char in s:\n            group_list[index] += char\n            \n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n           \n        return \"\".join(group_list)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"leetcode-ZigZagConversion","published":1,"updated":"2018-11-27T06:25:29.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86c00a5kvpxx87e271e","content":"<h2 id=\"ZigZag-Conversion\"><a href=\"#ZigZag-Conversion\" class=\"headerlink\" title=\"ZigZag Conversion\"></a><a href=\"https://leetcode.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure></p>\n<p>And then read line by line: “PAHNAPLSIIGYIR”.<br>（字符串ZIGZAG之后按行输出）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_6.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"规律\"><a href=\"#规律\" class=\"headerlink\" title=\"规律\"></a>规律</h3><p>根据ZigZag的规律，当行数为 numRows 时：</p>\n<ul>\n<li>ZigZag的第 i 行字符的序号为 \\(k * (2 * numRows - 2) + i \\) ；</li>\n<li>ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\((k + 1) * (2 * numRows - 2) - i \\)；<br>其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        add = <span class=\"number\">2</span> * numRows - <span class=\"number\">2</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numRows):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n-i, add):</span><br><span class=\"line\">                result += s[i+j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> i != numRows<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j+add-i&lt;n):</span><br><span class=\"line\">                    result += s[j+add-i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong>：这里需要特别注意的是保证 \\(add = 2 * numRows - 2\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。</p>\n<h3 id=\"变步长遍历字符串\"><a href=\"#变步长遍历字符串\" class=\"headerlink\" title=\"变步长遍历字符串\"></a>变步长遍历字符串</h3><p>这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span> <span class=\"keyword\">or</span> numRows &gt;= n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        group_list = [<span class=\"string\">\"\"</span>] * numRows</span><br><span class=\"line\"></span><br><span class=\"line\">        index = <span class=\"number\">0</span></span><br><span class=\"line\">        step = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            group_list[index] += char</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> index == <span class=\"number\">0</span>:</span><br><span class=\"line\">                step = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> index == numRows - <span class=\"number\">1</span>:</span><br><span class=\"line\">                step = <span class=\"number\">-1</span></span><br><span class=\"line\">            index += step</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.join(group_list)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ZigZag-Conversion\"><a href=\"#ZigZag-Conversion\" class=\"headerlink\" title=\"ZigZag Conversion\"></a><a href=\"https://leetcode.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure></p>\n<p>And then read line by line: “PAHNAPLSIIGYIR”.<br>（字符串ZIGZAG之后按行输出）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_6.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"规律\"><a href=\"#规律\" class=\"headerlink\" title=\"规律\"></a>规律</h3><p>根据ZigZag的规律，当行数为 numRows 时：</p>\n<ul>\n<li>ZigZag的第 i 行字符的序号为 \\(k * (2 * numRows - 2) + i \\) ；</li>\n<li>ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \\((k + 1) * (2 * numRows - 2) - i \\)；<br>其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        add = <span class=\"number\">2</span> * numRows - <span class=\"number\">2</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numRows):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n-i, add):</span><br><span class=\"line\">                result += s[i+j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> i != numRows<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j+add-i&lt;n):</span><br><span class=\"line\">                    result += s[j+add-i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong>：这里需要特别注意的是保证 \\(add = 2 * numRows - 2\\) 的有效性，因此需要单独考虑 numRows 为1时的情况。</p>\n<h3 id=\"变步长遍历字符串\"><a href=\"#变步长遍历字符串\" class=\"headerlink\" title=\"变步长遍历字符串\"></a>变步长遍历字符串</h3><p>这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \\(O(n)\\)，具体实现过程如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s, numRows)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :type numRows: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span> <span class=\"keyword\">or</span> numRows &gt;= n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        </span><br><span class=\"line\">        group_list = [<span class=\"string\">\"\"</span>] * numRows</span><br><span class=\"line\"></span><br><span class=\"line\">        index = <span class=\"number\">0</span></span><br><span class=\"line\">        step = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            group_list[index] += char</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> index == <span class=\"number\">0</span>:</span><br><span class=\"line\">                step = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> index == numRows - <span class=\"number\">1</span>:</span><br><span class=\"line\">                step = <span class=\"number\">-1</span></span><br><span class=\"line\">            index += step</span><br><span class=\"line\">           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.join(group_list)</span><br></pre></td></tr></table></figure></p>"},{"title":"LeetCode_Word Search","date":"2019-02-23T06:51:49.000Z","ategories":"LeetCode","_content":"\n## [Word Search](https://leetcode.com/problems/word-search/)\n\nGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n（矩阵中进行词语搜索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_79.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n\n\n\n\n\n```python\nclass Solution:\n    def dfs(self, i, j, word):\n        if word == '':\n            return True\n        tmp = self.board[i][j]\n        self.board[i][j] = '0'\n        \n        if i>0 and self.board[i-1][j] == word[0]:\n            if self.dfs(i-1, j, word[1:]):\n                return True\n        if j>0 and self.board[i][j-1] == word[0]:\n            if self.dfs(i, j-1, word[1:]):\n                return True\n        if i<len(self.board)-1 and self.board[i+1][j] == word[0]:\n            if self.dfs(i+1, j, word[1:]):\n                return True\n        if j<len(self.board[0])-1 and self.board[i][j+1] == word[0]:\n            if self.dfs(i, j+1, word[1:]):\n                return True\n        \n        self.board[i][j] = tmp\n        return False \n        \n    def exist(self, board: List[List[str]], word: str) -> bool:\n        if not word:\n            return True\n        \n        if not board or not board[0]:\n            return False\n        \n        self.board = board\n        for i in range(len(self.board)):\n            for j in range(len(self.board[0])):\n                if self.board[i][j] == word[0]:\n                    if self.dfs(i, j, word[1:]):\n                        return True\n        return False\n```","source":"_posts/leetcode-WordSearch.md","raw":"---\ntitle: LeetCode_Word Search\ndate: 2019-02-23 14:51:49\nategories: LeetCode\ntags: \n  - medium\n  - array\n  - back tracking\n---\n\n## [Word Search](https://leetcode.com/problems/word-search/)\n\nGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n（矩阵中进行词语搜索）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_79.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 回溯法 / DFS\n\n\n\n\n\n```python\nclass Solution:\n    def dfs(self, i, j, word):\n        if word == '':\n            return True\n        tmp = self.board[i][j]\n        self.board[i][j] = '0'\n        \n        if i>0 and self.board[i-1][j] == word[0]:\n            if self.dfs(i-1, j, word[1:]):\n                return True\n        if j>0 and self.board[i][j-1] == word[0]:\n            if self.dfs(i, j-1, word[1:]):\n                return True\n        if i<len(self.board)-1 and self.board[i+1][j] == word[0]:\n            if self.dfs(i+1, j, word[1:]):\n                return True\n        if j<len(self.board[0])-1 and self.board[i][j+1] == word[0]:\n            if self.dfs(i, j+1, word[1:]):\n                return True\n        \n        self.board[i][j] = tmp\n        return False \n        \n    def exist(self, board: List[List[str]], word: str) -> bool:\n        if not word:\n            return True\n        \n        if not board or not board[0]:\n            return False\n        \n        self.board = board\n        for i in range(len(self.board)):\n            for j in range(len(self.board[0])):\n                if self.board[i][j] == word[0]:\n                    if self.dfs(i, j, word[1:]):\n                        return True\n        return False\n```","slug":"leetcode-WordSearch","published":1,"updated":"2019-02-23T07:17:16.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86e00a8kvpxyq1hy0vu","content":"<h2 id=\"Word-Search\"><a href=\"#Word-Search\" class=\"headerlink\" title=\"Word Search\"></a><a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">Word Search</a></h2><p>Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.<br>（矩阵中进行词语搜索）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_79.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, j, word)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> word == <span class=\"string\">''</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        tmp = self.board[i][j]</span><br><span class=\"line\">        self.board[i][j] = <span class=\"string\">'0'</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> self.board[i<span class=\"number\">-1</span>][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i<span class=\"number\">-1</span>, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> self.board[i][j<span class=\"number\">-1</span>] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i, j<span class=\"number\">-1</span>, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&lt;len(self.board)<span class=\"number\">-1</span> <span class=\"keyword\">and</span> self.board[i+<span class=\"number\">1</span>][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i+<span class=\"number\">1</span>, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j&lt;len(self.board[<span class=\"number\">0</span>])<span class=\"number\">-1</span> <span class=\"keyword\">and</span> self.board[i][j+<span class=\"number\">1</span>] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i, j+<span class=\"number\">1</span>, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.board[i][j] = tmp</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> word:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> board <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> board[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.board = board</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(self.board)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(self.board[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.board[i][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> self.dfs(i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Word-Search\"><a href=\"#Word-Search\" class=\"headerlink\" title=\"Word Search\"></a><a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">Word Search</a></h2><p>Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.<br>（矩阵中进行词语搜索）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_79.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-回溯法-DFS\"><a href=\"#1-回溯法-DFS\" class=\"headerlink\" title=\"1. 回溯法 / DFS\"></a>1. 回溯法 / DFS</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, i, j, word)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> word == <span class=\"string\">''</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        tmp = self.board[i][j]</span><br><span class=\"line\">        self.board[i][j] = <span class=\"string\">'0'</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> self.board[i<span class=\"number\">-1</span>][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i<span class=\"number\">-1</span>, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> self.board[i][j<span class=\"number\">-1</span>] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i, j<span class=\"number\">-1</span>, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&lt;len(self.board)<span class=\"number\">-1</span> <span class=\"keyword\">and</span> self.board[i+<span class=\"number\">1</span>][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i+<span class=\"number\">1</span>, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j&lt;len(self.board[<span class=\"number\">0</span>])<span class=\"number\">-1</span> <span class=\"keyword\">and</span> self.board[i][j+<span class=\"number\">1</span>] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.dfs(i, j+<span class=\"number\">1</span>, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.board[i][j] = tmp</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> word:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> board <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> board[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.board = board</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(self.board)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(self.board[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.board[i][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> self.dfs(i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>"},{"title":"LeetCode_Two Sum","date":"2018-11-23T02:57:23.000Z","_content":"\n## [Two Sum](https://leetcode.com/problems/two-sum/)\n\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have **exactly one solution**, and you may **not** use the **same element** twice.\n（一个数组中某两个元素的和为给定值）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_1.png\" width = \"500\" align=center/>\n</div>\n\n这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：\n\n### 1. 暴力循环\n这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\\\(O(n^2)\\\\), 空间复杂度为  \\\\(O(1)\\\\)。\n\n### 2. 构建哈希表\n构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\\\(O(n)\\\\), 空间复杂度为  \\\\(O(n)\\\\)。\n\n(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)\n\n```python\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i, number in enumerate(nums):\n            if (target - number) in d:\n                return [i, d[target-number]]\n            d[number] = i\n```\n\n**注**：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。","source":"_posts/leetcode-twosum.md","raw":"---\ntitle: LeetCode_Two Sum\ndate: 2018-11-23 10:57:23\ncategories: LeetCode\ntags: \n  - easy\n  - array\n  - hash table\n---\n\n## [Two Sum](https://leetcode.com/problems/two-sum/)\n\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have **exactly one solution**, and you may **not** use the **same element** twice.\n（一个数组中某两个元素的和为给定值）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_1.png\" width = \"500\" align=center/>\n</div>\n\n这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：\n\n### 1. 暴力循环\n这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\\\(O(n^2)\\\\), 空间复杂度为  \\\\(O(1)\\\\)。\n\n### 2. 构建哈希表\n构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\\\(O(n)\\\\), 空间复杂度为  \\\\(O(n)\\\\)。\n\n(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)\n\n```python\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for i, number in enumerate(nums):\n            if (target - number) in d:\n                return [i, d[target-number]]\n            d[number] = i\n```\n\n**注**：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。","slug":"leetcode-twosum","published":1,"updated":"2018-11-27T06:25:21.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86g00ackvpxgkj6qdvl","content":"<h2 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly one solution</strong>, and you may <strong>not</strong> use the <strong>same element</strong> twice.<br>（一个数组中某两个元素的和为给定值）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_1.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：</p>\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\(O(n^2)\\), 空间复杂度为  \\(O(1)\\)。</p>\n<h3 id=\"2-构建哈希表\"><a href=\"#2-构建哈希表\" class=\"headerlink\" title=\"2. 构建哈希表\"></a>2. 构建哈希表</h3><p>构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\(O(n)\\), 空间复杂度为  \\(O(n)\\)。</p>\n<p>(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, number <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target - number) <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [i, d[target-number]]</span><br><span class=\"line\">            d[number] = i</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly one solution</strong>, and you may <strong>not</strong> use the <strong>same element</strong> twice.<br>（一个数组中某两个元素的和为给定值）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_1.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下：</p>\n<h3 id=\"1-暴力循环\"><a href=\"#1-暴力循环\" class=\"headerlink\" title=\"1. 暴力循环\"></a>1. 暴力循环</h3><p>这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \\(O(n^2)\\), 空间复杂度为  \\(O(1)\\)。</p>\n<h3 id=\"2-构建哈希表\"><a href=\"#2-构建哈希表\" class=\"headerlink\" title=\"2. 构建哈希表\"></a>2. 构建哈希表</h3><p>构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \\(O(n)\\), 空间复杂度为  \\(O(n)\\)。</p>\n<p>(注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type target: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, number <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target - number) <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [i, d[target-number]]</span><br><span class=\"line\">            d[number] = i</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。</p>"},{"title":"LeetCode_Add Two Numbers","date":"2018-11-23T03:59:43.000Z","_content":"\n## [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n（字符串/链表数值加法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_2.png\" width = \"500\" align=center/>\n</div>\n\n这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了**链表**的概念来表示组成数值的每个数字。\n\n### 1. 转换为数值计算\n\n很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\\\(O(m + n)\\\\)。\n\n```python\nclass Solution:\n    def list2num(self, l):\n        result = 0\n        j = 0\n        while l != None:\n            num =  10 ** j * l.val\n            result += num\n            l = l.next\n            j += 1 \n        return result\n    \n    def num2list(self, num):\n        if num == 0:\n            return ListNode(0)\n        l = ListNode(0)\n        p = l\n        while num != 0:\n            a = num % 10\n            num = num // 10\n            new_l = ListNode(a)\n            p.next = new_l\n            p = p.next \n        return l.next\n        \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        left = self.list2num(l1)\n        right = self.list2num(l2)\n        return self.num2list(left + right)\n```\n\n### 2. 加法器\n\n我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的**进位**。其时间复杂度为 \\\\(O(max(m + n))\\\\)。\n\n```python\nclass Solution:    \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n       \n        l = None\n        l3 = None\n        a = 0\n        \n        while l1 or l2 or a:\n            if l1:\n                a += l1.val\n                l1 = l1.next\n            if l2:\n                a +=l2.val\n                l2 = l2.next\n            if l3:\n                l3.next = ListNode(a % 10)\n                l3 = l3.next\n            else:\n                l3 = ListNode(a % 10)\n                l = l3\n            \n            a = a // 10\n        \n        return l\n```\n\n**注**：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。","source":"_posts/leetcode-addtwonumbers.md","raw":"---\ntitle: LeetCode_Add Two Numbers\ndate: 2018-11-23 11:59:43\ncategories: LeetCode\ntags: \n  - medium\n  - linked list\n  - math\n---\n\n## [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n（字符串/链表数值加法）\n\n<!--more-->\n\n**Example:** \n\n<div align=center>\n\t<img src=\"/images/leetcode_2.png\" width = \"500\" align=center/>\n</div>\n\n这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了**链表**的概念来表示组成数值的每个数字。\n\n### 1. 转换为数值计算\n\n很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\\\(O(m + n)\\\\)。\n\n```python\nclass Solution:\n    def list2num(self, l):\n        result = 0\n        j = 0\n        while l != None:\n            num =  10 ** j * l.val\n            result += num\n            l = l.next\n            j += 1 \n        return result\n    \n    def num2list(self, num):\n        if num == 0:\n            return ListNode(0)\n        l = ListNode(0)\n        p = l\n        while num != 0:\n            a = num % 10\n            num = num // 10\n            new_l = ListNode(a)\n            p.next = new_l\n            p = p.next \n        return l.next\n        \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        left = self.list2num(l1)\n        right = self.list2num(l2)\n        return self.num2list(left + right)\n```\n\n### 2. 加法器\n\n我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的**进位**。其时间复杂度为 \\\\(O(max(m + n))\\\\)。\n\n```python\nclass Solution:    \n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n       \n        l = None\n        l3 = None\n        a = 0\n        \n        while l1 or l2 or a:\n            if l1:\n                a += l1.val\n                l1 = l1.next\n            if l2:\n                a +=l2.val\n                l2 = l2.next\n            if l3:\n                l3.next = ListNode(a % 10)\n                l3 = l3.next\n            else:\n                l3 = ListNode(a % 10)\n                l = l3\n            \n            a = a // 10\n        \n        return l\n```\n\n**注**：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。","slug":"leetcode-addtwonumbers","published":1,"updated":"2018-11-27T06:19:38.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86i00afkvpx3apr0bkd","content":"<h2 id=\"Add-Two-Numbers\"><a href=\"#Add-Two-Numbers\" class=\"headerlink\" title=\"Add Two Numbers\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">Add Two Numbers</a></h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>（字符串/链表数值加法）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_2.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了<strong>链表</strong>的概念来表示组成数值的每个数字。</p>\n<h3 id=\"1-转换为数值计算\"><a href=\"#1-转换为数值计算\" class=\"headerlink\" title=\"1. 转换为数值计算\"></a>1. 转换为数值计算</h3><p>很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\(O(m + n)\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list2num</span><span class=\"params\">(self, l)</span>:</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            num =  <span class=\"number\">10</span> ** j * l.val</span><br><span class=\"line\">            result += num</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">            j += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">num2list</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        l = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a = num % <span class=\"number\">10</span></span><br><span class=\"line\">            num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            new_l = ListNode(a)</span><br><span class=\"line\">            p.next = new_l</span><br><span class=\"line\">            p = p.next </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        left = self.list2num(l1)</span><br><span class=\"line\">        right = self.list2num(l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.num2list(left + right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-加法器\"><a href=\"#2-加法器\" class=\"headerlink\" title=\"2. 加法器\"></a>2. 加法器</h3><p>我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的<strong>进位</strong>。其时间复杂度为 \\(O(max(m + n))\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        l = <span class=\"keyword\">None</span></span><br><span class=\"line\">        l3 = <span class=\"keyword\">None</span></span><br><span class=\"line\">        a = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> a:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                a += l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                a +=l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l3:</span><br><span class=\"line\">                l3.next = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l3 = l3.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                l3 = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l = l3</span><br><span class=\"line\">            </span><br><span class=\"line\">            a = a // <span class=\"number\">10</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Add-Two-Numbers\"><a href=\"#Add-Two-Numbers\" class=\"headerlink\" title=\"Add Two Numbers\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">Add Two Numbers</a></h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>（字符串/链表数值加法）</p>","more":"<p><strong>Example:</strong> </p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_2.png\" width=\"500\" align=\"center/\"><br></div>\n\n<p>这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了<strong>链表</strong>的概念来表示组成数值的每个数字。</p>\n<h3 id=\"1-转换为数值计算\"><a href=\"#1-转换为数值计算\" class=\"headerlink\" title=\"1. 转换为数值计算\"></a>1. 转换为数值计算</h3><p>很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \\(O(m + n)\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list2num</span><span class=\"params\">(self, l)</span>:</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            num =  <span class=\"number\">10</span> ** j * l.val</span><br><span class=\"line\">            result += num</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">            j += <span class=\"number\">1</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">num2list</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        l = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a = num % <span class=\"number\">10</span></span><br><span class=\"line\">            num = num // <span class=\"number\">10</span></span><br><span class=\"line\">            new_l = ListNode(a)</span><br><span class=\"line\">            p.next = new_l</span><br><span class=\"line\">            p = p.next </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        left = self.list2num(l1)</span><br><span class=\"line\">        right = self.list2num(l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.num2list(left + right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-加法器\"><a href=\"#2-加法器\" class=\"headerlink\" title=\"2. 加法器\"></a>2. 加法器</h3><p>我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的<strong>进位</strong>。其时间复杂度为 \\(O(max(m + n))\\)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        l = <span class=\"keyword\">None</span></span><br><span class=\"line\">        l3 = <span class=\"keyword\">None</span></span><br><span class=\"line\">        a = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> a:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                a += l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                a +=l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l3:</span><br><span class=\"line\">                l3.next = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l3 = l3.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                l3 = ListNode(a % <span class=\"number\">10</span>)</span><br><span class=\"line\">                l = l3</span><br><span class=\"line\">            </span><br><span class=\"line\">            a = a // <span class=\"number\">10</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。</p>"},{"title":"LeetCode_Sqrt X","date":"2019-02-16T09:13:26.000Z","_content":"\n## [Sqrt(x)](https://leetcode.com/problems/sqrtx/)\n\nImplement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\n（实现Sqrt(x)）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_69.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def mySqrt(self, x: 'int') -> 'int':\n        left, right = 0, x\n        \n        while left <= right:\n            middle  = (left + right)//2\n            if middle * middle <= x and (middle+1) * (middle+1) > x:\n                return middle\n            elif middle * middle < x:\n                left = middle + 1\n            else:\n                right = middle - 1\n```","source":"_posts/leetcode-sqrtx.md","raw":"---\ntitle: LeetCode_Sqrt X\ndate: 2019-02-16 17:13:26\ncategories: LeetCode\ntags: \n  - easy\n  - math\n  - binary search\n---\n\n## [Sqrt(x)](https://leetcode.com/problems/sqrtx/)\n\nImplement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\n（实现Sqrt(x)）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_69.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 二分查找\n```python\nclass Solution:\n    def mySqrt(self, x: 'int') -> 'int':\n        left, right = 0, x\n        \n        while left <= right:\n            middle  = (left + right)//2\n            if middle * middle <= x and (middle+1) * (middle+1) > x:\n                return middle\n            elif middle * middle < x:\n                left = middle + 1\n            else:\n                right = middle - 1\n```","slug":"leetcode-sqrtx","published":1,"updated":"2019-02-16T09:28:14.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86m00ajkvpxc6809j57","content":"<h2 id=\"Sqrt-x\"><a href=\"#Sqrt-x\" class=\"headerlink\" title=\"Sqrt(x)\"></a><a href=\"https://leetcode.com/problems/sqrtx/\" target=\"_blank\" rel=\"noopener\">Sqrt(x)</a></h2><p>Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.<br>（实现Sqrt(x)）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_69.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mySqrt</span><span class=\"params\">(self, x: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, x</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle  = (left + right)//<span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> middle * middle &lt;= x <span class=\"keyword\">and</span> (middle+<span class=\"number\">1</span>) * (middle+<span class=\"number\">1</span>) &gt; x:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> middle * middle &lt; x:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Sqrt-x\"><a href=\"#Sqrt-x\" class=\"headerlink\" title=\"Sqrt(x)\"></a><a href=\"https://leetcode.com/problems/sqrtx/\" target=\"_blank\" rel=\"noopener\">Sqrt(x)</a></h2><p>Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.<br>（实现Sqrt(x)）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_69.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mySqrt</span><span class=\"params\">(self, x: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, x</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            middle  = (left + right)//<span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> middle * middle &lt;= x <span class=\"keyword\">and</span> (middle+<span class=\"number\">1</span>) * (middle+<span class=\"number\">1</span>) &gt; x:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> middle * middle &lt; x:</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>"},{"title":"Task-Oriented Dialog System","date":"2018-11-15T09:37:35.000Z","_content":"\n面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。\n\n<!--more-->\n\n#### [数据集 In-Car DataSet](https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/)\n数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：\n<div align=center>\n\t<img src=\"/images/diag_example.png\" width = \"600\" align=center/>\n</div>\n\n这个数据集中总共有3031次对话，具体信息如下：\n<div align=center>\n\t<img src=\"/images/diag_statistics.png\" width = \"600\" align=center/>\n</div>\n\n其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：\n<div align=center>\n\t<img src=\"/images/diag_statistics2.png\" width = \"600\" align=center/>\n</div>\n\n特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。\n\n#### Key Value Retrieval Networks [1]\n这个模型是针对此数据集提出的 baseline，将**End-to-End模型**与**信息检索模型**结合。\n\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - LSTM\n 输入：历史对话，\\\\((u_1, s_1, ..., s_{i-1}, u_i)\\\\)\n Hidden State: \\\\(h_i\\\\)\n\n- Decoder\n 输入：\\\\(h_i\\\\)\n Hidden State: \\\\(\\tilde{h_{t}}\\\\)\n 输出：\\\\(y_1, y_2, ..., y_n\\\\)\n 其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。\n\n- Attention\n 在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为**subject**和**relation**的embedding的和\\\\(k_j\\\\)。具体的attention计算过程如下：\n \\\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\\\] \\\\[a_i^t = softmax(u_i^t)\\\\]\\\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\\\]\\\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\\\]\\\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\\\]\\\\[y_t = Softmax(o_t)\\\\]\n 其中，\\\\(\\tilde{v_t}\\\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\\\(\\tilde{v_t}\\\\)中与知识库中相关的表示为\\\\(u_j^t\\\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\\\(v_t\\\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval_result.png\" width = \"600\" align=center/>\n</div>\n\n#### Mem2Seq [2]\n这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。\n\n<div align=center>\n\t<img src=\"/images/mem2seq.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - Multi-hop MemNN\n 输入：U = [B; X]，其中X = {x1, ..., xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, ..., bl}表示知识库。\n 输出：\\\\(o_k\\\\)\n\n \\\\[ p_k^i = Softmax(q_k)^T C_i^k\\\\] \\\\[o_k = \\sum p_k C_{k+1}\\\\] \\\\[q_{k+1} = q_k + o_k\\\\]\n\n 一般的MemNN过程，其中\\\\(C_i\\\\)为Encoder的memory。\n\n- Decoder - GRU + MemNN\n 输入：\\\\(o_k\\\\)\n HiddenState：\\\\(h_t\\\\)\n 输出：\\\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\\\)\n\n \\\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\\\] \\\\[P_{ptr} = p_t^K \\\\]\n\n 其中，\\\\(P_{vocab}(\\hat{y_t})\\\\)结合第一个hop的输出得到输出词在词典上的分布，\\\\(P_{ptr}\\\\)是Decoder中MemNN的最后一个hop的\\\\(p_t^K\\\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/mem2seq_result.png\" width = \"600\" align=center/>\n</div>\n 下面是一个具体的生成案例：\n<div align=center>\n\t<img src=\"/images/mem2seq_result2.png\" width = \"800\" align=center/>\n</div>\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.\n[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.\n\n","source":"_posts/task-oriented-dialog-systems.md","raw":"---\ntitle: Task-Oriented Dialog System\ndate: 2018-11-15 17:37:35\ncategories: Research\ntags: \n  - intent\n  - slot \n  - task-oriented\n---\n\n面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。\n\n<!--more-->\n\n#### [数据集 In-Car DataSet](https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/)\n数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：\n<div align=center>\n\t<img src=\"/images/diag_example.png\" width = \"600\" align=center/>\n</div>\n\n这个数据集中总共有3031次对话，具体信息如下：\n<div align=center>\n\t<img src=\"/images/diag_statistics.png\" width = \"600\" align=center/>\n</div>\n\n其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：\n<div align=center>\n\t<img src=\"/images/diag_statistics2.png\" width = \"600\" align=center/>\n</div>\n\n特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。\n\n#### Key Value Retrieval Networks [1]\n这个模型是针对此数据集提出的 baseline，将**End-to-End模型**与**信息检索模型**结合。\n\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - LSTM\n 输入：历史对话，\\\\((u_1, s_1, ..., s_{i-1}, u_i)\\\\)\n Hidden State: \\\\(h_i\\\\)\n\n- Decoder\n 输入：\\\\(h_i\\\\)\n Hidden State: \\\\(\\tilde{h_{t}}\\\\)\n 输出：\\\\(y_1, y_2, ..., y_n\\\\)\n 其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。\n\n- Attention\n 在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为**subject**和**relation**的embedding的和\\\\(k_j\\\\)。具体的attention计算过程如下：\n \\\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\\\] \\\\[a_i^t = softmax(u_i^t)\\\\]\\\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\\\]\\\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\\\]\\\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\\\]\\\\[y_t = Softmax(o_t)\\\\]\n 其中，\\\\(\\tilde{v_t}\\\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\\\(\\tilde{v_t}\\\\)中与知识库中相关的表示为\\\\(u_j^t\\\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\\\(v_t\\\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/diag_kv_retrieval_result.png\" width = \"600\" align=center/>\n</div>\n\n#### Mem2Seq [2]\n这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。\n\n<div align=center>\n\t<img src=\"/images/mem2seq.png\" width = \"600\" align=center/>\n</div>\n\n- Encoder - Multi-hop MemNN\n 输入：U = [B; X]，其中X = {x1, ..., xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, ..., bl}表示知识库。\n 输出：\\\\(o_k\\\\)\n\n \\\\[ p_k^i = Softmax(q_k)^T C_i^k\\\\] \\\\[o_k = \\sum p_k C_{k+1}\\\\] \\\\[q_{k+1} = q_k + o_k\\\\]\n\n 一般的MemNN过程，其中\\\\(C_i\\\\)为Encoder的memory。\n\n- Decoder - GRU + MemNN\n 输入：\\\\(o_k\\\\)\n HiddenState：\\\\(h_t\\\\)\n 输出：\\\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\\\)\n\n \\\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\\\] \\\\[P_{ptr} = p_t^K \\\\]\n\n 其中，\\\\(P_{vocab}(\\hat{y_t})\\\\)结合第一个hop的输出得到输出词在词典上的分布，\\\\(P_{ptr}\\\\)是Decoder中MemNN的最后一个hop的\\\\(p_t^K\\\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:\n<div align=center>\n\t<img src=\"/images/mem2seq_result.png\" width = \"600\" align=center/>\n</div>\n 下面是一个具体的生成案例：\n<div align=center>\n\t<img src=\"/images/mem2seq_result2.png\" width = \"800\" align=center/>\n</div>\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.\n[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.\n\n","slug":"task-oriented-dialog-systems","published":1,"updated":"2018-11-27T03:23:40.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86n00amkvpx83hsvp08","content":"<p>面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。</p>\n<a id=\"more\"></a>\n<h4 id=\"数据集-In-Car-DataSet\"><a href=\"#数据集-In-Car-DataSet\" class=\"headerlink\" title=\"数据集 In-Car DataSet\"></a><a href=\"https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/\" target=\"_blank\" rel=\"noopener\">数据集 In-Car DataSet</a></h4><p>数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_example.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>这个数据集中总共有3031次对话，具体信息如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics2.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。</p>\n<h4 id=\"Key-Value-Retrieval-Networks-1\"><a href=\"#Key-Value-Retrieval-Networks-1\" class=\"headerlink\" title=\"Key Value Retrieval Networks [1]\"></a>Key Value Retrieval Networks [1]</h4><p>这个模型是针对此数据集提出的 baseline，将<strong>End-to-End模型</strong>与<strong>信息检索模型</strong>结合。</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_kv_retrieval.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - LSTM<br>输入：历史对话，\\((u_1, s_1, …, s_{i-1}, u_i)\\)<br>Hidden State: \\(h_i\\)</p>\n</li>\n<li><p>Decoder<br>输入：\\(h_i\\)<br>Hidden State: \\(\\tilde{h_{t}}\\)<br>输出：\\(y_1, y_2, …, y_n\\)<br>其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。</p>\n</li>\n<li><p>Attention<br>在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为<strong>subject</strong>和<strong>relation</strong>的embedding的和\\(k_j\\)。具体的attention计算过程如下：<br>\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\] \\[a_i^t = softmax(u_i^t)\\]\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\]\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\]\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\]\\[y_t = Softmax(o_t)\\]<br>其中，\\(\\tilde{v_t}\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\(\\tilde{v_t}\\)中与知识库中相关的表示为\\(u_j^t\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\(v_t\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/diag_kv_retrieval_result.png\" width=\"600\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<h4 id=\"Mem2Seq-2\"><a href=\"#Mem2Seq-2\" class=\"headerlink\" title=\"Mem2Seq [2]\"></a>Mem2Seq [2]</h4><p>这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。</p>\n<div align=\"center\"><br>    <img src=\"/images/mem2seq.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - Multi-hop MemNN<br>输入：U = [B; X]，其中X = {x1, …, xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, …, bl}表示知识库。<br>输出：\\(o_k\\)</p>\n<p>\\[ p_k^i = Softmax(q_k)^T C_i^k\\] \\[o_k = \\sum p_k C_{k+1}\\] \\[q_{k+1} = q_k + o_k\\]</p>\n<p>一般的MemNN过程，其中\\(C_i\\)为Encoder的memory。</p>\n</li>\n<li><p>Decoder - GRU + MemNN<br>输入：\\(o_k\\)<br>HiddenState：\\(h_t\\)<br>输出：\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\)</p>\n<p>\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\] \\[P_{ptr} = p_t^K \\]</p>\n<p>其中，\\(P_{vocab}(\\hat{y_t})\\)结合第一个hop的输出得到输出词在词典上的分布，\\(P_{ptr}\\)是Decoder中MemNN的最后一个hop的\\(p_t^K\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/mem2seq_result.png\" width=\"600\" align=\"center/\"><br></div><br>下面是一个具体的生成案例：<br><div align=\"center\"><br>  <img src=\"/images/mem2seq_result2.png\" width=\"800\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.<br>[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.</p>\n","site":{"data":{}},"excerpt":"<p>面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。</p>","more":"<h4 id=\"数据集-In-Car-DataSet\"><a href=\"#数据集-In-Car-DataSet\" class=\"headerlink\" title=\"数据集 In-Car DataSet\"></a><a href=\"https://nlp.stanford.edu/blog/a-new-multi-turn-multi-domain-task-oriented-dialogue-dataset/\" target=\"_blank\" rel=\"noopener\">数据集 In-Car DataSet</a></h4><p>数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_example.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>这个数据集中总共有3031次对话，具体信息如下：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值：</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_statistics2.png\" width=\"600\" align=\"center/\"><br></div>\n\n<p>特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。</p>\n<h4 id=\"Key-Value-Retrieval-Networks-1\"><a href=\"#Key-Value-Retrieval-Networks-1\" class=\"headerlink\" title=\"Key Value Retrieval Networks [1]\"></a>Key Value Retrieval Networks [1]</h4><p>这个模型是针对此数据集提出的 baseline，将<strong>End-to-End模型</strong>与<strong>信息检索模型</strong>结合。</p>\n<div align=\"center\"><br>    <img src=\"/images/diag_kv_retrieval.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - LSTM<br>输入：历史对话，\\((u_1, s_1, …, s_{i-1}, u_i)\\)<br>Hidden State: \\(h_i\\)</p>\n</li>\n<li><p>Decoder<br>输入：\\(h_i\\)<br>Hidden State: \\(\\tilde{h_{t}}\\)<br>输出：\\(y_1, y_2, …, y_n\\)<br>其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。</p>\n</li>\n<li><p>Attention<br>在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为<strong>subject</strong>和<strong>relation</strong>的embedding的和\\(k_j\\)。具体的attention计算过程如下：<br>\\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \\tilde{h_{t}}]))\\] \\[a_i^t = softmax(u_i^t)\\]\\[\\tilde{h_{t}}^{,} = a_i^t h_i\\]\\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \\tilde{h_{t}}]))\\]\\[o_t = U[\\tilde{h_{t}}, \\tilde{h_{t}}^{,}] + \\tilde{v_{t}}\\]\\[y_t = Softmax(o_t)\\]<br>其中，\\(\\tilde{v_t}\\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\\(\\tilde{v_t}\\)中与知识库中相关的表示为\\(u_j^t\\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\\(v_t\\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/diag_kv_retrieval_result.png\" width=\"600\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<h4 id=\"Mem2Seq-2\"><a href=\"#Mem2Seq-2\" class=\"headerlink\" title=\"Mem2Seq [2]\"></a>Mem2Seq [2]</h4><p>这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。</p>\n<div align=\"center\"><br>    <img src=\"/images/mem2seq.png\" width=\"600\" align=\"center/\"><br></div>\n\n<ul>\n<li><p>Encoder - Multi-hop MemNN<br>输入：U = [B; X]，其中X = {x1, …, xn, \\$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \\$u”），\\$表示结束；B = {b1, …, bl}表示知识库。<br>输出：\\(o_k\\)</p>\n<p>\\[ p_k^i = Softmax(q_k)^T C_i^k\\] \\[o_k = \\sum p_k C_{k+1}\\] \\[q_{k+1} = q_k + o_k\\]</p>\n<p>一般的MemNN过程，其中\\(C_i\\)为Encoder的memory。</p>\n</li>\n<li><p>Decoder - GRU + MemNN<br>输入：\\(o_k\\)<br>HiddenState：\\(h_t\\)<br>输出：\\(P_{vocab}(\\hat{y_t}), P_{ptr}\\)</p>\n<p>\\[P_{vocab}(\\hat{y_t}) = Softmax(W_1[h_t; o^1])\\] \\[P_{ptr} = p_t^K \\]</p>\n<p>其中，\\(P_{vocab}(\\hat{y_t})\\)结合第一个hop的输出得到输出词在词典上的分布，\\(P_{ptr}\\)是Decoder中MemNN的最后一个hop的\\(p_t^K\\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下:</p>\n<div align=\"center\"><br>  <img src=\"/images/mem2seq_result.png\" width=\"600\" align=\"center/\"><br></div><br>下面是一个具体的生成案例：<br><div align=\"center\"><br>  <img src=\"/images/mem2seq_result2.png\" width=\"800\" align=\"center/\"><br></div>\n\n</li>\n</ul>\n<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p>\n<p>[1] Key-Value Retrieval Networks for Task-Oriented Dialogue.<br>[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.</p>"},{"title":"LeetCode_Set Matrix Zeroes","date":"2019-02-16T13:13:21.000Z","_content":"\n## [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)\n\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\n（设置矩阵整行&列为0）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_73.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 遍历矩阵，集合维护“0”的行列号\n\n```python\nclass Solution:\n    def setZeroes(self, matrix: 'List[List[int]]') -> 'None':\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        \n        columns = set()\n        rows = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    columns.add(j)\n                    rows.add(i)\n    \n        for i in rows:\n            # matrix[i] = [0]*n\n            for j in range(n):\n                matrix[i][j] = 0\n        \n        for j in columns:\n            for i in range(m):\n                matrix[i][j] = 0\n```","source":"_posts/leetcode-SetMatrixZeroes.md","raw":"---\ntitle: LeetCode_Set Matrix Zeroes\ndate: 2019-02-16 21:13:21\ncategories: LeetCode\ntags: \n  - medium\n  - array\n---\n\n## [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)\n\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\n（设置矩阵整行&列为0）\n\n<!--more-->\n\n**Example:**\n\n<div align=center>\n\t<img src=\"/images/leetcode_73.png\" width = \"500\" align=center/>\n</div>\n\n### 1. 遍历矩阵，集合维护“0”的行列号\n\n```python\nclass Solution:\n    def setZeroes(self, matrix: 'List[List[int]]') -> 'None':\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        \n        columns = set()\n        rows = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    columns.add(j)\n                    rows.add(i)\n    \n        for i in rows:\n            # matrix[i] = [0]*n\n            for j in range(n):\n                matrix[i][j] = 0\n        \n        for j in columns:\n            for i in range(m):\n                matrix[i][j] = 0\n```","slug":"leetcode-SetMatrixZeroes","published":1,"updated":"2019-02-16T13:34:02.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht86p00aqkvpx5dolsm5w","content":"<h2 id=\"Set-Matrix-Zeroes\"><a href=\"#Set-Matrix-Zeroes\" class=\"headerlink\" title=\"Set Matrix Zeroes\"></a><a href=\"https://leetcode.com/problems/set-matrix-zeroes/\" target=\"_blank\" rel=\"noopener\">Set Matrix Zeroes</a></h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.<br>（设置矩阵整行&amp;列为0）</p>\n<a id=\"more\"></a>\n<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_73.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-遍历矩阵，集合维护“0”的行列号\"><a href=\"#1-遍历矩阵，集合维护“0”的行列号\" class=\"headerlink\" title=\"1. 遍历矩阵，集合维护“0”的行列号\"></a>1. 遍历矩阵，集合维护“0”的行列号</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setZeroes</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify matrix in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        columns = set()</span><br><span class=\"line\">        rows = set()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    columns.add(j)</span><br><span class=\"line\">                    rows.add(i)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> rows:</span><br><span class=\"line\">            <span class=\"comment\"># matrix[i] = [0]*n</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                matrix[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> columns:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">                matrix[i][j] = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Set-Matrix-Zeroes\"><a href=\"#Set-Matrix-Zeroes\" class=\"headerlink\" title=\"Set Matrix Zeroes\"></a><a href=\"https://leetcode.com/problems/set-matrix-zeroes/\" target=\"_blank\" rel=\"noopener\">Set Matrix Zeroes</a></h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.<br>（设置矩阵整行&amp;列为0）</p>","more":"<p><strong>Example:</strong></p>\n<div align=\"center\"><br>    <img src=\"/images/leetcode_73.png\" width=\"500\" align=\"center/\"><br></div>\n\n<h3 id=\"1-遍历矩阵，集合维护“0”的行列号\"><a href=\"#1-遍历矩阵，集合维护“0”的行列号\" class=\"headerlink\" title=\"1. 遍历矩阵，集合维护“0”的行列号\"></a>1. 遍历矩阵，集合维护“0”的行列号</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setZeroes</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify matrix in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        columns = set()</span><br><span class=\"line\">        rows = set()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    columns.add(j)</span><br><span class=\"line\">                    rows.add(i)</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> rows:</span><br><span class=\"line\">            <span class=\"comment\"># matrix[i] = [0]*n</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                matrix[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> columns:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">                matrix[i][j] = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>"},{"title":"First Step to Establish the Blog","date":"2018-11-01T02:41:02.000Z","_content":"\n让我们搭一个美美的博客，一起写写写吧~~~\n\n<!-- more --> \n\n## Requirement\n\n​\tbrew, hexo, Node.js\n\n### Hexo项目\n\n``` bash\n$ hexo init           # 新建博客目录\n$ hexo new \"postname\" # 生成postname.md文件\n$ hexo clean          # 清空生成的网页\n$ hexo generate       # 根据当前目录下文件生成静态网页\n$ hexo server \t      # 启动服务器\n```\n\n通过访问localhost:4000可以在本地调试。文件目录`source`下的`_posts`中可以添加用户新增加的博客内容（Markdown语法）。\n\nMore info: [Heox](https://hexo.io/docs/)\n\n### 修改主题\n\n``` bash\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n修改`config.yml`配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：\n``` bash\nauto_excerpt:   # 可通过 <!-- more --> 标签自动截断, 增加阅读全文按钮。\n  enable: true\n  length: 150\n\nbusuanzi_count: # 监听网页浏览量。\n  enable: true\n```\n\n### 添加新的导航栏\n\n``` bash\n$ hexo new page tags   # 添加tags标签页\n```\n\n修改`source`目录下的`tags`中的`index.md`如下：\n\n```\n---\ntitle: tags\ndate: 2018-10-30 17:23:49\ntype: \"tags\"\n---\n```\n\n在菜单中添加链接。编辑`config.yml`配置文件中的menu属性，如下：\n\n```\nmenu:\n  home: /\n  archives: /archives\n  tags : /tags\n```\n\n### 部署到 Github\n\n修改`config.yml`配置文件中的deploy属性：\n\n``` bash\ndeploy:\n  type: git \n  repo: https://github.com/test/test.github.io.git  # github路径\n```\n\n通过下面的指令实现部署：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo deploy\n```\n\n### Google 收录博客网站\n\n1. 添加站点：用自己的 Google 帐号登陆 [Webmaster Central](https://www.google.com/webmasters/verification/home?hl=en)。\n\n2. 验证站点: 将网站上的验证文件放在 `source` 文件下，在站点配置文件配置如下：\n``` bash\nskip_render: google10bb50e0b38f396b.html\n```\n\n3. 产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在`config.yml`里配置一下：\n``` bash\nnpm install hexo-generator-sitemap --save\n```\n\t``` bash\n\tsitemap:\n\t    path: sitemap.xml\n\t```\n\n4. 重新编译生成\n``` bash\nhexo generate\n```\n","source":"_posts/first_step.md","raw":"---\ntitle: First Step to Establish the Blog\ndate: 2018-11-01 10:41:02\ncategories: Note\ntags:\n  - tools\n---\n\n让我们搭一个美美的博客，一起写写写吧~~~\n\n<!-- more --> \n\n## Requirement\n\n​\tbrew, hexo, Node.js\n\n### Hexo项目\n\n``` bash\n$ hexo init           # 新建博客目录\n$ hexo new \"postname\" # 生成postname.md文件\n$ hexo clean          # 清空生成的网页\n$ hexo generate       # 根据当前目录下文件生成静态网页\n$ hexo server \t      # 启动服务器\n```\n\n通过访问localhost:4000可以在本地调试。文件目录`source`下的`_posts`中可以添加用户新增加的博客内容（Markdown语法）。\n\nMore info: [Heox](https://hexo.io/docs/)\n\n### 修改主题\n\n``` bash\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n修改`config.yml`配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：\n``` bash\nauto_excerpt:   # 可通过 <!-- more --> 标签自动截断, 增加阅读全文按钮。\n  enable: true\n  length: 150\n\nbusuanzi_count: # 监听网页浏览量。\n  enable: true\n```\n\n### 添加新的导航栏\n\n``` bash\n$ hexo new page tags   # 添加tags标签页\n```\n\n修改`source`目录下的`tags`中的`index.md`如下：\n\n```\n---\ntitle: tags\ndate: 2018-10-30 17:23:49\ntype: \"tags\"\n---\n```\n\n在菜单中添加链接。编辑`config.yml`配置文件中的menu属性，如下：\n\n```\nmenu:\n  home: /\n  archives: /archives\n  tags : /tags\n```\n\n### 部署到 Github\n\n修改`config.yml`配置文件中的deploy属性：\n\n``` bash\ndeploy:\n  type: git \n  repo: https://github.com/test/test.github.io.git  # github路径\n```\n\n通过下面的指令实现部署：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo deploy\n```\n\n### Google 收录博客网站\n\n1. 添加站点：用自己的 Google 帐号登陆 [Webmaster Central](https://www.google.com/webmasters/verification/home?hl=en)。\n\n2. 验证站点: 将网站上的验证文件放在 `source` 文件下，在站点配置文件配置如下：\n``` bash\nskip_render: google10bb50e0b38f396b.html\n```\n\n3. 产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在`config.yml`里配置一下：\n``` bash\nnpm install hexo-generator-sitemap --save\n```\n\t``` bash\n\tsitemap:\n\t    path: sitemap.xml\n\t```\n\n4. 重新编译生成\n``` bash\nhexo generate\n```\n","slug":"first_step","published":1,"updated":"2018-11-27T03:26:26.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszht8gs00l0kvpxcgmq8k74","content":"<p>让我们搭一个美美的博客，一起写写写吧~~~</p>\n<a id=\"more\"></a> \n<h2 id=\"Requirement\"><a href=\"#Requirement\" class=\"headerlink\" title=\"Requirement\"></a>Requirement</h2><p>​    brew, hexo, Node.js</p>\n<h3 id=\"Hexo项目\"><a href=\"#Hexo项目\" class=\"headerlink\" title=\"Hexo项目\"></a>Hexo项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init           <span class=\"comment\"># 新建博客目录</span></span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postname\"</span> <span class=\"comment\"># 生成postname.md文件</span></span><br><span class=\"line\">$ hexo clean          <span class=\"comment\"># 清空生成的网页</span></span><br><span class=\"line\">$ hexo generate       <span class=\"comment\"># 根据当前目录下文件生成静态网页</span></span><br><span class=\"line\">$ hexo server \t      <span class=\"comment\"># 启动服务器</span></span><br></pre></td></tr></table></figure>\n<p>通过访问localhost:4000可以在本地调试。文件目录<code>source</code>下的<code>_posts</code>中可以添加用户新增加的博客内容（Markdown语法）。</p>\n<p>More info: <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">Heox</a></p>\n<h3 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>修改<code>config.yml</code>配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_excerpt:   <span class=\"comment\"># 可通过 &lt;!-- more --&gt; 标签自动截断, 增加阅读全文按钮。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  length: 150</span><br><span class=\"line\"></span><br><span class=\"line\">busuanzi_count: <span class=\"comment\"># 监听网页浏览量。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加新的导航栏\"><a href=\"#添加新的导航栏\" class=\"headerlink\" title=\"添加新的导航栏\"></a>添加新的导航栏</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page tags   <span class=\"comment\"># 添加tags标签页</span></span><br></pre></td></tr></table></figure>\n<p>修改<code>source</code>目录下的<code>tags</code>中的<code>index.md</code>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2018-10-30 17:23:49</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>在菜单中添加链接。编辑<code>config.yml</code>配置文件中的menu属性，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /</span><br><span class=\"line\">  archives: /archives</span><br><span class=\"line\">  tags : /tags</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署到-Github\"><a href=\"#部署到-Github\" class=\"headerlink\" title=\"部署到 Github\"></a>部署到 Github</h3><p>修改<code>config.yml</code>配置文件中的deploy属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git </span><br><span class=\"line\">  repo: https://github.com/<span class=\"built_in\">test</span>/test.github.io.git  <span class=\"comment\"># github路径</span></span><br></pre></td></tr></table></figure>\n<p>通过下面的指令实现部署：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Google-收录博客网站\"><a href=\"#Google-收录博客网站\" class=\"headerlink\" title=\"Google 收录博客网站\"></a>Google 收录博客网站</h3><ol>\n<li><p>添加站点：用自己的 Google 帐号登陆 <a href=\"https://www.google.com/webmasters/verification/home?hl=en\" target=\"_blank\" rel=\"noopener\">Webmaster Central</a>。</p>\n</li>\n<li><p>验证站点: 将网站上的验证文件放在 <code>source</code> 文件下，在站点配置文件配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip_render: google10bb50e0b38f396b.html</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在<code>config.yml</code>里配置一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">    path: sitemap.xml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>让我们搭一个美美的博客，一起写写写吧~~~</p>","more":"<h2 id=\"Requirement\"><a href=\"#Requirement\" class=\"headerlink\" title=\"Requirement\"></a>Requirement</h2><p>​    brew, hexo, Node.js</p>\n<h3 id=\"Hexo项目\"><a href=\"#Hexo项目\" class=\"headerlink\" title=\"Hexo项目\"></a>Hexo项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init           <span class=\"comment\"># 新建博客目录</span></span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postname\"</span> <span class=\"comment\"># 生成postname.md文件</span></span><br><span class=\"line\">$ hexo clean          <span class=\"comment\"># 清空生成的网页</span></span><br><span class=\"line\">$ hexo generate       <span class=\"comment\"># 根据当前目录下文件生成静态网页</span></span><br><span class=\"line\">$ hexo server \t      <span class=\"comment\"># 启动服务器</span></span><br></pre></td></tr></table></figure>\n<p>通过访问localhost:4000可以在本地调试。文件目录<code>source</code>下的<code>_posts</code>中可以添加用户新增加的博客内容（Markdown语法）。</p>\n<p>More info: <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">Heox</a></p>\n<h3 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>修改<code>config.yml</code>配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_excerpt:   <span class=\"comment\"># 可通过 &lt;!-- more --&gt; 标签自动截断, 增加阅读全文按钮。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  length: 150</span><br><span class=\"line\"></span><br><span class=\"line\">busuanzi_count: <span class=\"comment\"># 监听网页浏览量。</span></span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加新的导航栏\"><a href=\"#添加新的导航栏\" class=\"headerlink\" title=\"添加新的导航栏\"></a>添加新的导航栏</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page tags   <span class=\"comment\"># 添加tags标签页</span></span><br></pre></td></tr></table></figure>\n<p>修改<code>source</code>目录下的<code>tags</code>中的<code>index.md</code>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2018-10-30 17:23:49</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>在菜单中添加链接。编辑<code>config.yml</code>配置文件中的menu属性，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /</span><br><span class=\"line\">  archives: /archives</span><br><span class=\"line\">  tags : /tags</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署到-Github\"><a href=\"#部署到-Github\" class=\"headerlink\" title=\"部署到 Github\"></a>部署到 Github</h3><p>修改<code>config.yml</code>配置文件中的deploy属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git </span><br><span class=\"line\">  repo: https://github.com/<span class=\"built_in\">test</span>/test.github.io.git  <span class=\"comment\"># github路径</span></span><br></pre></td></tr></table></figure>\n<p>通过下面的指令实现部署：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Google-收录博客网站\"><a href=\"#Google-收录博客网站\" class=\"headerlink\" title=\"Google 收录博客网站\"></a>Google 收录博客网站</h3><ol>\n<li><p>添加站点：用自己的 Google 帐号登陆 <a href=\"https://www.google.com/webmasters/verification/home?hl=en\" target=\"_blank\" rel=\"noopener\">Webmaster Central</a>。</p>\n</li>\n<li><p>验证站点: 将网站上的验证文件放在 <code>source</code> 文件下，在站点配置文件配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skip_render: google10bb50e0b38f396b.html</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生 sitemap：借助  hexo-generator-sitemap 工具自动生成，并在<code>config.yml</code>里配置一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">    path: sitemap.xml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br></pre></td></tr></table></figure>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjszht7yl0001kvpxxvogkhbc","category_id":"cjszht7z10005kvpxqgq138iq","_id":"cjszht7zo000ekvpxvhsk4ntq"},{"post_id":"cjszht7zi000ckvpxs4ggavy8","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht7zv000kkvpx5hp7738v"},{"post_id":"cjszht7ys0003kvpxhuo0wkh6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht7zz000pkvpxiq9xcp0w"},{"post_id":"cjszht7zk000dkvpxuoez5fmn","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht804000rkvpxu083b47x"},{"post_id":"cjszht7zq000hkvpxdycfnvql","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht807000vkvpxm4erxt7r"},{"post_id":"cjszht7z60007kvpxga59w8li","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht80c000xkvpx5gnz3cb0"},{"post_id":"cjszht7zu000jkvpx76v7poz6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht80e000zkvpxa5fcjjkb"},{"post_id":"cjszht7zx000okvpxbil6d12r","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht80h0013kvpxffaqh11c"},{"post_id":"cjszht7zd0008kvpx8z1kwc3n","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht80l0016kvpxt8r0xb7b"},{"post_id":"cjszht802000qkvpxe6vtf17e","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht80u001akvpx1h8mdj9w"},{"post_id":"cjszht805000ukvpxagmy4m62","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81g001ckvpx8b8275sc"},{"post_id":"cjszht7zf0009kvpxah1liqtj","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81i001gkvpxr9lb2ggg"},{"post_id":"cjszht80a000wkvpxk4vbooim","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81j001jkvpxkds978zg"},{"post_id":"cjszht80c000ykvpxa6pw69b5","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81m001nkvpx0fcuddvh"},{"post_id":"cjszht80f0012kvpxnu78t3q6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81p001qkvpx2cu5fawo"},{"post_id":"cjszht80i0015kvpxa3ps0hpx","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81t001ukvpxxsg3vbx7"},{"post_id":"cjszht80n0019kvpxyc60z9pv","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht81y001xkvpx7ste5anc"},{"post_id":"cjszht81b001bkvpxy0ksk1gq","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8200020kvpxbpn797oa"},{"post_id":"cjszht81h001fkvpx1w7z6d9i","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8220022kvpxwxzelwsh"},{"post_id":"cjszht81i001ikvpxfc35m3zs","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8250025kvpxqi4fo5v7"},{"post_id":"cjszht81l001mkvpxjyw2e4ct","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8270027kvpx6q5tjmgm"},{"post_id":"cjszht81o001pkvpxuail8flb","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82a002akvpx5dxobevp"},{"post_id":"cjszht81s001tkvpxfjyfj0lg","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82c002dkvpxtuidbfwu"},{"post_id":"cjszht81v001wkvpxhapcw10w","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82d002hkvpxd07k1waj"},{"post_id":"cjszht81z001zkvpxrki8zcam","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82g002kkvpxa3ulh6t0"},{"post_id":"cjszht8210021kvpxe027myx9","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82i002okvpx0x6qowdy"},{"post_id":"cjszht8230024kvpxyektq6um","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82j002qkvpxf2ph2ox9"},{"post_id":"cjszht8250026kvpxk5lq2woi","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82k002tkvpxffk8wm80"},{"post_id":"cjszht8280029kvpx1jnsdars","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82l002wkvpx6zlazx3j"},{"post_id":"cjszht82b002ckvpxxjwo0611","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82m0030kvpx63sn3vkc"},{"post_id":"cjszht82c002gkvpxwiio3s92","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82n0033kvpxn4kqqx6v"},{"post_id":"cjszht82e002jkvpx3zywtw5y","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82p0036kvpxmd1nglr9"},{"post_id":"cjszht82h002nkvpx28220drm","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82q0038kvpx4pqa77am"},{"post_id":"cjszht82i002pkvpxztu9579r","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82t003akvpx7rnfwrth"},{"post_id":"cjszht82j002skvpx9rs7qs8j","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82v003dkvpxlppuvuc7"},{"post_id":"cjszht82l002vkvpxy5ncz05s","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82w003fkvpxynmfhh00"},{"post_id":"cjszht82m002zkvpxfmbw5m81","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht82y003ikvpxhawzrcgp"},{"post_id":"cjszht82n0032kvpxpz7ugla2","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht831003lkvpxyzxn5nz2"},{"post_id":"cjszht82o0035kvpx3xwugzbf","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht833003pkvpxnco7pqj9"},{"post_id":"cjszht82p0037kvpxaxh3tlhk","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht835003skvpxf8zvh7j4"},{"post_id":"cjszht82r0039kvpx2r0tt9qf","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht836003wkvpxao3hgta4"},{"post_id":"cjszht82u003ckvpxqhtqiza6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht837003ykvpx6uoes6il"},{"post_id":"cjszht82v003ekvpxhi0l2skc","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8380041kvpx2e1zkv51"},{"post_id":"cjszht82w003hkvpx46szbsq7","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83a0044kvpx83o99r1l"},{"post_id":"cjszht82z003kkvpxhngqa6nb","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83b0048kvpxmewsbyf7"},{"post_id":"cjszht833003okvpxw3kfdski","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83d004bkvpx5mjtuuu0"},{"post_id":"cjszht834003rkvpxv5strfep","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83e004fkvpxob91i791"},{"post_id":"cjszht836003vkvpxvjpm99qs","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83g004ikvpxw3wtw2pt"},{"post_id":"cjszht836003xkvpxtcrnrelj","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83h004lkvpxxacedoxr"},{"post_id":"cjszht8380040kvpxtkdl8c0k","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83i004pkvpxnq28q9fh"},{"post_id":"cjszht8390043kvpxus7rb68f","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83j004skvpxwym50b7x"},{"post_id":"cjszht83a0047kvpx1w3it9x3","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83k004wkvpxsionegoo"},{"post_id":"cjszht83c004akvpxyvlw389o","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83l004zkvpxku5ef4nf"},{"post_id":"cjszht83e004ekvpxy0kw89g6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83n0053kvpx5l33vbb2"},{"post_id":"cjszht83f004hkvpx1e25xvsc","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83o0055kvpxdghb9kt5"},{"post_id":"cjszht83g004kkvpxnl8o46nu","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83r0058kvpxoiz6r115"},{"post_id":"cjszht83h004okvpx3cvtzho1","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83t005bkvpxm6q1k9hl"},{"post_id":"cjszht83i004rkvpx1ttgkf2r","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83u005fkvpxdgvhl4gy"},{"post_id":"cjszht83j004vkvpxb9at7vnt","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht83x005ikvpxnskm10m9"},{"post_id":"cjszht83l004ykvpxbqbp7fbl","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht840005mkvpx9d9orn68"},{"post_id":"cjszht83m0052kvpx00dseizv","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht841005pkvpxly0osjse"},{"post_id":"cjszht83n0054kvpx3ksm4wp5","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht843005tkvpxzvk6wtmu"},{"post_id":"cjszht83o0057kvpxznbn61jz","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht844005wkvpx7yisv5zf"},{"post_id":"cjszht83r005akvpx622bzyam","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8450060kvpxodoig7lm"},{"post_id":"cjszht83t005ekvpx6kfn72vx","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8460063kvpx4i19gqa8"},{"post_id":"cjszht83u005hkvpxkust0c23","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht8480067kvpx2j15mgef"},{"post_id":"cjszht83y005lkvpxi7ndj2vy","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84b006akvpxx38ebe0q"},{"post_id":"cjszht840005okvpxuv35p3l0","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84c006ekvpxlyu01spe"},{"post_id":"cjszht842005skvpxwhe1de83","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84e006hkvpxgsne8h6l"},{"post_id":"cjszht843005vkvpxrnkx0q9y","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84f006lkvpx2oifukwi"},{"post_id":"cjszht844005zkvpxjsvp7rqc","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84g006okvpxea1jiq3d"},{"post_id":"cjszht8460062kvpxe7ll7r9h","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84h006skvpx8ko1cuvm"},{"post_id":"cjszht8470066kvpx5sz0al2p","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84j006vkvpxbl7vtnm9"},{"post_id":"cjszht8490069kvpx0jfu7bae","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84k006ykvpxa1v98ymr"},{"post_id":"cjszht84c006dkvpxuasc8ro6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84l0072kvpxqtmjip3o"},{"post_id":"cjszht84d006gkvpxbf61kw88","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84q0075kvpxipp732jp"},{"post_id":"cjszht84e006kkvpxft6sv3kh","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84s0079kvpxu3xtdum6"},{"post_id":"cjszht84g006nkvpxqqlh0qm5","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84u007ckvpxdxk2tj63"},{"post_id":"cjszht84h006rkvpx2h40aylm","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84w007gkvpxr01rztve"},{"post_id":"cjszht84i006ukvpxuoxxz6dy","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84y007jkvpx1a8igkdo"},{"post_id":"cjszht84j006xkvpxiuazt88r","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht84z007nkvpxp4nsdxuw"},{"post_id":"cjszht84k0071kvpxbendkcp4","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht857007qkvpxh482gqvm"},{"post_id":"cjszht84l0074kvpxb8il6dsm","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85a007ukvpxbfgs4jbo"},{"post_id":"cjszht84r0078kvpx8h476r3e","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85c007xkvpxhggrc6rt"},{"post_id":"cjszht84s007bkvpxsp49kjah","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85d0081kvpxlvuy1a43"},{"post_id":"cjszht84w007fkvpxm46bxvur","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85e0084kvpxremli2u4"},{"post_id":"cjszht84x007ikvpx9sfhegk4","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85g0088kvpxcwuvfsi8"},{"post_id":"cjszht84y007mkvpx9o8o3s6k","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85i008bkvpx9hcdcigq"},{"post_id":"cjszht856007pkvpx7lk75qxw","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85j008fkvpxw5esaa1s"},{"post_id":"cjszht859007tkvpxq292tx4b","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85l008ikvpxrpkun9r7"},{"post_id":"cjszht85b007wkvpxepp3cwst","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85n008mkvpxc1qspyx4"},{"post_id":"cjszht85d0080kvpxkmslmxld","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85r008pkvpx0p1m7qce"},{"post_id":"cjszht85e0083kvpxrgzvk3yb","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85s008tkvpxpvo7q65g"},{"post_id":"cjszht85f0087kvpx2v5itfol","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85u008wkvpxc9v8jnd0"},{"post_id":"cjszht85h008akvpxdkz864m2","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85v0090kvpxmnlk4t0n"},{"post_id":"cjszht85i008ekvpx91rhp1ei","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85w0093kvpxqumenlcj"},{"post_id":"cjszht85k008hkvpxosomlnhe","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85x0097kvpxum46q31n"},{"post_id":"cjszht85m008lkvpxlv8gmfri","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht85z009akvpxudb8j2rr"},{"post_id":"cjszht85p008okvpx3jn5xgql","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht860009ekvpxzax4rno4"},{"post_id":"cjszht85s008skvpxd9avk1s6","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht862009hkvpxgls22ymh"},{"post_id":"cjszht85t008vkvpx55s4jr3c","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht863009lkvpxg65li8ds"},{"post_id":"cjszht85u008zkvpxkqlx16bd","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht865009okvpxztnxakeh"},{"post_id":"cjszht85v0092kvpx499v4kpk","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht867009skvpxcpkst0ex"},{"post_id":"cjszht85x0096kvpxdy5f7hi5","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht869009vkvpxmd8o874k"},{"post_id":"cjszht85y0099kvpx7e0j5yr1","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86a009zkvpxw0h4ntr9"},{"post_id":"cjszht85z009dkvpxq0zyr66f","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86b00a2kvpxkd8221in"},{"post_id":"cjszht861009gkvpx71uzrkze","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86d00a6kvpx4166jzi4"},{"post_id":"cjszht862009kkvpxiukanypd","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86f00a9kvpxgrtx0qgz"},{"post_id":"cjszht864009nkvpx06d704ji","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86i00adkvpx510q4yx7"},{"post_id":"cjszht866009rkvpxtcn79u5s","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86k00agkvpxm1dky7pz"},{"post_id":"cjszht868009ukvpxgy60arvn","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86n00akkvpxebfvvcg8"},{"post_id":"cjszht869009ykvpxxewyzxhn","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86o00ankvpx8a9x5gi8"},{"post_id":"cjszht86b00a1kvpx4kr7239k","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86r00arkvpx5eypodw6"},{"post_id":"cjszht86c00a5kvpxx87e271e","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86r00atkvpxwmryx7lp"},{"post_id":"cjszht86g00ackvpxgkj6qdvl","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86s00awkvpx4a4qy52n"},{"post_id":"cjszht86i00afkvpx3apr0bkd","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86s00aykvpxl5roervd"},{"post_id":"cjszht86m00ajkvpxc6809j57","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86s00b1kvpxoiueh527"},{"post_id":"cjszht86n00amkvpx83hsvp08","category_id":"cjszht7z10005kvpxqgq138iq","_id":"cjszht86s00b3kvpxiu60c1b3"},{"post_id":"cjszht86p00aqkvpx5dolsm5w","category_id":"cjszht7zh000akvpxc2soe4eg","_id":"cjszht86t00b6kvpxd3o87c9q"},{"post_id":"cjszht8gs00l0kvpxcgmq8k74","category_id":"cjszht8h000l1kvpxm4m7yeb6","_id":"cjszht8h900l4kvpxxt09ok49"}],"PostTag":[{"post_id":"cjszht7yl0001kvpxxvogkhbc","tag_id":"cjszht7z40006kvpx0rkbji89","_id":"cjszht7zs000ikvpxhe8cfp5t"},{"post_id":"cjszht7yl0001kvpxxvogkhbc","tag_id":"cjszht7zh000bkvpxhgdn07kf","_id":"cjszht7zv000lkvpx5jaz9ags"},{"post_id":"cjszht7ys0003kvpxhuo0wkh6","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht80f0011kvpxjfskgvsz"},{"post_id":"cjszht7ys0003kvpxhuo0wkh6","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht80i0014kvpx2yx2z8rt"},{"post_id":"cjszht7ys0003kvpxhuo0wkh6","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht80n0018kvpxiva8kpvb"},{"post_id":"cjszht80n0019kvpxyc60z9pv","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht81h001ekvpx099vtgsy"},{"post_id":"cjszht80n0019kvpxyc60z9pv","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht81i001hkvpxcdq4c14u"},{"post_id":"cjszht80n0019kvpxyc60z9pv","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht81k001lkvpxwfsui1th"},{"post_id":"cjszht7z60007kvpxga59w8li","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht81o001okvpx3p9wsh0u"},{"post_id":"cjszht7z60007kvpxga59w8li","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht81s001skvpxvroonj5u"},{"post_id":"cjszht7z60007kvpxga59w8li","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht81v001vkvpx3towie65"},{"post_id":"cjszht7zd0008kvpx8z1kwc3n","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht82a002bkvpxv7z0hq4j"},{"post_id":"cjszht7zd0008kvpx8z1kwc3n","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht82c002ekvpxw5zlicaw"},{"post_id":"cjszht7zd0008kvpx8z1kwc3n","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht82d002ikvpxhx7sqwjd"},{"post_id":"cjszht7zd0008kvpx8z1kwc3n","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht82g002lkvpxlkc818uu"},{"post_id":"cjszht7zf0009kvpxah1liqtj","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht82l002ukvpx6d9s7ea0"},{"post_id":"cjszht7zf0009kvpxah1liqtj","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht82m002xkvpxv9kg8o63"},{"post_id":"cjszht7zf0009kvpxah1liqtj","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht82n0031kvpxevbyv177"},{"post_id":"cjszht7zi000ckvpxs4ggavy8","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht82y003jkvpxuymvvae1"},{"post_id":"cjszht7zi000ckvpxs4ggavy8","tag_id":"cjszht82m002ykvpxhssyygp8","_id":"cjszht832003mkvpx5lhs7bro"},{"post_id":"cjszht7zi000ckvpxs4ggavy8","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht833003qkvpxto2rbhke"},{"post_id":"cjszht7zi000ckvpxs4ggavy8","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht835003tkvpx1equa0rj"},{"post_id":"cjszht7zk000dkvpxuoez5fmn","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht8380042kvpxdvaqsdfk"},{"post_id":"cjszht7zk000dkvpxuoez5fmn","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht83a0045kvpxum34t4kk"},{"post_id":"cjszht7zk000dkvpxuoez5fmn","tag_id":"cjszht835003ukvpxfl17whuf","_id":"cjszht83c0049kvpx0w0ez2ue"},{"post_id":"cjszht8390043kvpxus7rb68f","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht83d004ckvpx2nfuku19"},{"post_id":"cjszht8390043kvpxus7rb68f","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht83f004gkvpxtnkyhoil"},{"post_id":"cjszht8390043kvpxus7rb68f","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht83g004jkvpxasycpsfl"},{"post_id":"cjszht7zq000hkvpxdycfnvql","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht83h004nkvpx2j2dorzh"},{"post_id":"cjszht7zq000hkvpxdycfnvql","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht83i004qkvpxbc06wku5"},{"post_id":"cjszht7zq000hkvpxdycfnvql","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht83j004ukvpxqqehkju6"},{"post_id":"cjszht83i004rkvpx1ttgkf2r","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht83k004xkvpxj3ovb0if"},{"post_id":"cjszht83i004rkvpx1ttgkf2r","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht83m0051kvpxn1b8kj9k"},{"post_id":"cjszht7zu000jkvpx76v7poz6","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht83r0059kvpxjo0wpe3a"},{"post_id":"cjszht7zu000jkvpx76v7poz6","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht83t005ckvpxqax7fg4s"},{"post_id":"cjszht7zu000jkvpx76v7poz6","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht83u005gkvpxqdkghwhr"},{"post_id":"cjszht83n0054kvpx3ksm4wp5","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht83x005jkvpx76zo4j5m"},{"post_id":"cjszht83n0054kvpx3ksm4wp5","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht840005nkvpx306213gt"},{"post_id":"cjszht83n0054kvpx3ksm4wp5","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht841005qkvpxx4cy6ys0"},{"post_id":"cjszht83o0057kvpxznbn61jz","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht843005ukvpxzcg1j3op"},{"post_id":"cjszht83o0057kvpxznbn61jz","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht844005xkvpx4zhnr6dj"},{"post_id":"cjszht83o0057kvpxznbn61jz","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht8450061kvpxluw3c2kl"},{"post_id":"cjszht83y005lkvpxi7ndj2vy","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht8470064kvpxbiqjy8c0"},{"post_id":"cjszht83y005lkvpxi7ndj2vy","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht8490068kvpxcj1qmu7l"},{"post_id":"cjszht83y005lkvpxi7ndj2vy","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht84b006bkvpx810ejnz4"},{"post_id":"cjszht7zx000okvpxbil6d12r","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht84d006fkvpx53k9300u"},{"post_id":"cjszht7zx000okvpxbil6d12r","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht84e006ikvpxo3tlukdq"},{"post_id":"cjszht7zx000okvpxbil6d12r","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht84f006mkvpxzzwt3z3d"},{"post_id":"cjszht7zx000okvpxbil6d12r","tag_id":"cjszht835003ukvpxfl17whuf","_id":"cjszht84g006pkvpxzrbn8s14"},{"post_id":"cjszht840005okvpxuv35p3l0","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht84i006tkvpxvuu1gwvs"},{"post_id":"cjszht840005okvpxuv35p3l0","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht84j006wkvpxucc1jocv"},{"post_id":"cjszht840005okvpxuv35p3l0","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht84k0070kvpxbhmhiwfm"},{"post_id":"cjszht842005skvpxwhe1de83","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht84l0073kvpxe9j20sdw"},{"post_id":"cjszht842005skvpxwhe1de83","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht84r0077kvpx261cefay"},{"post_id":"cjszht842005skvpxwhe1de83","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht84s007akvpx6yfrry3v"},{"post_id":"cjszht843005vkvpxrnkx0q9y","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht84v007ekvpxqa1xrug9"},{"post_id":"cjszht843005vkvpxrnkx0q9y","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht84w007hkvpxrci8g9xz"},{"post_id":"cjszht843005vkvpxrnkx0q9y","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht84y007lkvpxrxsco9p0"},{"post_id":"cjszht802000qkvpxe6vtf17e","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht855007okvpxkt5dg62u"},{"post_id":"cjszht802000qkvpxe6vtf17e","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht858007skvpxz8xrrrtw"},{"post_id":"cjszht8470066kvpx5sz0al2p","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht85b007vkvpxx3ls2k6k"},{"post_id":"cjszht8470066kvpx5sz0al2p","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht85c007zkvpx8pydrfqy"},{"post_id":"cjszht8470066kvpx5sz0al2p","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht85d0082kvpxdi6n09id"},{"post_id":"cjszht8490069kvpx0jfu7bae","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht85f0086kvpx0jgn46kx"},{"post_id":"cjszht8490069kvpx0jfu7bae","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht85g0089kvpx5effwpzk"},{"post_id":"cjszht8490069kvpx0jfu7bae","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht85i008dkvpxpelmctav"},{"post_id":"cjszht84d006gkvpxbf61kw88","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht85j008gkvpxvjhoyhc5"},{"post_id":"cjszht84d006gkvpxbf61kw88","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht85m008kkvpxjfx3jqo2"},{"post_id":"cjszht84d006gkvpxbf61kw88","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht85n008nkvpxe4livqmc"},{"post_id":"cjszht805000ukvpxagmy4m62","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht85r008rkvpxqvv049t2"},{"post_id":"cjszht805000ukvpxagmy4m62","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht85t008ukvpx1063akbi"},{"post_id":"cjszht805000ukvpxagmy4m62","tag_id":"cjszht835003ukvpxfl17whuf","_id":"cjszht85u008ykvpxzgagviz2"},{"post_id":"cjszht84i006ukvpxuoxxz6dy","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht85v0091kvpxvmylcdv2"},{"post_id":"cjszht84i006ukvpxuoxxz6dy","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht85w0095kvpxf9lij7ei"},{"post_id":"cjszht80a000wkvpxk4vbooim","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht85y0098kvpxwul4cpgx"},{"post_id":"cjszht80a000wkvpxk4vbooim","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht85z009ckvpxz77dqb73"},{"post_id":"cjszht80a000wkvpxk4vbooim","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht861009fkvpxxcmv1sh8"},{"post_id":"cjszht84l0074kvpxb8il6dsm","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht862009jkvpxjd20c2st"},{"post_id":"cjszht84l0074kvpxb8il6dsm","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht864009mkvpxxqqxkhmw"},{"post_id":"cjszht84l0074kvpxb8il6dsm","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht866009pkvpxp04mmq2a"},{"post_id":"cjszht84r0078kvpx8h476r3e","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht867009tkvpx1stndluc"},{"post_id":"cjszht84r0078kvpx8h476r3e","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht869009wkvpx3d95dik4"},{"post_id":"cjszht80c000ykvpxa6pw69b5","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86b00a0kvpxeh8yp92y"},{"post_id":"cjszht80c000ykvpxa6pw69b5","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86c00a3kvpx46qk2inr"},{"post_id":"cjszht80c000ykvpxa6pw69b5","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht86e00a7kvpx3zdhecr4"},{"post_id":"cjszht80c000ykvpxa6pw69b5","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht86f00aakvpxxg83mazs"},{"post_id":"cjszht84s007bkvpxsp49kjah","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86i00aekvpxtslg5gzr"},{"post_id":"cjszht84s007bkvpxsp49kjah","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht86l00ahkvpxv8s1g6fa"},{"post_id":"cjszht80f0012kvpxnu78t3q6","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86n00alkvpxbzcn5697"},{"post_id":"cjszht80f0012kvpxnu78t3q6","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht86p00aokvpxuoifl9o9"},{"post_id":"cjszht84y007mkvpx9o8o3s6k","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86r00askvpxloe9rcgg"},{"post_id":"cjszht84y007mkvpx9o8o3s6k","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86r00aukvpxgcwhbptd"},{"post_id":"cjszht84y007mkvpx9o8o3s6k","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht86s00axkvpxv7gl954n"},{"post_id":"cjszht856007pkvpx7lk75qxw","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht86s00azkvpxisxz34dy"},{"post_id":"cjszht856007pkvpx7lk75qxw","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86s00b2kvpx0j759227"},{"post_id":"cjszht856007pkvpx7lk75qxw","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht86s00b4kvpx3td3apir"},{"post_id":"cjszht859007tkvpxq292tx4b","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86t00b7kvpxwx5esm2y"},{"post_id":"cjszht859007tkvpxq292tx4b","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86u00b8kvpxpz5eydj8"},{"post_id":"cjszht859007tkvpxq292tx4b","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht86u00bakvpx3r4ds09k"},{"post_id":"cjszht80i0015kvpxa3ps0hpx","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86u00bbkvpx84xjfi7n"},{"post_id":"cjszht80i0015kvpxa3ps0hpx","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86v00bdkvpxjwme2nnq"},{"post_id":"cjszht80i0015kvpxa3ps0hpx","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht86v00bekvpxt6lf5q2w"},{"post_id":"cjszht80i0015kvpxa3ps0hpx","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht86v00bgkvpxyhsgpsm3"},{"post_id":"cjszht85b007wkvpxepp3cwst","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86v00bhkvpxurqrqmb8"},{"post_id":"cjszht85b007wkvpxepp3cwst","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86v00bjkvpxcdvuc6r0"},{"post_id":"cjszht85b007wkvpxepp3cwst","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht86v00bkkvpxsc6vg67x"},{"post_id":"cjszht85d0080kvpxkmslmxld","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86w00bmkvpxgn39diuu"},{"post_id":"cjszht85d0080kvpxkmslmxld","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht86w00bnkvpxge6bd4dm"},{"post_id":"cjszht85d0080kvpxkmslmxld","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht86w00bpkvpxmx80y8we"},{"post_id":"cjszht85f0087kvpx2v5itfol","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86w00bqkvpx3qjz8p3w"},{"post_id":"cjszht85f0087kvpx2v5itfol","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86x00bskvpxlyu3g1td"},{"post_id":"cjszht85i008ekvpx91rhp1ei","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86x00btkvpxm2waeygp"},{"post_id":"cjszht85i008ekvpx91rhp1ei","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86x00bvkvpxz4qg0exh"},{"post_id":"cjszht81b001bkvpxy0ksk1gq","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht86x00bwkvpxt17zd8xo"},{"post_id":"cjszht81b001bkvpxy0ksk1gq","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht86x00bykvpxttz94rn9"},{"post_id":"cjszht81b001bkvpxy0ksk1gq","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht86x00bzkvpxwdv2gc04"},{"post_id":"cjszht85m008lkvpxlv8gmfri","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86y00c1kvpxibov261m"},{"post_id":"cjszht85m008lkvpxlv8gmfri","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht86y00c2kvpxixkzg5ri"},{"post_id":"cjszht85m008lkvpxlv8gmfri","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht86y00c4kvpxyn92le87"},{"post_id":"cjszht85p008okvpx3jn5xgql","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht86y00c5kvpxwx0ekq9q"},{"post_id":"cjszht85p008okvpx3jn5xgql","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht86y00c7kvpxgu8omrt7"},{"post_id":"cjszht85p008okvpx3jn5xgql","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht86y00c8kvpx4ry1hm2r"},{"post_id":"cjszht85p008okvpx3jn5xgql","tag_id":"cjszht835003ukvpxfl17whuf","_id":"cjszht86z00cakvpxexva0bkd"},{"post_id":"cjszht81h001fkvpx1w7z6d9i","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht86z00cbkvpxe5nzhv5d"},{"post_id":"cjszht81h001fkvpx1w7z6d9i","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht86z00cdkvpx2bvolm2k"},{"post_id":"cjszht85y0099kvpx7e0j5yr1","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht86z00cekvpx1cgiuv6y"},{"post_id":"cjszht85y0099kvpx7e0j5yr1","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht87000cgkvpx9ob8dk3h"},{"post_id":"cjszht85y0099kvpx7e0j5yr1","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87000chkvpxh1iujcx3"},{"post_id":"cjszht81i001ikvpxfc35m3zs","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht87000cjkvpxtqra3zr3"},{"post_id":"cjszht81i001ikvpxfc35m3zs","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht87000ckkvpx6fotxepb"},{"post_id":"cjszht81i001ikvpxfc35m3zs","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht87100cmkvpxaee0o3cn"},{"post_id":"cjszht861009gkvpx71uzrkze","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87100cnkvpxatp59eb7"},{"post_id":"cjszht861009gkvpx71uzrkze","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87200cpkvpx0dwuon46"},{"post_id":"cjszht861009gkvpx71uzrkze","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87200cqkvpxis0ov42x"},{"post_id":"cjszht862009kkvpxiukanypd","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87200cskvpxf3li83wg"},{"post_id":"cjszht862009kkvpxiukanypd","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87200ctkvpxu25u3to3"},{"post_id":"cjszht862009kkvpxiukanypd","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87300cvkvpxz8ev9u0m"},{"post_id":"cjszht864009nkvpx06d704ji","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht87300cwkvpxv3d55a6t"},{"post_id":"cjszht864009nkvpx06d704ji","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht87300cykvpxcsa7zy6r"},{"post_id":"cjszht864009nkvpx06d704ji","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87400czkvpxytuymygg"},{"post_id":"cjszht866009rkvpxtcn79u5s","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht87400d1kvpxjvelq0r0"},{"post_id":"cjszht866009rkvpxtcn79u5s","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87400d2kvpx0pcmh82r"},{"post_id":"cjszht866009rkvpxtcn79u5s","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht87400d4kvpxugj8stw9"},{"post_id":"cjszht868009ukvpxgy60arvn","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87500d5kvpxf2z5j3wc"},{"post_id":"cjszht868009ukvpxgy60arvn","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht87500d7kvpxcripfx31"},{"post_id":"cjszht868009ukvpxgy60arvn","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht87500d8kvpxdqlhewmi"},{"post_id":"cjszht869009ykvpxxewyzxhn","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87600dakvpxulk8zpyp"},{"post_id":"cjszht869009ykvpxxewyzxhn","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht87600dbkvpx4wzuqq2j"},{"post_id":"cjszht81l001mkvpxjyw2e4ct","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht87600ddkvpx7pnbt535"},{"post_id":"cjszht81l001mkvpxjyw2e4ct","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87600dekvpxwdfxzwcz"},{"post_id":"cjszht81l001mkvpxjyw2e4ct","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87600dgkvpxsytb5rmi"},{"post_id":"cjszht86c00a5kvpxx87e271e","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87700dhkvpx7gq2d573"},{"post_id":"cjszht86c00a5kvpxx87e271e","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87700djkvpx6l68hjvk"},{"post_id":"cjszht86e00a8kvpxyq1hy0vu","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87700dkkvpx4xhujwy2"},{"post_id":"cjszht86e00a8kvpxyq1hy0vu","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87700dmkvpxoc80hha3"},{"post_id":"cjszht86e00a8kvpxyq1hy0vu","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht87700dnkvpx3obc7m1w"},{"post_id":"cjszht86g00ackvpxgkj6qdvl","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht87800dpkvpx987zhl86"},{"post_id":"cjszht86g00ackvpxgkj6qdvl","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87800dqkvpx9rius002"},{"post_id":"cjszht86g00ackvpxgkj6qdvl","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht87800dskvpxhzhmj18k"},{"post_id":"cjszht81o001pkvpxuail8flb","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87800dtkvpx9v45jtua"},{"post_id":"cjszht81o001pkvpxuail8flb","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87900dvkvpxsvswrzlh"},{"post_id":"cjszht81o001pkvpxuail8flb","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87900dwkvpx9d8rse1p"},{"post_id":"cjszht86i00afkvpx3apr0bkd","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87900dykvpxv35578sk"},{"post_id":"cjszht86i00afkvpx3apr0bkd","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht87a00dzkvpxzjtvst96"},{"post_id":"cjszht86i00afkvpx3apr0bkd","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht87b00e1kvpxhowuw0wo"},{"post_id":"cjszht86m00ajkvpxc6809j57","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht87b00e2kvpx9toykg05"},{"post_id":"cjszht86m00ajkvpxc6809j57","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht87b00e4kvpx8p4aouoy"},{"post_id":"cjszht86m00ajkvpxc6809j57","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht87b00e5kvpxb3s718z4"},{"post_id":"cjszht86p00aqkvpx5dolsm5w","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87c00e7kvpxj7k7yppv"},{"post_id":"cjszht86p00aqkvpx5dolsm5w","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87c00e8kvpxm8xgynac"},{"post_id":"cjszht81s001tkvpxfjyfj0lg","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87c00eakvpx9qoi8nv2"},{"post_id":"cjszht81s001tkvpxfjyfj0lg","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht87c00ebkvpx7s58o5ha"},{"post_id":"cjszht81s001tkvpxfjyfj0lg","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht87c00edkvpx4stevxdj"},{"post_id":"cjszht81v001wkvpxhapcw10w","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht87d00eekvpxw01472m7"},{"post_id":"cjszht81v001wkvpxhapcw10w","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87d00egkvpxwbvcjffb"},{"post_id":"cjszht81v001wkvpxhapcw10w","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87d00ehkvpxqva4emip"},{"post_id":"cjszht81z001zkvpxrki8zcam","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht87d00ejkvpx5q6zsu6m"},{"post_id":"cjszht81z001zkvpxrki8zcam","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87e00ekkvpxzlww3jd3"},{"post_id":"cjszht8210021kvpxe027myx9","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87e00emkvpxtuuhptdy"},{"post_id":"cjszht8210021kvpxe027myx9","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87e00enkvpx64xwxdnl"},{"post_id":"cjszht8210021kvpxe027myx9","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht87f00epkvpxhbdh5p1f"},{"post_id":"cjszht8230024kvpxyektq6um","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87f00eqkvpxgtb4e0m4"},{"post_id":"cjszht8230024kvpxyektq6um","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht87g00eskvpxgd9d0e8y"},{"post_id":"cjszht8230024kvpxyektq6um","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht87g00etkvpxqbwe9hqm"},{"post_id":"cjszht8250026kvpxk5lq2woi","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87g00eukvpxikqjvufy"},{"post_id":"cjszht8250026kvpxk5lq2woi","tag_id":"cjszht86v00blkvpxh0hbu8p5","_id":"cjszht87h00ewkvpxaahhphmn"},{"post_id":"cjszht8250026kvpxk5lq2woi","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht87h00exkvpx8ljvsprn"},{"post_id":"cjszht8280029kvpx1jnsdars","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87i00ezkvpxt1aeo1iv"},{"post_id":"cjszht8280029kvpx1jnsdars","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87i00f0kvpx66bsqb1l"},{"post_id":"cjszht8280029kvpx1jnsdars","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht87j00f2kvpxuu6op9l1"},{"post_id":"cjszht82b002ckvpxxjwo0611","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87j00f3kvpxkqfzvtg0"},{"post_id":"cjszht82b002ckvpxxjwo0611","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87l00f5kvpxii93lr8a"},{"post_id":"cjszht82b002ckvpxxjwo0611","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht87l00f6kvpxwpajml7c"},{"post_id":"cjszht82c002gkvpxwiio3s92","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht87n00f8kvpx0y2hufzk"},{"post_id":"cjszht82c002gkvpxwiio3s92","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87n00f9kvpxa1y3qywg"},{"post_id":"cjszht82c002gkvpxwiio3s92","tag_id":"cjszht86x00c0kvpxwyl6t4uq","_id":"cjszht87o00fbkvpxnu4ubb7i"},{"post_id":"cjszht82e002jkvpx3zywtw5y","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87o00fckvpxjdia6pod"},{"post_id":"cjszht82e002jkvpx3zywtw5y","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht87p00fekvpxby4n3abl"},{"post_id":"cjszht82e002jkvpx3zywtw5y","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87p00ffkvpxhe6qw3ux"},{"post_id":"cjszht82h002nkvpx28220drm","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht87r00fhkvpxo2e6evhi"},{"post_id":"cjszht82h002nkvpx28220drm","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87r00fikvpxtikdugky"},{"post_id":"cjszht82h002nkvpx28220drm","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht87r00fkkvpxgpqf0b9d"},{"post_id":"cjszht82i002pkvpxztu9579r","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87r00flkvpx3aeyt1qf"},{"post_id":"cjszht82i002pkvpxztu9579r","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht87s00fnkvpxavwb63ew"},{"post_id":"cjszht82i002pkvpxztu9579r","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht87s00fokvpxrwqyc1s6"},{"post_id":"cjszht82j002skvpx9rs7qs8j","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht87u00fqkvpxtzcg92ib"},{"post_id":"cjszht82j002skvpx9rs7qs8j","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87u00frkvpxwkv2bldq"},{"post_id":"cjszht82j002skvpx9rs7qs8j","tag_id":"cjszht87000clkvpxyyljylzk","_id":"cjszht87x00ftkvpxlr33cnw6"},{"post_id":"cjszht82l002vkvpxy5ncz05s","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht87x00fukvpxc9pkauwn"},{"post_id":"cjszht82l002vkvpxy5ncz05s","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht87y00fwkvpxrdivqb7w"},{"post_id":"cjszht82l002vkvpxy5ncz05s","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht87z00fxkvpxdcbhv7u3"},{"post_id":"cjszht82l002vkvpxy5ncz05s","tag_id":"cjszht87000clkvpxyyljylzk","_id":"cjszht88100fzkvpxg042280x"},{"post_id":"cjszht82m002zkvpxfmbw5m81","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht88100g0kvpx1zuswkfj"},{"post_id":"cjszht82m002zkvpxfmbw5m81","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht88100g2kvpx3l06l9yh"},{"post_id":"cjszht82m002zkvpxfmbw5m81","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht88100g3kvpxbcavtaif"},{"post_id":"cjszht82n0032kvpxpz7ugla2","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht88200g5kvpxjl2jeiek"},{"post_id":"cjszht82n0032kvpxpz7ugla2","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88200g6kvpxo2cld9qt"},{"post_id":"cjszht82n0032kvpxpz7ugla2","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht88300g8kvpxg1y3ymtt"},{"post_id":"cjszht82o0035kvpx3xwugzbf","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht88300g9kvpxnkrw0sp4"},{"post_id":"cjszht82o0035kvpx3xwugzbf","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88600gbkvpxkj01k9wk"},{"post_id":"cjszht82p0037kvpxaxh3tlhk","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht88600gckvpx1j7z8bf9"},{"post_id":"cjszht82p0037kvpxaxh3tlhk","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88700gekvpxaa0azon0"},{"post_id":"cjszht82r0039kvpx2r0tt9qf","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht88700gfkvpxsqswh24w"},{"post_id":"cjszht82r0039kvpx2r0tt9qf","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88700ghkvpxxye2aucj"},{"post_id":"cjszht82r0039kvpx2r0tt9qf","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht88800gikvpx2xumihew"},{"post_id":"cjszht82r0039kvpx2r0tt9qf","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht88800gkkvpxzw6ypbqt"},{"post_id":"cjszht82u003ckvpxqhtqiza6","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht88800glkvpx58nvzt5i"},{"post_id":"cjszht82u003ckvpxqhtqiza6","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88800gnkvpx86wlmgaw"},{"post_id":"cjszht82u003ckvpxqhtqiza6","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht88800gokvpxsuncyb5e"},{"post_id":"cjszht82v003ekvpxhi0l2skc","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht88c00gqkvpx0xbkj7d8"},{"post_id":"cjszht82v003ekvpxhi0l2skc","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht88c00grkvpxx2e8kzv4"},{"post_id":"cjszht82v003ekvpxhi0l2skc","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht88e00gtkvpxma024yek"},{"post_id":"cjszht82w003hkvpx46szbsq7","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht88e00gukvpx2swzuwe3"},{"post_id":"cjszht82w003hkvpx46szbsq7","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88f00gwkvpx969hszqg"},{"post_id":"cjszht82w003hkvpx46szbsq7","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht88f00gxkvpx1malt08d"},{"post_id":"cjszht82z003kkvpxhngqa6nb","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht88g00gzkvpxrjxiquxl"},{"post_id":"cjszht82z003kkvpxhngqa6nb","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht88g00h0kvpxpg2r0vg1"},{"post_id":"cjszht82z003kkvpxhngqa6nb","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht88h00h2kvpx31i3hs3s"},{"post_id":"cjszht82z003kkvpxhngqa6nb","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht88h00h3kvpx6qujhjy5"},{"post_id":"cjszht82z003kkvpxhngqa6nb","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht88i00h5kvpxvnhaqs7i"},{"post_id":"cjszht833003okvpxw3kfdski","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht88i00h6kvpx069isyvm"},{"post_id":"cjszht833003okvpxw3kfdski","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht88l00h8kvpx7hdchzvu"},{"post_id":"cjszht833003okvpxw3kfdski","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht88m00h9kvpxnc89cydl"},{"post_id":"cjszht834003rkvpxv5strfep","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht88m00hbkvpxtw8raxtf"},{"post_id":"cjszht834003rkvpxv5strfep","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht88m00hckvpx6nodviby"},{"post_id":"cjszht834003rkvpxv5strfep","tag_id":"cjszht82c002fkvpxvs1ilg3i","_id":"cjszht88n00hekvpx2ylfqf9b"},{"post_id":"cjszht834003rkvpxv5strfep","tag_id":"cjszht87f00erkvpx3btfnuuq","_id":"cjszht88n00hfkvpxztsyxio4"},{"post_id":"cjszht836003vkvpxvjpm99qs","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht88o00hhkvpxiakgqhfe"},{"post_id":"cjszht836003vkvpxvjpm99qs","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht88o00hikvpxjo77rg0e"},{"post_id":"cjszht836003vkvpxvjpm99qs","tag_id":"cjszht87f00erkvpx3btfnuuq","_id":"cjszht88p00hkkvpx1kvje7u8"},{"post_id":"cjszht836003vkvpxvjpm99qs","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht88p00hlkvpx2dmzfju3"},{"post_id":"cjszht836003xkvpxtcrnrelj","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht88q00hnkvpx7ruk3q2b"},{"post_id":"cjszht836003xkvpxtcrnrelj","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht88r00hokvpxv4qa0662"},{"post_id":"cjszht836003xkvpxtcrnrelj","tag_id":"cjszht86x00c0kvpxwyl6t4uq","_id":"cjszht88v00hqkvpx3k0f1000"},{"post_id":"cjszht8380040kvpxtkdl8c0k","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht88w00hrkvpxa45d8kzg"},{"post_id":"cjszht8380040kvpxtkdl8c0k","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht88x00htkvpx8upsvv3i"},{"post_id":"cjszht83a0047kvpx1w3it9x3","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht88x00hukvpx62go3oyy"},{"post_id":"cjszht83a0047kvpx1w3it9x3","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht89200hwkvpxzizj1txr"},{"post_id":"cjszht83a0047kvpx1w3it9x3","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht89200hxkvpxc3x8dgwc"},{"post_id":"cjszht83a0047kvpx1w3it9x3","tag_id":"cjszht835003ukvpxfl17whuf","_id":"cjszht89300hzkvpxb148ls3x"},{"post_id":"cjszht83c004akvpxyvlw389o","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89300i0kvpx1lijujfp"},{"post_id":"cjszht83c004akvpxyvlw389o","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89400i2kvpxlzl9fd23"},{"post_id":"cjszht83c004akvpxyvlw389o","tag_id":"cjszht87r00fjkvpxlrzkgek8","_id":"cjszht89400i3kvpxabfs1mgx"},{"post_id":"cjszht83c004akvpxyvlw389o","tag_id":"cjszht87f00erkvpx3btfnuuq","_id":"cjszht89400i5kvpxf2ut5ylx"},{"post_id":"cjszht83e004ekvpxy0kw89g6","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89500i6kvpxxzog0fng"},{"post_id":"cjszht83e004ekvpxy0kw89g6","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht89500i7kvpx3h9twth8"},{"post_id":"cjszht83e004ekvpxy0kw89g6","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht89600i9kvpx861m2y6w"},{"post_id":"cjszht83e004ekvpxy0kw89g6","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89600iakvpx3f2v6j3h"},{"post_id":"cjszht83f004hkvpx1e25xvsc","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89800ickvpxxtpqcxmq"},{"post_id":"cjszht83f004hkvpx1e25xvsc","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht89800idkvpxuorf8uif"},{"post_id":"cjszht83f004hkvpx1e25xvsc","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht89a00ifkvpx0m8agk0b"},{"post_id":"cjszht83g004kkvpxnl8o46nu","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89a00igkvpxm46i35u8"},{"post_id":"cjszht83g004kkvpxnl8o46nu","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht89d00iikvpxa2n6lonj"},{"post_id":"cjszht83g004kkvpxnl8o46nu","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89d00ijkvpxlvoskc2z"},{"post_id":"cjszht83h004okvpx3cvtzho1","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89e00ilkvpxvrptxdln"},{"post_id":"cjszht83h004okvpx3cvtzho1","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89f00imkvpxqul979id"},{"post_id":"cjszht83j004vkvpxb9at7vnt","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht89g00iokvpx0ll7s3y1"},{"post_id":"cjszht83j004vkvpxb9at7vnt","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht89g00ipkvpxk7mtyfm5"},{"post_id":"cjszht83l004ykvpxbqbp7fbl","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89i00irkvpx1kcuf9v6"},{"post_id":"cjszht83l004ykvpxbqbp7fbl","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89i00iskvpxd2ct1rn7"},{"post_id":"cjszht83l004ykvpxbqbp7fbl","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht89k00iukvpx62mr9mic"},{"post_id":"cjszht83m0052kvpx00dseizv","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89k00ivkvpxc3ku6mgz"},{"post_id":"cjszht83m0052kvpx00dseizv","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89l00iwkvpxhkyqux2k"},{"post_id":"cjszht83r005akvpx622bzyam","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89l00ixkvpxn8ixfaij"},{"post_id":"cjszht83r005akvpx622bzyam","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89l00iykvpxlelhwwk9"},{"post_id":"cjszht83t005ekvpx6kfn72vx","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89m00izkvpxtlfakbdw"},{"post_id":"cjszht83t005ekvpx6kfn72vx","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht89m00j0kvpxt5088g0s"},{"post_id":"cjszht83t005ekvpx6kfn72vx","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89m00j1kvpxkyxm1gx3"},{"post_id":"cjszht83u005hkvpxkust0c23","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89m00j2kvpxc981pbxh"},{"post_id":"cjszht83u005hkvpxkust0c23","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89m00j3kvpx69glcpae"},{"post_id":"cjszht844005zkvpxjsvp7rqc","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89m00j4kvpxjsqbcdfo"},{"post_id":"cjszht844005zkvpxjsvp7rqc","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89m00j5kvpxn0t2hizn"},{"post_id":"cjszht844005zkvpxjsvp7rqc","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht89m00j6kvpx5l60nzou"},{"post_id":"cjszht844005zkvpxjsvp7rqc","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89m00j7kvpxquwy378t"},{"post_id":"cjszht8460062kvpxe7ll7r9h","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89m00j8kvpxtfffxeui"},{"post_id":"cjszht8460062kvpxe7ll7r9h","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht89m00j9kvpxphyovfe1"},{"post_id":"cjszht8460062kvpxe7ll7r9h","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht89m00jakvpxywf4sgy0"},{"post_id":"cjszht84c006dkvpxuasc8ro6","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht89m00jbkvpxh8q27rwa"},{"post_id":"cjszht84c006dkvpxuasc8ro6","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89m00jckvpxhgu94jda"},{"post_id":"cjszht84e006kkvpxft6sv3kh","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89m00jdkvpx4ptusxlp"},{"post_id":"cjszht84e006kkvpxft6sv3kh","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89m00jekvpx5p7odx7w"},{"post_id":"cjszht84g006nkvpxqqlh0qm5","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89m00jfkvpxnhmmboep"},{"post_id":"cjszht84g006nkvpxqqlh0qm5","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89n00jgkvpx6mxzq466"},{"post_id":"cjszht84g006nkvpxqqlh0qm5","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89n00jhkvpxeja99ig7"},{"post_id":"cjszht84h006rkvpx2h40aylm","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89n00jikvpxt5fyqdys"},{"post_id":"cjszht84h006rkvpx2h40aylm","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89n00jjkvpx7adcf1mf"},{"post_id":"cjszht84h006rkvpx2h40aylm","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht89n00jkkvpx4rt2i4rz"},{"post_id":"cjszht84j006xkvpxiuazt88r","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89n00jlkvpxg6am5gen"},{"post_id":"cjszht84j006xkvpxiuazt88r","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89n00jmkvpxeu77wylf"},{"post_id":"cjszht84k0071kvpxbendkcp4","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89n00jnkvpxhg0625fn"},{"post_id":"cjszht84k0071kvpxbendkcp4","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89n00jokvpxv0cld0wk"},{"post_id":"cjszht84w007fkvpxm46bxvur","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89n00jpkvpxhqzvonvk"},{"post_id":"cjszht84w007fkvpxm46bxvur","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89n00jqkvpx049yrj1a"},{"post_id":"cjszht84w007fkvpxm46bxvur","tag_id":"cjszht88w00hskvpxpkipvxjo","_id":"cjszht89n00jrkvpx2gqh5cc9"},{"post_id":"cjszht84w007fkvpxm46bxvur","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht89n00jskvpxvi37v2f8"},{"post_id":"cjszht84x007ikvpx9sfhegk4","tag_id":"cjszht837003zkvpx5zycahj1","_id":"cjszht89n00jtkvpxrgdla7sa"},{"post_id":"cjszht84x007ikvpx9sfhegk4","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht89n00jukvpxend4dzpd"},{"post_id":"cjszht84x007ikvpx9sfhegk4","tag_id":"cjszht83d004dkvpxtjo78ek0","_id":"cjszht89n00jvkvpxdxxdn54p"},{"post_id":"cjszht84x007ikvpx9sfhegk4","tag_id":"cjszht88w00hskvpxpkipvxjo","_id":"cjszht89o00jwkvpx91rv1bmr"},{"post_id":"cjszht85e0083kvpxrgzvk3yb","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89o00jxkvpx6a2jwt2c"},{"post_id":"cjszht85e0083kvpxrgzvk3yb","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht89o00jykvpxvstzkjwh"},{"post_id":"cjszht85e0083kvpxrgzvk3yb","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht89o00jzkvpxuv87xrac"},{"post_id":"cjszht85e0083kvpxrgzvk3yb","tag_id":"cjszht86x00c0kvpxwyl6t4uq","_id":"cjszht89o00k0kvpx9yz45hn5"},{"post_id":"cjszht85h008akvpxdkz864m2","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89o00k1kvpx64tzcmww"},{"post_id":"cjszht85h008akvpxdkz864m2","tag_id":"cjszht83l0050kvpx8l4u1p1q","_id":"cjszht89o00k2kvpxr8ud6okm"},{"post_id":"cjszht85h008akvpxdkz864m2","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89o00k3kvpxrg7rn8uw"},{"post_id":"cjszht85h008akvpxdkz864m2","tag_id":"cjszht89300i1kvpxh6llk2xk","_id":"cjszht89o00k4kvpxtvfd0ty7"},{"post_id":"cjszht85k008hkvpxosomlnhe","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89o00k5kvpxaqjvibzv"},{"post_id":"cjszht85k008hkvpxosomlnhe","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht89o00k6kvpxl464uy8l"},{"post_id":"cjszht85k008hkvpxosomlnhe","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89o00k7kvpxwsmo6xal"},{"post_id":"cjszht85k008hkvpxosomlnhe","tag_id":"cjszht89400i4kvpxnkwb36hi","_id":"cjszht89o00k8kvpxh25oydou"},{"post_id":"cjszht85s008skvpxd9avk1s6","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89o00k9kvpx9vsixtgu"},{"post_id":"cjszht85s008skvpxd9avk1s6","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89o00kakvpxp68owydz"},{"post_id":"cjszht85s008skvpxd9avk1s6","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht89o00kbkvpxin5v96qj"},{"post_id":"cjszht85s008skvpxd9avk1s6","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht89o00kckvpx9vr0j1ng"},{"post_id":"cjszht85t008vkvpx55s4jr3c","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89o00kdkvpx4boknu0f"},{"post_id":"cjszht85t008vkvpx55s4jr3c","tag_id":"cjszht81y001ykvpxzdzydph3","_id":"cjszht89p00kekvpxojvs9e5m"},{"post_id":"cjszht85t008vkvpx55s4jr3c","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89p00kfkvpx4hwx4aei"},{"post_id":"cjszht85u008zkvpxkqlx16bd","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89p00kgkvpx63lf9h3l"},{"post_id":"cjszht85u008zkvpxkqlx16bd","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89p00khkvpxzye95ve5"},{"post_id":"cjszht85v0092kvpx499v4kpk","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89p00kikvpxztqf91df"},{"post_id":"cjszht85v0092kvpx499v4kpk","tag_id":"cjszht85w0094kvpxdo2xb1gx","_id":"cjszht89p00kjkvpxcdxio59c"},{"post_id":"cjszht85x0096kvpxdy5f7hi5","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89p00kkkvpxr9xivcon"},{"post_id":"cjszht85x0096kvpxdy5f7hi5","tag_id":"cjszht7zw000nkvpxlk21cqp7","_id":"cjszht89p00klkvpxb2wcfkp9"},{"post_id":"cjszht85x0096kvpxdy5f7hi5","tag_id":"cjszht805000tkvpxewszx2wy","_id":"cjszht89p00kmkvpxj1ldaqub"},{"post_id":"cjszht85x0096kvpxdy5f7hi5","tag_id":"cjszht82o0034kvpxhcdahtoa","_id":"cjszht89p00knkvpxd049cz1n"},{"post_id":"cjszht85z009dkvpxq0zyr66f","tag_id":"cjszht7zo000gkvpxz2whkarm","_id":"cjszht89p00kokvpxe8z7yqog"},{"post_id":"cjszht85z009dkvpxq0zyr66f","tag_id":"cjszht82t003bkvpxqmqj3okz","_id":"cjszht89p00kpkvpx5r9m41s3"},{"post_id":"cjszht85z009dkvpxq0zyr66f","tag_id":"cjszht88w00hskvpxpkipvxjo","_id":"cjszht89p00kqkvpxjqnqthje"},{"post_id":"cjszht85z009dkvpxq0zyr66f","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht89p00krkvpxwr6e8mmv"},{"post_id":"cjszht86b00a1kvpx4kr7239k","tag_id":"cjszht862009ikvpxv7c5ikoh","_id":"cjszht89p00kskvpxhs86badb"},{"post_id":"cjszht86b00a1kvpx4kr7239k","tag_id":"cjszht83j004tkvpxtify6qz9","_id":"cjszht89p00ktkvpx00lm7giq"},{"post_id":"cjszht86b00a1kvpx4kr7239k","tag_id":"cjszht844005ykvpxkuhydwm1","_id":"cjszht89p00kukvpxzm2no8ox"},{"post_id":"cjszht86b00a1kvpx4kr7239k","tag_id":"cjszht84h006qkvpxuuf8fb2z","_id":"cjszht89p00kvkvpxuyd1a01o"},{"post_id":"cjszht86b00a1kvpx4kr7239k","tag_id":"cjszht87000clkvpxyyljylzk","_id":"cjszht89p00kwkvpxwtf0pj6a"},{"post_id":"cjszht86n00amkvpx83hsvp08","tag_id":"cjszht7z40006kvpx0rkbji89","_id":"cjszht89p00kxkvpx9qj2rb06"},{"post_id":"cjszht86n00amkvpx83hsvp08","tag_id":"cjszht7zh000bkvpxhgdn07kf","_id":"cjszht89q00kykvpxdm80vw4l"},{"post_id":"cjszht86n00amkvpx83hsvp08","tag_id":"cjszht89i00itkvpxilieirvc","_id":"cjszht89q00kzkvpx5fxzy2sk"},{"post_id":"cjszht8gs00l0kvpxcgmq8k74","tag_id":"cjszht8h100l2kvpxkbac144w","_id":"cjszht8h900l3kvpxilml4k6t"}],"Tag":[{"name":"intent","_id":"cjszht7z40006kvpx0rkbji89"},{"name":"slot","_id":"cjszht7zh000bkvpxhgdn07kf"},{"name":"medium","_id":"cjszht7zo000gkvpxz2whkarm"},{"name":"array","_id":"cjszht7zw000nkvpxlk21cqp7"},{"name":"two pointers","_id":"cjszht805000tkvpxewszx2wy"},{"name":"hash table","_id":"cjszht81y001ykvpxzdzydph3"},{"name":"binary search","_id":"cjszht82c002fkvpxvs1ilg3i"},{"name":"hashed table","_id":"cjszht82m002ykvpxhssyygp8"},{"name":"stack","_id":"cjszht82o0034kvpxhcdahtoa"},{"name":"tree","_id":"cjszht82t003bkvpxqmqj3okz"},{"name":"bfs","_id":"cjszht835003ukvpxfl17whuf"},{"name":"easy","_id":"cjszht837003zkvpx5zycahj1"},{"name":"dfs","_id":"cjszht83d004dkvpxtjo78ek0"},{"name":"string","_id":"cjszht83j004tkvpxtify6qz9"},{"name":"math","_id":"cjszht83l0050kvpx8l4u1p1q"},{"name":"dynamic programming","_id":"cjszht844005ykvpxkuhydwm1"},{"name":"back tracking","_id":"cjszht84h006qkvpxuuf8fb2z"},{"name":"linked list","_id":"cjszht85w0094kvpxdo2xb1gx"},{"name":"hard","_id":"cjszht862009ikvpxv7c5ikoh"},{"name":"binary","_id":"cjszht86v00blkvpxh0hbu8p5"},{"name":"sort","_id":"cjszht86x00c0kvpxwyl6t4uq"},{"name":"greedy","_id":"cjszht87000clkvpxyyljylzk"},{"name":"divide and conquer","_id":"cjszht87f00erkvpx3btfnuuq"},{"name":"heap","_id":"cjszht87r00fjkvpxlrzkgek8"},{"name":"recursion","_id":"cjszht88w00hskvpxpkipvxjo"},{"name":"regular expression","_id":"cjszht89300i1kvpxh6llk2xk"},{"name":"bit manipulation","_id":"cjszht89400i4kvpxnkwb36hi"},{"name":"task-oriented","_id":"cjszht89i00itkvpxilieirvc"},{"name":"tools","_id":"cjszht8h100l2kvpxkbac144w"}]}}